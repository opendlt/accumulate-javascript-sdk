import BN from "bn.js";
import {
  Account,
  AccountAuthOperation,
  AccountAuthOperationType,
  AccountType,
  AllowedTransactions,
  AnchorBody,
  BookType,
  DataEntry,
  DataEntryType,
  Fee,
  KeyPageOperation,
  KeyPageOperationType,
  PartitionType,
  Signature,
  SignatureType,
  Signer,
  TransactionBody,
  TransactionResult,
  TransactionType,
  VoteType,
} from ".";
import * as errors2 from "../errors";
import * as managed from "../managed";
import { TxID, URL } from "../url";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */

export namespace ADI {
  export type Args = {
    url: URL | string;
    authorities: (AuthorityEntry | AuthorityEntry.Args)[];
  };
  export type ArgsWithType = Args & { type: AccountType.Identity | "identity" };
}
export class ADI {
  public readonly type = AccountType.Identity;
  public url: URL;
  public authorities: AuthorityEntry[];

  constructor(args: ADI.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.authorities = args.authorities.map((v) =>
      v instanceof AuthorityEntry ? v : new AuthorityEntry(v)
    );
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      authorities: this.authorities?.map((v) => v.asObject()),
    };
  }
}

export namespace AccountAuth {
  export type Args = {
    authorities: (AuthorityEntry | AuthorityEntry.Args)[];
  };
}
export class AccountAuth {
  public authorities: AuthorityEntry[];

  constructor(args: AccountAuth.Args) {
    this.authorities = args.authorities.map((v) =>
      v instanceof AuthorityEntry ? v : new AuthorityEntry(v)
    );
  }

  asObject() {
    return {
      authorities: this.authorities?.map((v) => v.asObject()),
    };
  }
}

export namespace AccumulateDataEntry {
  export type Args = {
    data: (Uint8Array | string)[];
  };
  export type ArgsWithType = Args & { type: DataEntryType.Accumulate | "accumulate" };
}
export class AccumulateDataEntry {
  public readonly type = DataEntryType.Accumulate;
  public data: Uint8Array[];

  constructor(args: AccumulateDataEntry.Args) {
    this.data = args.data.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
  }

  asObject() {
    return {
      type: this.type,
      data: this.data?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export namespace AcmeFaucet {
  export type Args = {
    url: URL | string;
  };
  export type ArgsWithType = Args & { type: TransactionType.AcmeFaucet | "acmeFaucet" };
}
export class AcmeFaucet {
  public readonly type = TransactionType.AcmeFaucet;
  public url: URL;

  constructor(args: AcmeFaucet.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
    };
  }
}

export namespace AcmeOracle {
  export type Args = {
    price: number;
  };
}
export class AcmeOracle {
  public price: number;

  constructor(args: AcmeOracle.Args) {
    this.price = args.price;
  }

  asObject() {
    return {
      price: this.price,
    };
  }
}

export namespace AddAccountAuthorityOperation {
  export type Args = {
    authority: URL | string;
  };
  export type ArgsWithType = Args & {
    type: AccountAuthOperationType.AddAuthority | "addAuthority";
  };
}
export class AddAccountAuthorityOperation {
  public readonly type = AccountAuthOperationType.AddAuthority;
  public authority: URL;

  constructor(args: AddAccountAuthorityOperation.Args) {
    this.authority = args.authority instanceof URL ? args.authority : new URL(args.authority);
  }

  asObject() {
    return {
      type: this.type,
      authority: this.authority.toString(),
    };
  }
}

export namespace AddCredits {
  export type Args = {
    recipient: URL | string;
    amount: BN | string;
    oracle: number;
  };
  export type ArgsWithType = Args & { type: TransactionType.AddCredits | "addCredits" };
}
export class AddCredits {
  public readonly type = TransactionType.AddCredits;
  public recipient: URL;
  public amount: BN;
  public oracle?: number;

  constructor(args: AddCredits.Args) {
    this.recipient = args.recipient instanceof URL ? args.recipient : new URL(args.recipient);
    this.amount = args.amount instanceof BN ? args.amount : new BN(args.amount);
    this.oracle = args.oracle;
  }

  asObject() {
    return {
      type: this.type,
      recipient: this.recipient.toString(),
      amount: this.amount.toString(),
      oracle: this.oracle && this.oracle,
    };
  }
}

export namespace AddCreditsResult {
  export type Args = {
    amount: BN | string;
    credits: number;
    oracle: number;
  };
  export type ArgsWithType = Args & { type: TransactionType.AddCredits | "addCredits" };
}
export class AddCreditsResult {
  public readonly type = TransactionType.AddCredits;
  public amount: BN;
  public credits: number;
  public oracle: number;

  constructor(args: AddCreditsResult.Args) {
    this.amount = args.amount instanceof BN ? args.amount : new BN(args.amount);
    this.credits = args.credits;
    this.oracle = args.oracle;
  }

  asObject() {
    return {
      type: this.type,
      amount: this.amount.toString(),
      credits: this.credits,
      oracle: this.oracle,
    };
  }
}

export namespace AddKeyOperation {
  export type Args = {
    entry: KeySpecParams | KeySpecParams.Args;
  };
  export type ArgsWithType = Args & { type: KeyPageOperationType.Add | "add" };
}
export class AddKeyOperation {
  public readonly type = KeyPageOperationType.Add;
  public entry: KeySpecParams;

  constructor(args: AddKeyOperation.Args) {
    this.entry = args.entry instanceof KeySpecParams ? args.entry : new KeySpecParams(args.entry);
  }

  asObject() {
    return {
      type: this.type,
      entry: this.entry.asObject(),
    };
  }
}

export namespace AnchorLedger {
  export type Args = {
    url: URL | string;
    minorBlockSequenceNumber: number;
    majorBlockIndex: number;
    majorBlockTime: Date | string;
    pendingMajorBlockAnchors: (URL | string)[];
    sequence: (PartitionSyntheticLedger | PartitionSyntheticLedger.Args)[];
  };
  export type ArgsWithType = Args & { type: AccountType.AnchorLedger | "anchorLedger" };
}
export class AnchorLedger {
  public readonly type = AccountType.AnchorLedger;
  public url: URL;
  public minorBlockSequenceNumber: number;
  public majorBlockIndex: number;
  public majorBlockTime: Date;
  public pendingMajorBlockAnchors: URL[];
  public sequence: PartitionSyntheticLedger[];

  constructor(args: AnchorLedger.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.minorBlockSequenceNumber = args.minorBlockSequenceNumber;
    this.majorBlockIndex = args.majorBlockIndex;
    this.majorBlockTime =
      args.majorBlockTime instanceof Date ? args.majorBlockTime : new Date(args.majorBlockTime);
    this.pendingMajorBlockAnchors = args.pendingMajorBlockAnchors.map((v) =>
      v instanceof URL ? v : new URL(v)
    );
    this.sequence = args.sequence.map((v) =>
      v instanceof PartitionSyntheticLedger ? v : new PartitionSyntheticLedger(v)
    );
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      minorBlockSequenceNumber: this.minorBlockSequenceNumber,
      majorBlockIndex: this.majorBlockIndex,
      majorBlockTime: this.majorBlockTime,
      pendingMajorBlockAnchors: this.pendingMajorBlockAnchors?.map((v) => v.toString()),
      sequence: this.sequence?.map((v) => v.asObject()),
    };
  }
}

export namespace AuthorityEntry {
  export type Args = {
    url: URL | string;
    disabled: boolean;
  };
}
export class AuthorityEntry {
  public url: URL;
  public disabled: boolean;

  constructor(args: AuthorityEntry.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.disabled = args.disabled;
  }

  asObject() {
    return {
      url: this.url.toString(),
      disabled: this.disabled,
    };
  }
}

export namespace BTCLegacySignature {
  export type Args = {
    publicKey: Uint8Array | string;
    signature: Uint8Array | string;
    signer: URL | string;
    signerVersion: number;
    timestamp: number;
    vote: VoteType.Args;
    transactionHash: Uint8Array | string;
  };
  export type ArgsWithType = Args & { type: SignatureType.BTCLegacy | "btclegacy" };
}
export class BTCLegacySignature {
  public readonly type = SignatureType.BTCLegacy;
  public publicKey: Uint8Array;
  public signature: Uint8Array;
  public signer: URL;
  public signerVersion: number;
  public timestamp?: number;
  public vote?: VoteType;
  public transactionHash?: Uint8Array;

  constructor(args: BTCLegacySignature.Args) {
    this.publicKey =
      args.publicKey instanceof Uint8Array ? args.publicKey : Buffer.from(args.publicKey, "hex");
    this.signature =
      args.signature instanceof Uint8Array ? args.signature : Buffer.from(args.signature, "hex");
    this.signer = args.signer instanceof URL ? args.signer : new URL(args.signer);
    this.signerVersion = args.signerVersion;
    this.timestamp = args.timestamp;
    this.vote = VoteType.fromObject(args.vote);
    this.transactionHash =
      args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  asObject() {
    return {
      type: this.type,
      publicKey: Buffer.from(this.publicKey).toString("hex"),
      signature: Buffer.from(this.signature).toString("hex"),
      signer: this.signer.toString(),
      signerVersion: this.signerVersion,
      timestamp: this.timestamp && this.timestamp,
      vote: this.vote && this.vote.toString(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export namespace BTCSignature {
  export type Args = {
    publicKey: Uint8Array | string;
    signature: Uint8Array | string;
    signer: URL | string;
    signerVersion: number;
    timestamp: number;
    vote: VoteType.Args;
    transactionHash: Uint8Array | string;
  };
  export type ArgsWithType = Args & { type: SignatureType.BTC | "btc" };
}
export class BTCSignature {
  public readonly type = SignatureType.BTC;
  public publicKey: Uint8Array;
  public signature: Uint8Array;
  public signer: URL;
  public signerVersion: number;
  public timestamp?: number;
  public vote?: VoteType;
  public transactionHash?: Uint8Array;

  constructor(args: BTCSignature.Args) {
    this.publicKey =
      args.publicKey instanceof Uint8Array ? args.publicKey : Buffer.from(args.publicKey, "hex");
    this.signature =
      args.signature instanceof Uint8Array ? args.signature : Buffer.from(args.signature, "hex");
    this.signer = args.signer instanceof URL ? args.signer : new URL(args.signer);
    this.signerVersion = args.signerVersion;
    this.timestamp = args.timestamp;
    this.vote = VoteType.fromObject(args.vote);
    this.transactionHash =
      args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  asObject() {
    return {
      type: this.type,
      publicKey: Buffer.from(this.publicKey).toString("hex"),
      signature: Buffer.from(this.signature).toString("hex"),
      signer: this.signer.toString(),
      signerVersion: this.signerVersion,
      timestamp: this.timestamp && this.timestamp,
      vote: this.vote && this.vote.toString(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export namespace BlockEntry {
  export type Args = {
    account: URL | string;
    chain: string;
    index: number;
  };
}
export class BlockEntry {
  public account: URL;
  public chain: string;
  public index: number;

  constructor(args: BlockEntry.Args) {
    this.account = args.account instanceof URL ? args.account : new URL(args.account);
    this.chain = args.chain;
    this.index = args.index;
  }

  asObject() {
    return {
      account: this.account.toString(),
      chain: this.chain,
      index: this.index,
    };
  }
}

export namespace BlockLedger {
  export type Args = {
    url: URL | string;
    index: number;
    time: Date | string;
    entries: (BlockEntry | BlockEntry.Args)[];
  };
  export type ArgsWithType = Args & { type: AccountType.BlockLedger | "blockLedger" };
}
export class BlockLedger {
  public readonly type = AccountType.BlockLedger;
  public url: URL;
  public index: number;
  public time: Date;
  public entries: BlockEntry[];

  constructor(args: BlockLedger.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.index = args.index;
    this.time = args.time instanceof Date ? args.time : new Date(args.time);
    this.entries = args.entries.map((v) => (v instanceof BlockEntry ? v : new BlockEntry(v)));
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      index: this.index,
      time: this.time,
      entries: this.entries?.map((v) => v.asObject()),
    };
  }
}

export namespace BlockValidatorAnchor {
  export type Args = {
    source: URL | string;
    majorBlockIndex: number;
    minorBlockIndex: number;
    rootChainIndex: number;
    rootChainAnchor: Uint8Array | string;
    stateTreeAnchor: Uint8Array | string;
    acmeBurnt: BN | string;
  };
  export type ArgsWithType = Args & {
    type: TransactionType.BlockValidatorAnchor | "blockValidatorAnchor";
  };
}
export class BlockValidatorAnchor {
  public readonly type = TransactionType.BlockValidatorAnchor;
  public source: URL;
  public majorBlockIndex: number;
  public minorBlockIndex: number;
  public rootChainIndex: number;
  public rootChainAnchor: Uint8Array;
  public stateTreeAnchor: Uint8Array;
  public acmeBurnt: BN;

  constructor(args: BlockValidatorAnchor.Args) {
    this.source = args.source instanceof URL ? args.source : new URL(args.source);
    this.majorBlockIndex = args.majorBlockIndex;
    this.minorBlockIndex = args.minorBlockIndex;
    this.rootChainIndex = args.rootChainIndex;
    this.rootChainAnchor =
      args.rootChainAnchor instanceof Uint8Array
        ? args.rootChainAnchor
        : Buffer.from(args.rootChainAnchor, "hex");
    this.stateTreeAnchor =
      args.stateTreeAnchor instanceof Uint8Array
        ? args.stateTreeAnchor
        : Buffer.from(args.stateTreeAnchor, "hex");
    this.acmeBurnt = args.acmeBurnt instanceof BN ? args.acmeBurnt : new BN(args.acmeBurnt);
  }

  asObject() {
    return {
      type: this.type,
      source: this.source.toString(),
      majorBlockIndex: this.majorBlockIndex,
      minorBlockIndex: this.minorBlockIndex,
      rootChainIndex: this.rootChainIndex,
      rootChainAnchor: Buffer.from(this.rootChainAnchor).toString("hex"),
      stateTreeAnchor: Buffer.from(this.stateTreeAnchor).toString("hex"),
      acmeBurnt: this.acmeBurnt.toString(),
    };
  }
}

export namespace BurnTokens {
  export type Args = {
    amount: BN | string;
  };
  export type ArgsWithType = Args & { type: TransactionType.BurnTokens | "burnTokens" };
}
export class BurnTokens {
  public readonly type = TransactionType.BurnTokens;
  public amount: BN;

  constructor(args: BurnTokens.Args) {
    this.amount = args.amount instanceof BN ? args.amount : new BN(args.amount);
  }

  asObject() {
    return {
      type: this.type,
      amount: this.amount.toString(),
    };
  }
}

export namespace ChainParams {
  export type Args = {
    data: Uint8Array | string;
    isUpdate: boolean;
  };
}
export class ChainParams {
  public data: Uint8Array;
  public isUpdate: boolean;

  constructor(args: ChainParams.Args) {
    this.data = args.data instanceof Uint8Array ? args.data : Buffer.from(args.data, "hex");
    this.isUpdate = args.isUpdate;
  }

  asObject() {
    return {
      data: Buffer.from(this.data).toString("hex"),
      isUpdate: this.isUpdate,
    };
  }
}

export namespace CreateDataAccount {
  export type Args = {
    url: URL | string;
    authorities: (URL | string)[];
  };
  export type ArgsWithType = Args & {
    type: TransactionType.CreateDataAccount | "createDataAccount";
  };
}
export class CreateDataAccount {
  public readonly type = TransactionType.CreateDataAccount;
  public url: URL;
  public authorities?: URL[];

  constructor(args: CreateDataAccount.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.authorities = args.authorities.map((v) => (v instanceof URL ? v : new URL(v)));
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      authorities: this.authorities?.map((v) => v.toString()),
    };
  }
}

export namespace CreateIdentity {
  export type Args = {
    url: URL | string;
    keyHash: Uint8Array | string;
    keyBookUrl: URL | string;
    authorities: (URL | string)[];
  };
  export type ArgsWithType = Args & { type: TransactionType.CreateIdentity | "createIdentity" };
}
export class CreateIdentity {
  public readonly type = TransactionType.CreateIdentity;
  public url: URL;
  public keyHash?: Uint8Array;
  public keyBookUrl?: URL;
  public authorities?: URL[];

  constructor(args: CreateIdentity.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.keyHash =
      args.keyHash instanceof Uint8Array ? args.keyHash : Buffer.from(args.keyHash, "hex");
    this.keyBookUrl = args.keyBookUrl instanceof URL ? args.keyBookUrl : new URL(args.keyBookUrl);
    this.authorities = args.authorities.map((v) => (v instanceof URL ? v : new URL(v)));
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      keyHash: this.keyHash && Buffer.from(this.keyHash).toString("hex"),
      keyBookUrl: this.keyBookUrl && this.keyBookUrl.toString(),
      authorities: this.authorities?.map((v) => v.toString()),
    };
  }
}

export namespace CreateKeyBook {
  export type Args = {
    url: URL | string;
    publicKeyHash: Uint8Array | string;
    authorities: (URL | string)[];
  };
  export type ArgsWithType = Args & { type: TransactionType.CreateKeyBook | "createKeyBook" };
}
export class CreateKeyBook {
  public readonly type = TransactionType.CreateKeyBook;
  public url: URL;
  public publicKeyHash: Uint8Array;
  public authorities?: URL[];

  constructor(args: CreateKeyBook.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.publicKeyHash =
      args.publicKeyHash instanceof Uint8Array
        ? args.publicKeyHash
        : Buffer.from(args.publicKeyHash, "hex");
    this.authorities = args.authorities.map((v) => (v instanceof URL ? v : new URL(v)));
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      publicKeyHash: Buffer.from(this.publicKeyHash).toString("hex"),
      authorities: this.authorities?.map((v) => v.toString()),
    };
  }
}

export namespace CreateKeyPage {
  export type Args = {
    keys: (KeySpecParams | KeySpecParams.Args)[];
  };
  export type ArgsWithType = Args & { type: TransactionType.CreateKeyPage | "createKeyPage" };
}
export class CreateKeyPage {
  public readonly type = TransactionType.CreateKeyPage;
  public keys: KeySpecParams[];

  constructor(args: CreateKeyPage.Args) {
    this.keys = args.keys.map((v) => (v instanceof KeySpecParams ? v : new KeySpecParams(v)));
  }

  asObject() {
    return {
      type: this.type,
      keys: this.keys?.map((v) => v.asObject()),
    };
  }
}

export namespace CreateLiteTokenAccount {
  export type Args = Record<string, never>;
  export type ArgsWithType = Args & {
    type: TransactionType.CreateLiteTokenAccount | "createLiteTokenAccount";
  };
}
export class CreateLiteTokenAccount {
  public readonly type = TransactionType.CreateLiteTokenAccount;

  constructor(_: CreateLiteTokenAccount.Args) {}

  asObject() {
    return {
      type: this.type,
    };
  }
}

export namespace CreateToken {
  export type Args = {
    url: URL | string;
    symbol: string;
    precision: number;
    properties: URL | string;
    supplyLimit: BN | string;
    authorities: (URL | string)[];
  };
  export type ArgsWithType = Args & { type: TransactionType.CreateToken | "createToken" };
}
export class CreateToken {
  public readonly type = TransactionType.CreateToken;
  public url: URL;
  public symbol: string;
  public precision: number;
  public properties?: URL;
  public supplyLimit?: BN;
  public authorities?: URL[];

  constructor(args: CreateToken.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.symbol = args.symbol;
    this.precision = args.precision;
    this.properties = args.properties instanceof URL ? args.properties : new URL(args.properties);
    this.supplyLimit = args.supplyLimit instanceof BN ? args.supplyLimit : new BN(args.supplyLimit);
    this.authorities = args.authorities.map((v) => (v instanceof URL ? v : new URL(v)));
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      symbol: this.symbol,
      precision: this.precision,
      properties: this.properties && this.properties.toString(),
      supplyLimit: this.supplyLimit && this.supplyLimit.toString(),
      authorities: this.authorities?.map((v) => v.toString()),
    };
  }
}

export namespace CreateTokenAccount {
  export type Args = {
    url: URL | string;
    tokenUrl: URL | string;
    authorities: (URL | string)[];
    proof: TokenIssuerProof | TokenIssuerProof.Args;
  };
  export type ArgsWithType = Args & {
    type: TransactionType.CreateTokenAccount | "createTokenAccount";
  };
}
export class CreateTokenAccount {
  public readonly type = TransactionType.CreateTokenAccount;
  public url: URL;
  public tokenUrl: URL;
  public authorities?: URL[];
  public proof?: TokenIssuerProof;

  constructor(args: CreateTokenAccount.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.tokenUrl = args.tokenUrl instanceof URL ? args.tokenUrl : new URL(args.tokenUrl);
    this.authorities = args.authorities.map((v) => (v instanceof URL ? v : new URL(v)));
    this.proof =
      args.proof instanceof TokenIssuerProof ? args.proof : new TokenIssuerProof(args.proof);
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      tokenUrl: this.tokenUrl.toString(),
      authorities: this.authorities?.map((v) => v.toString()),
      proof: this.proof && this.proof.asObject(),
    };
  }
}

export namespace DataAccount {
  export type Args = {
    url: URL | string;
    authorities: (AuthorityEntry | AuthorityEntry.Args)[];
    entry: DataEntry.Args;
  };
  export type ArgsWithType = Args & { type: AccountType.DataAccount | "dataAccount" };
}
export class DataAccount {
  public readonly type = AccountType.DataAccount;
  public url: URL;
  public authorities: AuthorityEntry[];
  public entry?: DataEntry;

  constructor(args: DataAccount.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.authorities = args.authorities.map((v) =>
      v instanceof AuthorityEntry ? v : new AuthorityEntry(v)
    );
    this.entry = DataEntry.fromObject(args.entry);
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      authorities: this.authorities?.map((v) => v.asObject()),
      entry: this.entry && this.entry.asObject(),
    };
  }
}

export namespace DelegatedSignature {
  export type Args = {
    signature: Signature.Args;
    delegator: URL | string;
  };
  export type ArgsWithType = Args & { type: SignatureType.Delegated | "delegated" };
}
export class DelegatedSignature {
  public readonly type = SignatureType.Delegated;
  public signature: Signature;
  public delegator: URL;

  constructor(args: DelegatedSignature.Args) {
    this.signature = Signature.fromObject(args.signature);
    this.delegator = args.delegator instanceof URL ? args.delegator : new URL(args.delegator);
  }

  asObject() {
    return {
      type: this.type,
      signature: this.signature.asObject(),
      delegator: this.delegator.toString(),
    };
  }
}

export namespace DirectoryAnchor {
  export type Args = {
    source: URL | string;
    majorBlockIndex: number;
    minorBlockIndex: number;
    rootChainIndex: number;
    rootChainAnchor: Uint8Array | string;
    stateTreeAnchor: Uint8Array | string;
    updates: (NetworkAccountUpdate | NetworkAccountUpdate.Args)[];
    receipts: (PartitionAnchorReceipt | PartitionAnchorReceipt.Args)[];
    makeMajorBlock: number;
    makeMajorBlockTime: Date | string;
  };
  export type ArgsWithType = Args & { type: TransactionType.DirectoryAnchor | "directoryAnchor" };
}
export class DirectoryAnchor {
  public readonly type = TransactionType.DirectoryAnchor;
  public source: URL;
  public majorBlockIndex: number;
  public minorBlockIndex: number;
  public rootChainIndex: number;
  public rootChainAnchor: Uint8Array;
  public stateTreeAnchor: Uint8Array;
  public updates: NetworkAccountUpdate[];
  public receipts: PartitionAnchorReceipt[];
  public makeMajorBlock: number;
  public makeMajorBlockTime: Date;

  constructor(args: DirectoryAnchor.Args) {
    this.source = args.source instanceof URL ? args.source : new URL(args.source);
    this.majorBlockIndex = args.majorBlockIndex;
    this.minorBlockIndex = args.minorBlockIndex;
    this.rootChainIndex = args.rootChainIndex;
    this.rootChainAnchor =
      args.rootChainAnchor instanceof Uint8Array
        ? args.rootChainAnchor
        : Buffer.from(args.rootChainAnchor, "hex");
    this.stateTreeAnchor =
      args.stateTreeAnchor instanceof Uint8Array
        ? args.stateTreeAnchor
        : Buffer.from(args.stateTreeAnchor, "hex");
    this.updates = args.updates.map((v) =>
      v instanceof NetworkAccountUpdate ? v : new NetworkAccountUpdate(v)
    );
    this.receipts = args.receipts.map((v) =>
      v instanceof PartitionAnchorReceipt ? v : new PartitionAnchorReceipt(v)
    );
    this.makeMajorBlock = args.makeMajorBlock;
    this.makeMajorBlockTime =
      args.makeMajorBlockTime instanceof Date
        ? args.makeMajorBlockTime
        : new Date(args.makeMajorBlockTime);
  }

  asObject() {
    return {
      type: this.type,
      source: this.source.toString(),
      majorBlockIndex: this.majorBlockIndex,
      minorBlockIndex: this.minorBlockIndex,
      rootChainIndex: this.rootChainIndex,
      rootChainAnchor: Buffer.from(this.rootChainAnchor).toString("hex"),
      stateTreeAnchor: Buffer.from(this.stateTreeAnchor).toString("hex"),
      updates: this.updates?.map((v) => v.asObject()),
      receipts: this.receipts?.map((v) => v.asObject()),
      makeMajorBlock: this.makeMajorBlock,
      makeMajorBlockTime: this.makeMajorBlockTime,
    };
  }
}

export namespace DisableAccountAuthOperation {
  export type Args = {
    authority: URL | string;
  };
  export type ArgsWithType = Args & { type: AccountAuthOperationType.Disable | "disable" };
}
export class DisableAccountAuthOperation {
  public readonly type = AccountAuthOperationType.Disable;
  public authority: URL;

  constructor(args: DisableAccountAuthOperation.Args) {
    this.authority = args.authority instanceof URL ? args.authority : new URL(args.authority);
  }

  asObject() {
    return {
      type: this.type,
      authority: this.authority.toString(),
    };
  }
}

export namespace ED25519Signature {
  export type Args = {
    publicKey: Uint8Array | string;
    signature: Uint8Array | string;
    signer: URL | string;
    signerVersion: number;
    timestamp: number;
    vote: VoteType.Args;
    transactionHash: Uint8Array | string;
  };
  export type ArgsWithType = Args & { type: SignatureType.ED25519 | "ed25519" };
}
export class ED25519Signature {
  public readonly type = SignatureType.ED25519;
  public publicKey: Uint8Array;
  public signature: Uint8Array;
  public signer: URL;
  public signerVersion: number;
  public timestamp?: number;
  public vote?: VoteType;
  public transactionHash?: Uint8Array;

  constructor(args: ED25519Signature.Args) {
    this.publicKey =
      args.publicKey instanceof Uint8Array ? args.publicKey : Buffer.from(args.publicKey, "hex");
    this.signature =
      args.signature instanceof Uint8Array ? args.signature : Buffer.from(args.signature, "hex");
    this.signer = args.signer instanceof URL ? args.signer : new URL(args.signer);
    this.signerVersion = args.signerVersion;
    this.timestamp = args.timestamp;
    this.vote = VoteType.fromObject(args.vote);
    this.transactionHash =
      args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  asObject() {
    return {
      type: this.type,
      publicKey: Buffer.from(this.publicKey).toString("hex"),
      signature: Buffer.from(this.signature).toString("hex"),
      signer: this.signer.toString(),
      signerVersion: this.signerVersion,
      timestamp: this.timestamp && this.timestamp,
      vote: this.vote && this.vote.toString(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export namespace ETHSignature {
  export type Args = {
    publicKey: Uint8Array | string;
    signature: Uint8Array | string;
    signer: URL | string;
    signerVersion: number;
    timestamp: number;
    vote: VoteType.Args;
    transactionHash: Uint8Array | string;
  };
  export type ArgsWithType = Args & { type: SignatureType.ETH | "eth" };
}
export class ETHSignature {
  public readonly type = SignatureType.ETH;
  public publicKey: Uint8Array;
  public signature: Uint8Array;
  public signer: URL;
  public signerVersion: number;
  public timestamp?: number;
  public vote?: VoteType;
  public transactionHash?: Uint8Array;

  constructor(args: ETHSignature.Args) {
    this.publicKey =
      args.publicKey instanceof Uint8Array ? args.publicKey : Buffer.from(args.publicKey, "hex");
    this.signature =
      args.signature instanceof Uint8Array ? args.signature : Buffer.from(args.signature, "hex");
    this.signer = args.signer instanceof URL ? args.signer : new URL(args.signer);
    this.signerVersion = args.signerVersion;
    this.timestamp = args.timestamp;
    this.vote = VoteType.fromObject(args.vote);
    this.transactionHash =
      args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  asObject() {
    return {
      type: this.type,
      publicKey: Buffer.from(this.publicKey).toString("hex"),
      signature: Buffer.from(this.signature).toString("hex"),
      signer: this.signer.toString(),
      signerVersion: this.signerVersion,
      timestamp: this.timestamp && this.timestamp,
      vote: this.vote && this.vote.toString(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export namespace EmptyResult {
  export type Args = Record<string, never>;
  export type ArgsWithType = Args & { type: TransactionType.Unknown | "unknown" };
}
export class EmptyResult {
  public readonly type = TransactionType.Unknown;

  constructor(_: EmptyResult.Args) {}

  asObject() {
    return {
      type: this.type,
    };
  }
}

export namespace EnableAccountAuthOperation {
  export type Args = {
    authority: URL | string;
  };
  export type ArgsWithType = Args & { type: AccountAuthOperationType.Enable | "enable" };
}
export class EnableAccountAuthOperation {
  public readonly type = AccountAuthOperationType.Enable;
  public authority: URL;

  constructor(args: EnableAccountAuthOperation.Args) {
    this.authority = args.authority instanceof URL ? args.authority : new URL(args.authority);
  }

  asObject() {
    return {
      type: this.type,
      authority: this.authority.toString(),
    };
  }
}

export namespace Envelope {
  export type Args = {
    signatures: Signature.Args[];
    txHash: Uint8Array | string;
    transaction: (Transaction | Transaction.Args)[];
  };
}
export class Envelope {
  public signatures: Signature[];
  public txHash?: Uint8Array;
  public transaction?: Transaction[];

  constructor(args: Envelope.Args) {
    this.signatures = args.signatures.map((v) => Signature.fromObject(v));
    this.txHash = args.txHash instanceof Uint8Array ? args.txHash : Buffer.from(args.txHash, "hex");
    this.transaction = args.transaction.map((v) =>
      v instanceof Transaction ? v : new Transaction(v)
    );
  }

  asObject() {
    return {
      signatures: this.signatures?.map((v) => v.asObject()),
      txHash: this.txHash && Buffer.from(this.txHash).toString("hex"),
      transaction: this.transaction?.map((v) => v.asObject()),
    };
  }
}

export namespace FactomDataEntry {
  export type Args = {
    accountId: Uint8Array | string;
    data: Uint8Array | string;
    extIds: (Uint8Array | string)[];
  };
}
export class FactomDataEntry {
  public accountId: Uint8Array;
  public data: Uint8Array;
  public extIds: Uint8Array[];

  constructor(args: FactomDataEntry.Args) {
    this.accountId =
      args.accountId instanceof Uint8Array ? args.accountId : Buffer.from(args.accountId, "hex");
    this.data = args.data instanceof Uint8Array ? args.data : Buffer.from(args.data, "hex");
    this.extIds = args.extIds.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
  }

  asObject() {
    return {
      accountId: Buffer.from(this.accountId).toString("hex"),
      data: Buffer.from(this.data).toString("hex"),
      extIds: this.extIds?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export namespace FactomDataEntryWrapper {
  export type Args = {
    accountId: Uint8Array | string;
    data: Uint8Array | string;
    extIds: (Uint8Array | string)[];
  };
  export type ArgsWithType = Args & { type: DataEntryType.Factom | "factom" };
}
export class FactomDataEntryWrapper {
  public readonly type = DataEntryType.Factom;
  public accountId: Uint8Array;
  public data: Uint8Array;
  public extIds: Uint8Array[];

  constructor(args: FactomDataEntryWrapper.Args) {
    this.accountId =
      args.accountId instanceof Uint8Array ? args.accountId : Buffer.from(args.accountId, "hex");
    this.data = args.data instanceof Uint8Array ? args.data : Buffer.from(args.data, "hex");
    this.extIds = args.extIds.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
  }

  asObject() {
    return {
      type: this.type,
      accountId: Buffer.from(this.accountId).toString("hex"),
      data: Buffer.from(this.data).toString("hex"),
      extIds: this.extIds?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export namespace FeeSchedule {
  export type Args = {
    createIdentitySliding: Fee.Args[];
  };
}
export class FeeSchedule {
  public createIdentitySliding: Fee[];

  constructor(args: FeeSchedule.Args) {
    this.createIdentitySliding = args.createIdentitySliding.map((v) => Fee.fromObject(v));
  }

  asObject() {
    return {
      createIdentitySliding: this.createIdentitySliding?.map((v) => v.toString()),
    };
  }
}

export namespace IndexEntry {
  export type Args = {
    source: number;
    anchor: number;
    blockIndex: number;
    blockTime: Date | string;
    rootIndexIndex: number;
  };
}
export class IndexEntry {
  public source: number;
  public anchor: number;
  public blockIndex: number;
  public blockTime: Date;
  public rootIndexIndex: number;

  constructor(args: IndexEntry.Args) {
    this.source = args.source;
    this.anchor = args.anchor;
    this.blockIndex = args.blockIndex;
    this.blockTime = args.blockTime instanceof Date ? args.blockTime : new Date(args.blockTime);
    this.rootIndexIndex = args.rootIndexIndex;
  }

  asObject() {
    return {
      source: this.source,
      anchor: this.anchor,
      blockIndex: this.blockIndex,
      blockTime: this.blockTime,
      rootIndexIndex: this.rootIndexIndex,
    };
  }
}

export namespace InternalSignature {
  export type Args = {
    cause: Uint8Array | string;
    transactionHash: Uint8Array | string;
  };
  export type ArgsWithType = Args & { type: SignatureType.Internal | "internal" };
}
export class InternalSignature {
  public readonly type = SignatureType.Internal;
  public cause: Uint8Array;
  public transactionHash: Uint8Array;

  constructor(args: InternalSignature.Args) {
    this.cause = args.cause instanceof Uint8Array ? args.cause : Buffer.from(args.cause, "hex");
    this.transactionHash =
      args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  asObject() {
    return {
      type: this.type,
      cause: Buffer.from(this.cause).toString("hex"),
      transactionHash: Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export namespace IssueTokens {
  export type Args = {
    recipient: URL | string;
    amount: BN | string;
    to: (TokenRecipient | TokenRecipient.Args)[];
  };
  export type ArgsWithType = Args & { type: TransactionType.IssueTokens | "issueTokens" };
}
export class IssueTokens {
  public readonly type = TransactionType.IssueTokens;
  public recipient: URL;
  public amount: BN;
  public to: TokenRecipient[];

  constructor(args: IssueTokens.Args) {
    this.recipient = args.recipient instanceof URL ? args.recipient : new URL(args.recipient);
    this.amount = args.amount instanceof BN ? args.amount : new BN(args.amount);
    this.to = args.to.map((v) => (v instanceof TokenRecipient ? v : new TokenRecipient(v)));
  }

  asObject() {
    return {
      type: this.type,
      recipient: this.recipient.toString(),
      amount: this.amount.toString(),
      to: this.to?.map((v) => v.asObject()),
    };
  }
}

export namespace KeyBook {
  export type Args = {
    url: URL | string;
    bookType: BookType.Args;
    authorities: (AuthorityEntry | AuthorityEntry.Args)[];
    pageCount: number;
  };
  export type ArgsWithType = Args & { type: AccountType.KeyBook | "keyBook" };
}
export class KeyBook {
  public readonly type = AccountType.KeyBook;
  public url: URL;
  public bookType: BookType;
  public authorities: AuthorityEntry[];
  public pageCount: number;

  constructor(args: KeyBook.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.bookType = BookType.fromObject(args.bookType);
    this.authorities = args.authorities.map((v) =>
      v instanceof AuthorityEntry ? v : new AuthorityEntry(v)
    );
    this.pageCount = args.pageCount;
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      bookType: this.bookType.toString(),
      authorities: this.authorities?.map((v) => v.asObject()),
      pageCount: this.pageCount,
    };
  }
}

export namespace KeyPage {
  export type Args = {
    url: URL | string;
    creditBalance: number;
    acceptThreshold: number;
    rejectThreshold: number;
    responseThreshold: number;
    blockThreshold: number;
    version: number;
    keys: (KeySpec | KeySpec.Args)[];
    transactionBlacklist: AllowedTransactions.Args;
  };
  export type ArgsWithType = Args & { type: AccountType.KeyPage | "keyPage" };
}
export class KeyPage {
  public readonly type = AccountType.KeyPage;
  public url: URL;
  public creditBalance: number;
  public acceptThreshold: number;
  public rejectThreshold: number;
  public responseThreshold: number;
  public blockThreshold: number;
  public version: number;
  public keys: KeySpec[];
  public transactionBlacklist?: AllowedTransactions;

  constructor(args: KeyPage.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.creditBalance = args.creditBalance;
    this.acceptThreshold = args.acceptThreshold;
    this.rejectThreshold = args.rejectThreshold;
    this.responseThreshold = args.responseThreshold;
    this.blockThreshold = args.blockThreshold;
    this.version = args.version;
    this.keys = args.keys.map((v) => (v instanceof KeySpec ? v : new KeySpec(v)));
    this.transactionBlacklist = AllowedTransactions.fromObject(args.transactionBlacklist);
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      creditBalance: this.creditBalance,
      acceptThreshold: this.acceptThreshold,
      rejectThreshold: this.rejectThreshold,
      responseThreshold: this.responseThreshold,
      blockThreshold: this.blockThreshold,
      version: this.version,
      keys: this.keys?.map((v) => v.asObject()),
      transactionBlacklist: this.transactionBlacklist && this.transactionBlacklist.toString(),
    };
  }
}

export namespace KeySpec {
  export type Args = {
    publicKeyHash: Uint8Array | string;
    lastUsedOn: number;
    delegate: URL | string;
  };
}
export class KeySpec {
  public publicKeyHash: Uint8Array;
  public lastUsedOn: number;
  public delegate: URL;

  constructor(args: KeySpec.Args) {
    this.publicKeyHash =
      args.publicKeyHash instanceof Uint8Array
        ? args.publicKeyHash
        : Buffer.from(args.publicKeyHash, "hex");
    this.lastUsedOn = args.lastUsedOn;
    this.delegate = args.delegate instanceof URL ? args.delegate : new URL(args.delegate);
  }

  asObject() {
    return {
      publicKeyHash: Buffer.from(this.publicKeyHash).toString("hex"),
      lastUsedOn: this.lastUsedOn,
      delegate: this.delegate.toString(),
    };
  }
}

export namespace KeySpecParams {
  export type Args = {
    keyHash: Uint8Array | string;
    delegate: URL | string;
  };
}
export class KeySpecParams {
  public keyHash: Uint8Array;
  public delegate?: URL;

  constructor(args: KeySpecParams.Args) {
    this.keyHash =
      args.keyHash instanceof Uint8Array ? args.keyHash : Buffer.from(args.keyHash, "hex");
    this.delegate = args.delegate instanceof URL ? args.delegate : new URL(args.delegate);
  }

  asObject() {
    return {
      keyHash: Buffer.from(this.keyHash).toString("hex"),
      delegate: this.delegate && this.delegate.toString(),
    };
  }
}

export namespace LegacyED25519Signature {
  export type Args = {
    timestamp: number;
    publicKey: Uint8Array | string;
    signature: Uint8Array | string;
    signer: URL | string;
    signerVersion: number;
    vote: VoteType.Args;
    transactionHash: Uint8Array | string;
  };
  export type ArgsWithType = Args & { type: SignatureType.LegacyED25519 | "legacyED25519" };
}
export class LegacyED25519Signature {
  public readonly type = SignatureType.LegacyED25519;
  public timestamp: number;
  public publicKey: Uint8Array;
  public signature: Uint8Array;
  public signer: URL;
  public signerVersion: number;
  public vote?: VoteType;
  public transactionHash?: Uint8Array;

  constructor(args: LegacyED25519Signature.Args) {
    this.timestamp = args.timestamp;
    this.publicKey =
      args.publicKey instanceof Uint8Array ? args.publicKey : Buffer.from(args.publicKey, "hex");
    this.signature =
      args.signature instanceof Uint8Array ? args.signature : Buffer.from(args.signature, "hex");
    this.signer = args.signer instanceof URL ? args.signer : new URL(args.signer);
    this.signerVersion = args.signerVersion;
    this.vote = VoteType.fromObject(args.vote);
    this.transactionHash =
      args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  asObject() {
    return {
      type: this.type,
      timestamp: this.timestamp,
      publicKey: Buffer.from(this.publicKey).toString("hex"),
      signature: Buffer.from(this.signature).toString("hex"),
      signer: this.signer.toString(),
      signerVersion: this.signerVersion,
      vote: this.vote && this.vote.toString(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export namespace LiteDataAccount {
  export type Args = {
    url: URL | string;
  };
  export type ArgsWithType = Args & { type: AccountType.LiteDataAccount | "liteDataAccount" };
}
export class LiteDataAccount {
  public readonly type = AccountType.LiteDataAccount;
  public url: URL;

  constructor(args: LiteDataAccount.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
    };
  }
}

export namespace LiteIdentity {
  export type Args = {
    url: URL | string;
    creditBalance: number;
    lastUsedOn: number;
  };
  export type ArgsWithType = Args & { type: AccountType.LiteIdentity | "liteIdentity" };
}
export class LiteIdentity {
  public readonly type = AccountType.LiteIdentity;
  public url: URL;
  public creditBalance: number;
  public lastUsedOn: number;

  constructor(args: LiteIdentity.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.creditBalance = args.creditBalance;
    this.lastUsedOn = args.lastUsedOn;
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      creditBalance: this.creditBalance,
      lastUsedOn: this.lastUsedOn,
    };
  }
}

export namespace LiteTokenAccount {
  export type Args = {
    url: URL | string;
    tokenUrl: URL | string;
    balance: BN | string;
    lockHeight: number;
  };
  export type ArgsWithType = Args & { type: AccountType.LiteTokenAccount | "liteTokenAccount" };
}
export class LiteTokenAccount {
  public readonly type = AccountType.LiteTokenAccount;
  public url: URL;
  public tokenUrl: URL;
  public balance: BN;
  public lockHeight: number;

  constructor(args: LiteTokenAccount.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.tokenUrl = args.tokenUrl instanceof URL ? args.tokenUrl : new URL(args.tokenUrl);
    this.balance = args.balance instanceof BN ? args.balance : new BN(args.balance);
    this.lockHeight = args.lockHeight;
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      tokenUrl: this.tokenUrl.toString(),
      balance: this.balance.toString(),
      lockHeight: this.lockHeight,
    };
  }
}

export namespace LockAccount {
  export type Args = {
    height: number;
  };
  export type ArgsWithType = Args & { type: TransactionType.LockAccount | "lockAccount" };
}
export class LockAccount {
  public readonly type = TransactionType.LockAccount;
  public height: number;

  constructor(args: LockAccount.Args) {
    this.height = args.height;
  }

  asObject() {
    return {
      type: this.type,
      height: this.height,
    };
  }
}

export namespace NetworkAccountUpdate {
  export type Args = {
    name: string;
    body: TransactionBody.Args;
  };
}
export class NetworkAccountUpdate {
  public name: string;
  public body: TransactionBody;

  constructor(args: NetworkAccountUpdate.Args) {
    this.name = args.name;
    this.body = TransactionBody.fromObject(args.body);
  }

  asObject() {
    return {
      name: this.name,
      body: this.body.asObject(),
    };
  }
}

export namespace NetworkDefinition {
  export type Args = {
    networkName: string;
    version: number;
    partitions: (PartitionInfo | PartitionInfo.Args)[];
    validators: (ValidatorInfo | ValidatorInfo.Args)[];
  };
}
export class NetworkDefinition {
  public networkName: string;
  public version: number;
  public partitions: PartitionInfo[];
  public validators: ValidatorInfo[];

  constructor(args: NetworkDefinition.Args) {
    this.networkName = args.networkName;
    this.version = args.version;
    this.partitions = args.partitions.map((v) =>
      v instanceof PartitionInfo ? v : new PartitionInfo(v)
    );
    this.validators = args.validators.map((v) =>
      v instanceof ValidatorInfo ? v : new ValidatorInfo(v)
    );
  }

  asObject() {
    return {
      networkName: this.networkName,
      version: this.version,
      partitions: this.partitions?.map((v) => v.asObject()),
      validators: this.validators?.map((v) => v.asObject()),
    };
  }
}

export namespace NetworkGlobals {
  export type Args = {
    operatorAcceptThreshold: Rational | Rational.Args;
    validatorAcceptThreshold: Rational | Rational.Args;
    majorBlockSchedule: string;
    anchorEmptyBlocks: boolean;
    feeSchedule: FeeSchedule | FeeSchedule.Args;
    limits: NetworkLimits | NetworkLimits.Args;
  };
}
export class NetworkGlobals {
  public operatorAcceptThreshold: Rational;
  public validatorAcceptThreshold: Rational;
  public majorBlockSchedule: string;
  public anchorEmptyBlocks: boolean;
  public feeSchedule: FeeSchedule;
  public limits: NetworkLimits;

  constructor(args: NetworkGlobals.Args) {
    this.operatorAcceptThreshold =
      args.operatorAcceptThreshold instanceof Rational
        ? args.operatorAcceptThreshold
        : new Rational(args.operatorAcceptThreshold);
    this.validatorAcceptThreshold =
      args.validatorAcceptThreshold instanceof Rational
        ? args.validatorAcceptThreshold
        : new Rational(args.validatorAcceptThreshold);
    this.majorBlockSchedule = args.majorBlockSchedule;
    this.anchorEmptyBlocks = args.anchorEmptyBlocks;
    this.feeSchedule =
      args.feeSchedule instanceof FeeSchedule
        ? args.feeSchedule
        : new FeeSchedule(args.feeSchedule);
    this.limits =
      args.limits instanceof NetworkLimits ? args.limits : new NetworkLimits(args.limits);
  }

  asObject() {
    return {
      operatorAcceptThreshold: this.operatorAcceptThreshold.asObject(),
      validatorAcceptThreshold: this.validatorAcceptThreshold.asObject(),
      majorBlockSchedule: this.majorBlockSchedule,
      anchorEmptyBlocks: this.anchorEmptyBlocks,
      feeSchedule: this.feeSchedule.asObject(),
      limits: this.limits.asObject(),
    };
  }
}

export namespace NetworkLimits {
  export type Args = {
    dataEntryParts: number;
    accountAuthorities: number;
    bookPages: number;
    pageEntries: number;
    identityAccounts: number;
  };
}
export class NetworkLimits {
  public dataEntryParts: number;
  public accountAuthorities: number;
  public bookPages: number;
  public pageEntries: number;
  public identityAccounts: number;

  constructor(args: NetworkLimits.Args) {
    this.dataEntryParts = args.dataEntryParts;
    this.accountAuthorities = args.accountAuthorities;
    this.bookPages = args.bookPages;
    this.pageEntries = args.pageEntries;
    this.identityAccounts = args.identityAccounts;
  }

  asObject() {
    return {
      dataEntryParts: this.dataEntryParts,
      accountAuthorities: this.accountAuthorities,
      bookPages: this.bookPages,
      pageEntries: this.pageEntries,
      identityAccounts: this.identityAccounts,
    };
  }
}

export namespace PartitionAnchor {
  export type Args = {
    source: URL | string;
    majorBlockIndex: number;
    minorBlockIndex: number;
    rootChainIndex: number;
    rootChainAnchor: Uint8Array | string;
    stateTreeAnchor: Uint8Array | string;
  };
}
export class PartitionAnchor {
  public source: URL;
  public majorBlockIndex: number;
  public minorBlockIndex: number;
  public rootChainIndex: number;
  public rootChainAnchor: Uint8Array;
  public stateTreeAnchor: Uint8Array;

  constructor(args: PartitionAnchor.Args) {
    this.source = args.source instanceof URL ? args.source : new URL(args.source);
    this.majorBlockIndex = args.majorBlockIndex;
    this.minorBlockIndex = args.minorBlockIndex;
    this.rootChainIndex = args.rootChainIndex;
    this.rootChainAnchor =
      args.rootChainAnchor instanceof Uint8Array
        ? args.rootChainAnchor
        : Buffer.from(args.rootChainAnchor, "hex");
    this.stateTreeAnchor =
      args.stateTreeAnchor instanceof Uint8Array
        ? args.stateTreeAnchor
        : Buffer.from(args.stateTreeAnchor, "hex");
  }

  asObject() {
    return {
      source: this.source.toString(),
      majorBlockIndex: this.majorBlockIndex,
      minorBlockIndex: this.minorBlockIndex,
      rootChainIndex: this.rootChainIndex,
      rootChainAnchor: Buffer.from(this.rootChainAnchor).toString("hex"),
      stateTreeAnchor: Buffer.from(this.stateTreeAnchor).toString("hex"),
    };
  }
}

export namespace PartitionAnchorReceipt {
  export type Args = {
    anchor: PartitionAnchor | PartitionAnchor.Args;
    rootChainReceipt: managed.Receipt | managed.Receipt.Args;
  };
}
export class PartitionAnchorReceipt {
  public anchor: PartitionAnchor;
  public rootChainReceipt: managed.Receipt;

  constructor(args: PartitionAnchorReceipt.Args) {
    this.anchor =
      args.anchor instanceof PartitionAnchor ? args.anchor : new PartitionAnchor(args.anchor);
    this.rootChainReceipt =
      args.rootChainReceipt instanceof managed.Receipt
        ? args.rootChainReceipt
        : new managed.Receipt(args.rootChainReceipt);
  }

  asObject() {
    return {
      anchor: this.anchor.asObject(),
      rootChainReceipt: this.rootChainReceipt.asObject(),
    };
  }
}

export namespace PartitionInfo {
  export type Args = {
    id: string;
    type: PartitionType.Args;
  };
}
export class PartitionInfo {
  public id: string;
  public type: PartitionType;

  constructor(args: PartitionInfo.Args) {
    this.id = args.id;
    this.type = PartitionType.fromObject(args.type);
  }

  asObject() {
    return {
      id: this.id,
      type: this.type.toString(),
    };
  }
}

export namespace PartitionSignature {
  export type Args = {
    sourceNetwork: URL | string;
    destinationNetwork: URL | string;
    sequenceNumber: number;
    transactionHash: Uint8Array | string;
  };
  export type ArgsWithType = Args & { type: SignatureType.Partition | "partition" };
}
export class PartitionSignature {
  public readonly type = SignatureType.Partition;
  public sourceNetwork: URL;
  public destinationNetwork: URL;
  public sequenceNumber: number;
  public transactionHash?: Uint8Array;

  constructor(args: PartitionSignature.Args) {
    this.sourceNetwork =
      args.sourceNetwork instanceof URL ? args.sourceNetwork : new URL(args.sourceNetwork);
    this.destinationNetwork =
      args.destinationNetwork instanceof URL
        ? args.destinationNetwork
        : new URL(args.destinationNetwork);
    this.sequenceNumber = args.sequenceNumber;
    this.transactionHash =
      args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  asObject() {
    return {
      type: this.type,
      sourceNetwork: this.sourceNetwork.toString(),
      destinationNetwork: this.destinationNetwork.toString(),
      sequenceNumber: this.sequenceNumber,
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export namespace PartitionSyntheticLedger {
  export type Args = {
    url: URL | string;
    produced: number;
    received: number;
    delivered: number;
    pending: (TxID | string)[];
  };
}
export class PartitionSyntheticLedger {
  public url: URL;
  public produced: number;
  public received: number;
  public delivered: number;
  public pending: TxID[];

  constructor(args: PartitionSyntheticLedger.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.produced = args.produced;
    this.received = args.received;
    this.delivered = args.delivered;
    this.pending = args.pending.map((v) => (v instanceof TxID ? v : new TxID(v)));
  }

  asObject() {
    return {
      url: this.url.toString(),
      produced: this.produced,
      received: this.received,
      delivered: this.delivered,
      pending: this.pending?.map((v) => v.toString()),
    };
  }
}

export namespace RCD1Signature {
  export type Args = {
    publicKey: Uint8Array | string;
    signature: Uint8Array | string;
    signer: URL | string;
    signerVersion: number;
    timestamp: number;
    vote: VoteType.Args;
    transactionHash: Uint8Array | string;
  };
  export type ArgsWithType = Args & { type: SignatureType.RCD1 | "rcd1" };
}
export class RCD1Signature {
  public readonly type = SignatureType.RCD1;
  public publicKey: Uint8Array;
  public signature: Uint8Array;
  public signer: URL;
  public signerVersion: number;
  public timestamp?: number;
  public vote?: VoteType;
  public transactionHash?: Uint8Array;

  constructor(args: RCD1Signature.Args) {
    this.publicKey =
      args.publicKey instanceof Uint8Array ? args.publicKey : Buffer.from(args.publicKey, "hex");
    this.signature =
      args.signature instanceof Uint8Array ? args.signature : Buffer.from(args.signature, "hex");
    this.signer = args.signer instanceof URL ? args.signer : new URL(args.signer);
    this.signerVersion = args.signerVersion;
    this.timestamp = args.timestamp;
    this.vote = VoteType.fromObject(args.vote);
    this.transactionHash =
      args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  asObject() {
    return {
      type: this.type,
      publicKey: Buffer.from(this.publicKey).toString("hex"),
      signature: Buffer.from(this.signature).toString("hex"),
      signer: this.signer.toString(),
      signerVersion: this.signerVersion,
      timestamp: this.timestamp && this.timestamp,
      vote: this.vote && this.vote.toString(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export namespace Rational {
  export type Args = {
    numerator: number;
    denominator: number;
  };
}
export class Rational {
  public numerator: number;
  public denominator: number;

  constructor(args: Rational.Args) {
    this.numerator = args.numerator;
    this.denominator = args.denominator;
  }

  asObject() {
    return {
      numerator: this.numerator,
      denominator: this.denominator,
    };
  }
}

export namespace ReceiptSignature {
  export type Args = {
    sourceNetwork: URL | string;
    proof: managed.Receipt | managed.Receipt.Args;
    transactionHash: Uint8Array | string;
  };
  export type ArgsWithType = Args & { type: SignatureType.Receipt | "receipt" };
}
export class ReceiptSignature {
  public readonly type = SignatureType.Receipt;
  public sourceNetwork: URL;
  public proof: managed.Receipt;
  public transactionHash?: Uint8Array;

  constructor(args: ReceiptSignature.Args) {
    this.sourceNetwork =
      args.sourceNetwork instanceof URL ? args.sourceNetwork : new URL(args.sourceNetwork);
    this.proof =
      args.proof instanceof managed.Receipt ? args.proof : new managed.Receipt(args.proof);
    this.transactionHash =
      args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  asObject() {
    return {
      type: this.type,
      sourceNetwork: this.sourceNetwork.toString(),
      proof: this.proof.asObject(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export namespace RemoteSignature {
  export type Args = {
    destination: URL | string;
    signature: Signature.Args;
    cause: (Uint8Array | string)[];
  };
  export type ArgsWithType = Args & { type: SignatureType.Remote | "remote" };
}
export class RemoteSignature {
  public readonly type = SignatureType.Remote;
  public destination: URL;
  public signature: Signature;
  public cause: Uint8Array[];

  constructor(args: RemoteSignature.Args) {
    this.destination =
      args.destination instanceof URL ? args.destination : new URL(args.destination);
    this.signature = Signature.fromObject(args.signature);
    this.cause = args.cause.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
  }

  asObject() {
    return {
      type: this.type,
      destination: this.destination.toString(),
      signature: this.signature.asObject(),
      cause: this.cause?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export namespace RemoteTransaction {
  export type Args = {
    hash: Uint8Array | string;
  };
  export type ArgsWithType = Args & { type: TransactionType.Remote | "remote" };
}
export class RemoteTransaction {
  public readonly type = TransactionType.Remote;
  public hash?: Uint8Array;

  constructor(args: RemoteTransaction.Args) {
    this.hash = args.hash instanceof Uint8Array ? args.hash : Buffer.from(args.hash, "hex");
  }

  asObject() {
    return {
      type: this.type,
      hash: this.hash && Buffer.from(this.hash).toString("hex"),
    };
  }
}

export namespace RemoveAccountAuthorityOperation {
  export type Args = {
    authority: URL | string;
  };
  export type ArgsWithType = Args & {
    type: AccountAuthOperationType.RemoveAuthority | "removeAuthority";
  };
}
export class RemoveAccountAuthorityOperation {
  public readonly type = AccountAuthOperationType.RemoveAuthority;
  public authority: URL;

  constructor(args: RemoveAccountAuthorityOperation.Args) {
    this.authority = args.authority instanceof URL ? args.authority : new URL(args.authority);
  }

  asObject() {
    return {
      type: this.type,
      authority: this.authority.toString(),
    };
  }
}

export namespace RemoveKeyOperation {
  export type Args = {
    entry: KeySpecParams | KeySpecParams.Args;
  };
  export type ArgsWithType = Args & { type: KeyPageOperationType.Remove | "remove" };
}
export class RemoveKeyOperation {
  public readonly type = KeyPageOperationType.Remove;
  public entry: KeySpecParams;

  constructor(args: RemoveKeyOperation.Args) {
    this.entry = args.entry instanceof KeySpecParams ? args.entry : new KeySpecParams(args.entry);
  }

  asObject() {
    return {
      type: this.type,
      entry: this.entry.asObject(),
    };
  }
}

export namespace Route {
  export type Args = {
    length: number;
    value: number;
    partition: string;
  };
}
export class Route {
  public length: number;
  public value: number;
  public partition: string;

  constructor(args: Route.Args) {
    this.length = args.length;
    this.value = args.value;
    this.partition = args.partition;
  }

  asObject() {
    return {
      length: this.length,
      value: this.value,
      partition: this.partition,
    };
  }
}

export namespace RouteOverride {
  export type Args = {
    account: URL | string;
    partition: string;
  };
}
export class RouteOverride {
  public account: URL;
  public partition: string;

  constructor(args: RouteOverride.Args) {
    this.account = args.account instanceof URL ? args.account : new URL(args.account);
    this.partition = args.partition;
  }

  asObject() {
    return {
      account: this.account.toString(),
      partition: this.partition,
    };
  }
}

export namespace RoutingTable {
  export type Args = {
    overrides: (RouteOverride | RouteOverride.Args)[];
    routes: (Route | Route.Args)[];
  };
}
export class RoutingTable {
  public overrides: RouteOverride[];
  public routes: Route[];

  constructor(args: RoutingTable.Args) {
    this.overrides = args.overrides.map((v) =>
      v instanceof RouteOverride ? v : new RouteOverride(v)
    );
    this.routes = args.routes.map((v) => (v instanceof Route ? v : new Route(v)));
  }

  asObject() {
    return {
      overrides: this.overrides?.map((v) => v.asObject()),
      routes: this.routes?.map((v) => v.asObject()),
    };
  }
}

export namespace SendTokens {
  export type Args = {
    hash: Uint8Array | string;
    meta: unknown;
    to: (TokenRecipient | TokenRecipient.Args)[];
  };
  export type ArgsWithType = Args & { type: TransactionType.SendTokens | "sendTokens" };
}
export class SendTokens {
  public readonly type = TransactionType.SendTokens;
  public hash?: Uint8Array;
  public meta?: unknown;
  public to: TokenRecipient[];

  constructor(args: SendTokens.Args) {
    this.hash = args.hash instanceof Uint8Array ? args.hash : Buffer.from(args.hash, "hex");
    this.meta = args.meta;
    this.to = args.to.map((v) => (v instanceof TokenRecipient ? v : new TokenRecipient(v)));
  }

  asObject() {
    return {
      type: this.type,
      hash: this.hash && Buffer.from(this.hash).toString("hex"),
      meta: this.meta && this.meta,
      to: this.to?.map((v) => v.asObject()),
    };
  }
}

export namespace SetThresholdKeyPageOperation {
  export type Args = {
    threshold: number;
  };
  export type ArgsWithType = Args & { type: KeyPageOperationType.SetThreshold | "setThreshold" };
}
export class SetThresholdKeyPageOperation {
  public readonly type = KeyPageOperationType.SetThreshold;
  public threshold: number;

  constructor(args: SetThresholdKeyPageOperation.Args) {
    this.threshold = args.threshold;
  }

  asObject() {
    return {
      type: this.type,
      threshold: this.threshold,
    };
  }
}

export namespace SignatureSet {
  export type Args = {
    vote: VoteType.Args;
    signer: URL | string;
    authority: URL | string;
    transactionHash: Uint8Array | string;
    signatures: Signature.Args[];
  };
  export type ArgsWithType = Args & { type: SignatureType.Set | "set" };
}
export class SignatureSet {
  public readonly type = SignatureType.Set;
  public vote?: VoteType;
  public signer: URL;
  public authority: URL;
  public transactionHash?: Uint8Array;
  public signatures: Signature[];

  constructor(args: SignatureSet.Args) {
    this.vote = VoteType.fromObject(args.vote);
    this.signer = args.signer instanceof URL ? args.signer : new URL(args.signer);
    this.authority = args.authority instanceof URL ? args.authority : new URL(args.authority);
    this.transactionHash =
      args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
    this.signatures = args.signatures.map((v) => Signature.fromObject(v));
  }

  asObject() {
    return {
      type: this.type,
      vote: this.vote && this.vote.toString(),
      signer: this.signer.toString(),
      authority: this.authority.toString(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
      signatures: this.signatures?.map((v) => v.asObject()),
    };
  }
}

export namespace SyntheticBurnTokens {
  export type Args = {
    cause: TxID | string;
    source: URL | string;
    initiator: URL | string;
    feeRefund: number;
    amount: BN | string;
    isRefund: boolean;
  };
  export type ArgsWithType = Args & {
    type: TransactionType.SyntheticBurnTokens | "syntheticBurnTokens";
  };
}
export class SyntheticBurnTokens {
  public readonly type = TransactionType.SyntheticBurnTokens;
  public cause: TxID;
  public source: URL;
  public initiator: URL;
  public feeRefund: number;
  public amount: BN;
  public isRefund: boolean;

  constructor(args: SyntheticBurnTokens.Args) {
    this.cause = args.cause instanceof TxID ? args.cause : new TxID(args.cause);
    this.source = args.source instanceof URL ? args.source : new URL(args.source);
    this.initiator = args.initiator instanceof URL ? args.initiator : new URL(args.initiator);
    this.feeRefund = args.feeRefund;
    this.amount = args.amount instanceof BN ? args.amount : new BN(args.amount);
    this.isRefund = args.isRefund;
  }

  asObject() {
    return {
      type: this.type,
      cause: this.cause.toString(),
      source: this.source.toString(),
      initiator: this.initiator.toString(),
      feeRefund: this.feeRefund,
      amount: this.amount.toString(),
      isRefund: this.isRefund,
    };
  }
}

export namespace SyntheticCreateIdentity {
  export type Args = {
    cause: TxID | string;
    source: URL | string;
    initiator: URL | string;
    feeRefund: number;
    accounts: Account.Args[];
  };
  export type ArgsWithType = Args & {
    type: TransactionType.SyntheticCreateIdentity | "syntheticCreateIdentity";
  };
}
export class SyntheticCreateIdentity {
  public readonly type = TransactionType.SyntheticCreateIdentity;
  public cause: TxID;
  public source: URL;
  public initiator: URL;
  public feeRefund: number;
  public accounts: Account[];

  constructor(args: SyntheticCreateIdentity.Args) {
    this.cause = args.cause instanceof TxID ? args.cause : new TxID(args.cause);
    this.source = args.source instanceof URL ? args.source : new URL(args.source);
    this.initiator = args.initiator instanceof URL ? args.initiator : new URL(args.initiator);
    this.feeRefund = args.feeRefund;
    this.accounts = args.accounts.map((v) => Account.fromObject(v));
  }

  asObject() {
    return {
      type: this.type,
      cause: this.cause.toString(),
      source: this.source.toString(),
      initiator: this.initiator.toString(),
      feeRefund: this.feeRefund,
      accounts: this.accounts?.map((v) => v.asObject()),
    };
  }
}

export namespace SyntheticDepositCredits {
  export type Args = {
    cause: TxID | string;
    source: URL | string;
    initiator: URL | string;
    feeRefund: number;
    amount: number;
    acmeRefundAmount: BN | string;
    isRefund: boolean;
  };
  export type ArgsWithType = Args & {
    type: TransactionType.SyntheticDepositCredits | "syntheticDepositCredits";
  };
}
export class SyntheticDepositCredits {
  public readonly type = TransactionType.SyntheticDepositCredits;
  public cause: TxID;
  public source: URL;
  public initiator: URL;
  public feeRefund: number;
  public amount: number;
  public acmeRefundAmount: BN;
  public isRefund: boolean;

  constructor(args: SyntheticDepositCredits.Args) {
    this.cause = args.cause instanceof TxID ? args.cause : new TxID(args.cause);
    this.source = args.source instanceof URL ? args.source : new URL(args.source);
    this.initiator = args.initiator instanceof URL ? args.initiator : new URL(args.initiator);
    this.feeRefund = args.feeRefund;
    this.amount = args.amount;
    this.acmeRefundAmount =
      args.acmeRefundAmount instanceof BN ? args.acmeRefundAmount : new BN(args.acmeRefundAmount);
    this.isRefund = args.isRefund;
  }

  asObject() {
    return {
      type: this.type,
      cause: this.cause.toString(),
      source: this.source.toString(),
      initiator: this.initiator.toString(),
      feeRefund: this.feeRefund,
      amount: this.amount,
      acmeRefundAmount: this.acmeRefundAmount.toString(),
      isRefund: this.isRefund,
    };
  }
}

export namespace SyntheticDepositTokens {
  export type Args = {
    cause: TxID | string;
    source: URL | string;
    initiator: URL | string;
    feeRefund: number;
    token: URL | string;
    amount: BN | string;
    isIssuer: boolean;
    isRefund: boolean;
  };
  export type ArgsWithType = Args & {
    type: TransactionType.SyntheticDepositTokens | "syntheticDepositTokens";
  };
}
export class SyntheticDepositTokens {
  public readonly type = TransactionType.SyntheticDepositTokens;
  public cause: TxID;
  public source: URL;
  public initiator: URL;
  public feeRefund: number;
  public token: URL;
  public amount: BN;
  public isIssuer: boolean;
  public isRefund: boolean;

  constructor(args: SyntheticDepositTokens.Args) {
    this.cause = args.cause instanceof TxID ? args.cause : new TxID(args.cause);
    this.source = args.source instanceof URL ? args.source : new URL(args.source);
    this.initiator = args.initiator instanceof URL ? args.initiator : new URL(args.initiator);
    this.feeRefund = args.feeRefund;
    this.token = args.token instanceof URL ? args.token : new URL(args.token);
    this.amount = args.amount instanceof BN ? args.amount : new BN(args.amount);
    this.isIssuer = args.isIssuer;
    this.isRefund = args.isRefund;
  }

  asObject() {
    return {
      type: this.type,
      cause: this.cause.toString(),
      source: this.source.toString(),
      initiator: this.initiator.toString(),
      feeRefund: this.feeRefund,
      token: this.token.toString(),
      amount: this.amount.toString(),
      isIssuer: this.isIssuer,
      isRefund: this.isRefund,
    };
  }
}

export namespace SyntheticForwardTransaction {
  export type Args = {
    signatures: (RemoteSignature | RemoteSignature.Args)[];
    transaction: Transaction | Transaction.Args;
  };
  export type ArgsWithType = Args & {
    type: TransactionType.SyntheticForwardTransaction | "syntheticForwardTransaction";
  };
}
export class SyntheticForwardTransaction {
  public readonly type = TransactionType.SyntheticForwardTransaction;
  public signatures: RemoteSignature[];
  public transaction?: Transaction;

  constructor(args: SyntheticForwardTransaction.Args) {
    this.signatures = args.signatures.map((v) =>
      v instanceof RemoteSignature ? v : new RemoteSignature(v)
    );
    this.transaction =
      args.transaction instanceof Transaction
        ? args.transaction
        : new Transaction(args.transaction);
  }

  asObject() {
    return {
      type: this.type,
      signatures: this.signatures?.map((v) => v.asObject()),
      transaction: this.transaction && this.transaction.asObject(),
    };
  }
}

export namespace SyntheticLedger {
  export type Args = {
    url: URL | string;
    sequence: (PartitionSyntheticLedger | PartitionSyntheticLedger.Args)[];
  };
  export type ArgsWithType = Args & { type: AccountType.SyntheticLedger | "syntheticLedger" };
}
export class SyntheticLedger {
  public readonly type = AccountType.SyntheticLedger;
  public url: URL;
  public sequence: PartitionSyntheticLedger[];

  constructor(args: SyntheticLedger.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.sequence = args.sequence.map((v) =>
      v instanceof PartitionSyntheticLedger ? v : new PartitionSyntheticLedger(v)
    );
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      sequence: this.sequence?.map((v) => v.asObject()),
    };
  }
}

export namespace SyntheticOrigin {
  export type Args = {
    cause: TxID | string;
    initiator: URL | string;
    feeRefund: number;
  };
}
export class SyntheticOrigin {
  public cause: TxID;
  public initiator: URL;
  public feeRefund: number;

  constructor(args: SyntheticOrigin.Args) {
    this.cause = args.cause instanceof TxID ? args.cause : new TxID(args.cause);
    this.initiator = args.initiator instanceof URL ? args.initiator : new URL(args.initiator);
    this.feeRefund = args.feeRefund;
  }

  asObject() {
    return {
      cause: this.cause.toString(),
      initiator: this.initiator.toString(),
      feeRefund: this.feeRefund,
    };
  }
}

export namespace SyntheticWriteData {
  export type Args = {
    cause: TxID | string;
    source: URL | string;
    initiator: URL | string;
    feeRefund: number;
    entry: DataEntry.Args;
  };
  export type ArgsWithType = Args & {
    type: TransactionType.SyntheticWriteData | "syntheticWriteData";
  };
}
export class SyntheticWriteData {
  public readonly type = TransactionType.SyntheticWriteData;
  public cause: TxID;
  public source: URL;
  public initiator: URL;
  public feeRefund: number;
  public entry: DataEntry;

  constructor(args: SyntheticWriteData.Args) {
    this.cause = args.cause instanceof TxID ? args.cause : new TxID(args.cause);
    this.source = args.source instanceof URL ? args.source : new URL(args.source);
    this.initiator = args.initiator instanceof URL ? args.initiator : new URL(args.initiator);
    this.feeRefund = args.feeRefund;
    this.entry = DataEntry.fromObject(args.entry);
  }

  asObject() {
    return {
      type: this.type,
      cause: this.cause.toString(),
      source: this.source.toString(),
      initiator: this.initiator.toString(),
      feeRefund: this.feeRefund,
      entry: this.entry.asObject(),
    };
  }
}

export namespace SystemGenesis {
  export type Args = Record<string, never>;
  export type ArgsWithType = Args & { type: TransactionType.SystemGenesis | "systemGenesis" };
}
export class SystemGenesis {
  public readonly type = TransactionType.SystemGenesis;

  constructor(_: SystemGenesis.Args) {}

  asObject() {
    return {
      type: this.type,
    };
  }
}

export namespace SystemLedger {
  export type Args = {
    url: URL | string;
    index: number;
    timestamp: Date | string;
    acmeBurnt: BN | string;
    pendingUpdates: (NetworkAccountUpdate | NetworkAccountUpdate.Args)[];
    anchor: AnchorBody.Args;
  };
  export type ArgsWithType = Args & { type: AccountType.SystemLedger | "systemLedger" };
}
export class SystemLedger {
  public readonly type = AccountType.SystemLedger;
  public url: URL;
  public index: number;
  public timestamp: Date;
  public acmeBurnt: BN;
  public pendingUpdates: NetworkAccountUpdate[];
  public anchor: AnchorBody;

  constructor(args: SystemLedger.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.index = args.index;
    this.timestamp = args.timestamp instanceof Date ? args.timestamp : new Date(args.timestamp);
    this.acmeBurnt = args.acmeBurnt instanceof BN ? args.acmeBurnt : new BN(args.acmeBurnt);
    this.pendingUpdates = args.pendingUpdates.map((v) =>
      v instanceof NetworkAccountUpdate ? v : new NetworkAccountUpdate(v)
    );
    this.anchor = AnchorBody.fromObject(args.anchor);
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      index: this.index,
      timestamp: this.timestamp,
      acmeBurnt: this.acmeBurnt.toString(),
      pendingUpdates: this.pendingUpdates?.map((v) => v.asObject()),
      anchor: this.anchor.asObject(),
    };
  }
}

export namespace SystemWriteData {
  export type Args = {
    entry: DataEntry.Args;
    writeToState: boolean;
  };
  export type ArgsWithType = Args & { type: TransactionType.SystemWriteData | "systemWriteData" };
}
export class SystemWriteData {
  public readonly type = TransactionType.SystemWriteData;
  public entry: DataEntry;
  public writeToState?: boolean;

  constructor(args: SystemWriteData.Args) {
    this.entry = DataEntry.fromObject(args.entry);
    this.writeToState = args.writeToState;
  }

  asObject() {
    return {
      type: this.type,
      entry: this.entry.asObject(),
      writeToState: this.writeToState && this.writeToState,
    };
  }
}

export namespace TokenAccount {
  export type Args = {
    url: URL | string;
    authorities: (AuthorityEntry | AuthorityEntry.Args)[];
    tokenUrl: URL | string;
    balance: BN | string;
  };
  export type ArgsWithType = Args & { type: AccountType.TokenAccount | "tokenAccount" };
}
export class TokenAccount {
  public readonly type = AccountType.TokenAccount;
  public url: URL;
  public authorities: AuthorityEntry[];
  public tokenUrl: URL;
  public balance: BN;

  constructor(args: TokenAccount.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.authorities = args.authorities.map((v) =>
      v instanceof AuthorityEntry ? v : new AuthorityEntry(v)
    );
    this.tokenUrl = args.tokenUrl instanceof URL ? args.tokenUrl : new URL(args.tokenUrl);
    this.balance = args.balance instanceof BN ? args.balance : new BN(args.balance);
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      authorities: this.authorities?.map((v) => v.asObject()),
      tokenUrl: this.tokenUrl.toString(),
      balance: this.balance.toString(),
    };
  }
}

export namespace TokenIssuer {
  export type Args = {
    url: URL | string;
    authorities: (AuthorityEntry | AuthorityEntry.Args)[];
    symbol: string;
    precision: number;
    properties: URL | string;
    issued: BN | string;
    supplyLimit: BN | string;
  };
  export type ArgsWithType = Args & { type: AccountType.TokenIssuer | "tokenIssuer" };
}
export class TokenIssuer {
  public readonly type = AccountType.TokenIssuer;
  public url: URL;
  public authorities: AuthorityEntry[];
  public symbol: string;
  public precision: number;
  public properties: URL;
  public issued: BN;
  public supplyLimit?: BN;

  constructor(args: TokenIssuer.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.authorities = args.authorities.map((v) =>
      v instanceof AuthorityEntry ? v : new AuthorityEntry(v)
    );
    this.symbol = args.symbol;
    this.precision = args.precision;
    this.properties = args.properties instanceof URL ? args.properties : new URL(args.properties);
    this.issued = args.issued instanceof BN ? args.issued : new BN(args.issued);
    this.supplyLimit = args.supplyLimit instanceof BN ? args.supplyLimit : new BN(args.supplyLimit);
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      authorities: this.authorities?.map((v) => v.asObject()),
      symbol: this.symbol,
      precision: this.precision,
      properties: this.properties.toString(),
      issued: this.issued.toString(),
      supplyLimit: this.supplyLimit && this.supplyLimit.toString(),
    };
  }
}

export namespace TokenIssuerProof {
  export type Args = {
    transaction: CreateToken | CreateToken.Args;
    receipt: managed.Receipt | managed.Receipt.Args;
  };
}
export class TokenIssuerProof {
  public transaction: CreateToken;
  public receipt: managed.Receipt;

  constructor(args: TokenIssuerProof.Args) {
    this.transaction =
      args.transaction instanceof CreateToken
        ? args.transaction
        : new CreateToken(args.transaction);
    this.receipt =
      args.receipt instanceof managed.Receipt ? args.receipt : new managed.Receipt(args.receipt);
  }

  asObject() {
    return {
      transaction: this.transaction.asObject(),
      receipt: this.receipt.asObject(),
    };
  }
}

export namespace TokenRecipient {
  export type Args = {
    url: URL | string;
    amount: BN | string;
  };
}
export class TokenRecipient {
  public url: URL;
  public amount: BN;

  constructor(args: TokenRecipient.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.amount = args.amount instanceof BN ? args.amount : new BN(args.amount);
  }

  asObject() {
    return {
      url: this.url.toString(),
      amount: this.amount.toString(),
    };
  }
}

export namespace Transaction {
  export type Args = {
    header: TransactionHeader | TransactionHeader.Args;
    body: TransactionBody.Args;
  };
}
export class Transaction {
  public header: TransactionHeader;
  public body: TransactionBody;

  constructor(args: Transaction.Args) {
    this.header =
      args.header instanceof TransactionHeader ? args.header : new TransactionHeader(args.header);
    this.body = TransactionBody.fromObject(args.body);
  }

  asObject() {
    return {
      header: this.header.asObject(),
      body: this.body.asObject(),
    };
  }
}

export namespace TransactionHeader {
  export type Args = {
    principal: URL | string;
    initiator: Uint8Array | string;
    memo: string;
    metadata: Uint8Array | string;
  };
}
export class TransactionHeader {
  public principal: URL;
  public initiator: Uint8Array;
  public memo?: string;
  public metadata?: Uint8Array;

  constructor(args: TransactionHeader.Args) {
    this.principal = args.principal instanceof URL ? args.principal : new URL(args.principal);
    this.initiator =
      args.initiator instanceof Uint8Array ? args.initiator : Buffer.from(args.initiator, "hex");
    this.memo = args.memo;
    this.metadata =
      args.metadata instanceof Uint8Array ? args.metadata : Buffer.from(args.metadata, "hex");
  }

  asObject() {
    return {
      principal: this.principal.toString(),
      initiator: Buffer.from(this.initiator).toString("hex"),
      memo: this.memo && this.memo,
      metadata: this.metadata && Buffer.from(this.metadata).toString("hex"),
    };
  }
}

export namespace TransactionStatus {
  export type Args = {
    txID: TxID | string;
    code: errors2.Status.Args;
    error: errors2.Error | errors2.Error.Args;
    result: TransactionResult.Args;
    received: number;
    initiator: URL | string;
    signers: Signer.Args[];
    sourceNetwork: URL | string;
    destinationNetwork: URL | string;
    sequenceNumber: number;
    gotDirectoryReceipt: boolean;
    proof: managed.Receipt | managed.Receipt.Args;
    anchorSigners: (Uint8Array | string)[];
  };
}
export class TransactionStatus {
  public txID: TxID;
  public code: errors2.Status;
  public error: errors2.Error;
  public result: TransactionResult;
  public received: number;
  public initiator: URL;
  public signers: Signer[];
  public sourceNetwork: URL;
  public destinationNetwork: URL;
  public sequenceNumber: number;
  public gotDirectoryReceipt: boolean;
  public proof: managed.Receipt;
  public anchorSigners: Uint8Array[];

  constructor(args: TransactionStatus.Args) {
    this.txID = args.txID instanceof TxID ? args.txID : new TxID(args.txID);
    this.code = errors2.Status.fromObject(args.code);
    this.error = args.error instanceof errors2.Error ? args.error : new errors2.Error(args.error);
    this.result = TransactionResult.fromObject(args.result);
    this.received = args.received;
    this.initiator = args.initiator instanceof URL ? args.initiator : new URL(args.initiator);
    this.signers = args.signers.map((v) => Signer.fromObject(v));
    this.sourceNetwork =
      args.sourceNetwork instanceof URL ? args.sourceNetwork : new URL(args.sourceNetwork);
    this.destinationNetwork =
      args.destinationNetwork instanceof URL
        ? args.destinationNetwork
        : new URL(args.destinationNetwork);
    this.sequenceNumber = args.sequenceNumber;
    this.gotDirectoryReceipt = args.gotDirectoryReceipt;
    this.proof =
      args.proof instanceof managed.Receipt ? args.proof : new managed.Receipt(args.proof);
    this.anchorSigners = args.anchorSigners.map((v) =>
      v instanceof Uint8Array ? v : Buffer.from(v, "hex")
    );
  }

  asObject() {
    return {
      txID: this.txID.toString(),
      code: this.code.toString(),
      error: this.error.asObject(),
      result: this.result.asObject(),
      received: this.received,
      initiator: this.initiator.toString(),
      signers: this.signers?.map((v) => v.asObject()),
      sourceNetwork: this.sourceNetwork.toString(),
      destinationNetwork: this.destinationNetwork.toString(),
      sequenceNumber: this.sequenceNumber,
      gotDirectoryReceipt: this.gotDirectoryReceipt,
      proof: this.proof.asObject(),
      anchorSigners: this.anchorSigners?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export namespace TxIdSet {
  export type Args = {
    entries: (TxID | string)[];
  };
}
export class TxIdSet {
  public entries: TxID[];

  constructor(args: TxIdSet.Args) {
    this.entries = args.entries.map((v) => (v instanceof TxID ? v : new TxID(v)));
  }

  asObject() {
    return {
      entries: this.entries?.map((v) => v.toString()),
    };
  }
}

export namespace UnknownAccount {
  export type Args = {
    url: URL | string;
  };
  export type ArgsWithType = Args & { type: AccountType.Unknown | "unknown" };
}
export class UnknownAccount {
  public readonly type = AccountType.Unknown;
  public url: URL;

  constructor(args: UnknownAccount.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
    };
  }
}

export namespace UnknownSigner {
  export type Args = {
    url: URL | string;
    version: number;
  };
  export type ArgsWithType = Args & { type: AccountType.UnknownSigner | "unknownSigner" };
}
export class UnknownSigner {
  public readonly type = AccountType.UnknownSigner;
  public url: URL;
  public version: number;

  constructor(args: UnknownSigner.Args) {
    this.url = args.url instanceof URL ? args.url : new URL(args.url);
    this.version = args.version;
  }

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      version: this.version,
    };
  }
}

export namespace UpdateAccountAuth {
  export type Args = {
    operations: AccountAuthOperation.Args[];
  };
  export type ArgsWithType = Args & {
    type: TransactionType.UpdateAccountAuth | "updateAccountAuth";
  };
}
export class UpdateAccountAuth {
  public readonly type = TransactionType.UpdateAccountAuth;
  public operations: AccountAuthOperation[];

  constructor(args: UpdateAccountAuth.Args) {
    this.operations = args.operations.map((v) => AccountAuthOperation.fromObject(v));
  }

  asObject() {
    return {
      type: this.type,
      operations: this.operations?.map((v) => v.asObject()),
    };
  }
}

export namespace UpdateAllowedKeyPageOperation {
  export type Args = {
    allow: TransactionType.Args[];
    deny: TransactionType.Args[];
  };
  export type ArgsWithType = Args & { type: KeyPageOperationType.UpdateAllowed | "updateAllowed" };
}
export class UpdateAllowedKeyPageOperation {
  public readonly type = KeyPageOperationType.UpdateAllowed;
  public allow?: TransactionType[];
  public deny?: TransactionType[];

  constructor(args: UpdateAllowedKeyPageOperation.Args) {
    this.allow = args.allow.map((v) => TransactionType.fromObject(v));
    this.deny = args.deny.map((v) => TransactionType.fromObject(v));
  }

  asObject() {
    return {
      type: this.type,
      allow: this.allow?.map((v) => v.toString()),
      deny: this.deny?.map((v) => v.toString()),
    };
  }
}

export namespace UpdateKey {
  export type Args = {
    newKeyHash: Uint8Array | string;
  };
  export type ArgsWithType = Args & { type: TransactionType.UpdateKey | "updateKey" };
}
export class UpdateKey {
  public readonly type = TransactionType.UpdateKey;
  public newKeyHash: Uint8Array;

  constructor(args: UpdateKey.Args) {
    this.newKeyHash =
      args.newKeyHash instanceof Uint8Array ? args.newKeyHash : Buffer.from(args.newKeyHash, "hex");
  }

  asObject() {
    return {
      type: this.type,
      newKeyHash: Buffer.from(this.newKeyHash).toString("hex"),
    };
  }
}

export namespace UpdateKeyOperation {
  export type Args = {
    oldEntry: KeySpecParams | KeySpecParams.Args;
    newEntry: KeySpecParams | KeySpecParams.Args;
  };
  export type ArgsWithType = Args & { type: KeyPageOperationType.Update | "update" };
}
export class UpdateKeyOperation {
  public readonly type = KeyPageOperationType.Update;
  public oldEntry: KeySpecParams;
  public newEntry: KeySpecParams;

  constructor(args: UpdateKeyOperation.Args) {
    this.oldEntry =
      args.oldEntry instanceof KeySpecParams ? args.oldEntry : new KeySpecParams(args.oldEntry);
    this.newEntry =
      args.newEntry instanceof KeySpecParams ? args.newEntry : new KeySpecParams(args.newEntry);
  }

  asObject() {
    return {
      type: this.type,
      oldEntry: this.oldEntry.asObject(),
      newEntry: this.newEntry.asObject(),
    };
  }
}

export namespace UpdateKeyPage {
  export type Args = {
    operation: KeyPageOperation.Args[];
  };
  export type ArgsWithType = Args & { type: TransactionType.UpdateKeyPage | "updateKeyPage" };
}
export class UpdateKeyPage {
  public readonly type = TransactionType.UpdateKeyPage;
  public operation: KeyPageOperation[];

  constructor(args: UpdateKeyPage.Args) {
    this.operation = args.operation.map((v) => KeyPageOperation.fromObject(v));
  }

  asObject() {
    return {
      type: this.type,
      operation: this.operation?.map((v) => v.asObject()),
    };
  }
}

export namespace ValidatorInfo {
  export type Args = {
    publicKey: Uint8Array | string;
    publicKeyHash: Uint8Array | string;
    operator: URL | string;
    partitions: (ValidatorPartitionInfo | ValidatorPartitionInfo.Args)[];
  };
}
export class ValidatorInfo {
  public publicKey: Uint8Array;
  public publicKeyHash: Uint8Array;
  public operator: URL;
  public partitions: ValidatorPartitionInfo[];

  constructor(args: ValidatorInfo.Args) {
    this.publicKey =
      args.publicKey instanceof Uint8Array ? args.publicKey : Buffer.from(args.publicKey, "hex");
    this.publicKeyHash =
      args.publicKeyHash instanceof Uint8Array
        ? args.publicKeyHash
        : Buffer.from(args.publicKeyHash, "hex");
    this.operator = args.operator instanceof URL ? args.operator : new URL(args.operator);
    this.partitions = args.partitions.map((v) =>
      v instanceof ValidatorPartitionInfo ? v : new ValidatorPartitionInfo(v)
    );
  }

  asObject() {
    return {
      publicKey: Buffer.from(this.publicKey).toString("hex"),
      publicKeyHash: Buffer.from(this.publicKeyHash).toString("hex"),
      operator: this.operator.toString(),
      partitions: this.partitions?.map((v) => v.asObject()),
    };
  }
}

export namespace ValidatorPartitionInfo {
  export type Args = {
    id: string;
    active: boolean;
  };
}
export class ValidatorPartitionInfo {
  public id: string;
  public active: boolean;

  constructor(args: ValidatorPartitionInfo.Args) {
    this.id = args.id;
    this.active = args.active;
  }

  asObject() {
    return {
      id: this.id,
      active: this.active,
    };
  }
}

export namespace WriteData {
  export type Args = {
    entry: DataEntry.Args;
    scratch: boolean;
    writeToState: boolean;
  };
  export type ArgsWithType = Args & { type: TransactionType.WriteData | "writeData" };
}
export class WriteData {
  public readonly type = TransactionType.WriteData;
  public entry: DataEntry;
  public scratch?: boolean;
  public writeToState?: boolean;

  constructor(args: WriteData.Args) {
    this.entry = DataEntry.fromObject(args.entry);
    this.scratch = args.scratch;
    this.writeToState = args.writeToState;
  }

  asObject() {
    return {
      type: this.type,
      entry: this.entry.asObject(),
      scratch: this.scratch && this.scratch,
      writeToState: this.writeToState && this.writeToState,
    };
  }
}

export namespace WriteDataResult {
  export type Args = {
    entryHash: Uint8Array | string;
    accountUrl: URL | string;
    accountID: Uint8Array | string;
  };
  export type ArgsWithType = Args & { type: TransactionType.WriteData | "writeData" };
}
export class WriteDataResult {
  public readonly type = TransactionType.WriteData;
  public entryHash: Uint8Array;
  public accountUrl: URL;
  public accountID: Uint8Array;

  constructor(args: WriteDataResult.Args) {
    this.entryHash =
      args.entryHash instanceof Uint8Array ? args.entryHash : Buffer.from(args.entryHash, "hex");
    this.accountUrl = args.accountUrl instanceof URL ? args.accountUrl : new URL(args.accountUrl);
    this.accountID =
      args.accountID instanceof Uint8Array ? args.accountID : Buffer.from(args.accountID, "hex");
  }

  asObject() {
    return {
      type: this.type,
      entryHash: Buffer.from(this.entryHash).toString("hex"),
      accountUrl: this.accountUrl.toString(),
      accountID: Buffer.from(this.accountID).toString("hex"),
    };
  }
}

export namespace WriteDataTo {
  export type Args = {
    recipient: URL | string;
    entry: DataEntry.Args;
  };
  export type ArgsWithType = Args & { type: TransactionType.WriteDataTo | "writeDataTo" };
}
export class WriteDataTo {
  public readonly type = TransactionType.WriteDataTo;
  public recipient: URL;
  public entry: DataEntry;

  constructor(args: WriteDataTo.Args) {
    this.recipient = args.recipient instanceof URL ? args.recipient : new URL(args.recipient);
    this.entry = DataEntry.fromObject(args.entry);
  }

  asObject() {
    return {
      type: this.type,
      recipient: this.recipient.toString(),
      entry: this.entry.asObject(),
    };
  }
}
