import BN from "bn.js";
import {
  AccountAuthOperationType,
  AccountType,
  AllowedTransactions,
  AnchorBody,
  BookType,
  DataEntryType,
  Fee,
  KeyPageOperationType,
  PartitionType,
  SignatureType,
  Signer,
  TransactionResult,
  TransactionType,
  VoteType,
} from ".";
import * as errors2 from "../errors";
import * as managed from "../managed";
import * as url from "../url";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

export type Account =
  | ADI
  | AnchorLedger
  | BlockLedger
  | DataAccount
  | KeyBook
  | KeyPage
  | LiteDataAccount
  | LiteIdentity
  | LiteTokenAccount
  | SyntheticLedger
  | SystemLedger
  | TokenAccount
  | TokenIssuer
  | UnknownAccount
  | UnknownSigner;
export type DataEntry = AccumulateDataEntry | FactomDataEntryWrapper;
export type TransactionBody =
  | AcmeFaucet
  | AddCredits
  | BlockValidatorAnchor
  | BurnTokens
  | CreateDataAccount
  | CreateIdentity
  | CreateKeyBook
  | CreateKeyPage
  | CreateLiteTokenAccount
  | CreateToken
  | CreateTokenAccount
  | DirectoryAnchor
  | IssueTokens
  | LockAccount
  | RemoteTransaction
  | SendTokens
  | SyntheticBurnTokens
  | SyntheticCreateIdentity
  | SyntheticDepositCredits
  | SyntheticDepositTokens
  | SyntheticForwardTransaction
  | SyntheticWriteData
  | SystemGenesis
  | SystemWriteData
  | UpdateAccountAuth
  | UpdateKey
  | UpdateKeyPage
  | WriteData
  | WriteDataTo;
export type AccountAuthOperation =
  | AddAccountAuthorityOperation
  | DisableAccountAuthOperation
  | EnableAccountAuthOperation
  | RemoveAccountAuthorityOperation;
export type KeyPageOperation =
  | AddKeyOperation
  | RemoveKeyOperation
  | SetThresholdKeyPageOperation
  | UpdateAllowedKeyPageOperation
  | UpdateKeyOperation;
export type Signature =
  | BTCLegacySignature
  | BTCSignature
  | DelegatedSignature
  | ED25519Signature
  | ETHSignature
  | InternalSignature
  | LegacyED25519Signature
  | PartitionSignature
  | RCD1Signature
  | ReceiptSignature
  | RemoteSignature
  | SignatureSet;

export class ADI {
  public readonly type = AccountType.Identity;
  public url: url.URL;
  public authorities: AuthorityEntry[];

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      authorities: this.authorities?.map((v) => v.asObject()),
    };
  }
}

export class AccountAuth {
  public authorities: AuthorityEntry[];

  asObject() {
    return {
      authorities: this.authorities?.map((v) => v.asObject()),
    };
  }
}

export class AccumulateDataEntry {
  public readonly type = DataEntryType.Accumulate;
  public data: Uint8Array[];

  asObject() {
    return {
      type: this.type,
      data: this.data?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export class AcmeFaucet {
  public readonly type = TransactionType.AcmeFaucet;
  public url: url.URL;

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
    };
  }
}

export class AcmeOracle {
  public price: number;

  asObject() {
    return {
      price: this.price,
    };
  }
}

export class AddAccountAuthorityOperation {
  public readonly type = AccountAuthOperationType.AddAuthority;
  public authority: url.URL;

  asObject() {
    return {
      type: this.type,
      authority: this.authority.toString(),
    };
  }
}

export class AddCredits {
  public readonly type = TransactionType.AddCredits;
  public recipient: url.URL;
  public amount: BN;
  public oracle?: number;

  asObject() {
    return {
      type: this.type,
      recipient: this.recipient.toString(),
      amount: this.amount.toString(),
      oracle: this.oracle && this.oracle,
    };
  }
}

export class AddCreditsResult {
  public readonly type = TransactionType.AddCredits;
  public amount: BN;
  public credits: number;
  public oracle: number;

  asObject() {
    return {
      type: this.type,
      amount: this.amount.toString(),
      credits: this.credits,
      oracle: this.oracle,
    };
  }
}

export class AddKeyOperation {
  public readonly type = KeyPageOperationType.Add;
  public entry: KeySpecParams;

  asObject() {
    return {
      type: this.type,
      entry: this.entry.asObject(),
    };
  }
}

export class AnchorLedger {
  public readonly type = AccountType.AnchorLedger;
  public url: url.URL;
  public minorBlockSequenceNumber: number;
  public majorBlockIndex: number;
  public majorBlockTime: Date;
  public pendingMajorBlockAnchors: url.URL[];
  public sequence: PartitionSyntheticLedger[];

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      minorBlockSequenceNumber: this.minorBlockSequenceNumber,
      majorBlockIndex: this.majorBlockIndex,
      majorBlockTime: this.majorBlockTime,
      pendingMajorBlockAnchors: this.pendingMajorBlockAnchors?.map((v) => v.toString()),
      sequence: this.sequence?.map((v) => v.asObject()),
    };
  }
}

export class AuthorityEntry {
  public url: url.URL;
  public disabled: boolean;

  asObject() {
    return {
      url: this.url.toString(),
      disabled: this.disabled,
    };
  }
}

export class BTCLegacySignature {
  public readonly type = SignatureType.BTCLegacy;
  public publicKey: Uint8Array;
  public signature: Uint8Array;
  public signer: url.URL;
  public signerVersion: number;
  public timestamp?: number;
  public vote?: VoteType;
  public transactionHash?: Uint8Array;

  asObject() {
    return {
      type: this.type,
      publicKey: Buffer.from(this.publicKey).toString("hex"),
      signature: Buffer.from(this.signature).toString("hex"),
      signer: this.signer.toString(),
      signerVersion: this.signerVersion,
      timestamp: this.timestamp && this.timestamp,
      vote: this.vote && this.vote.toString(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export class BTCSignature {
  public readonly type = SignatureType.BTC;
  public publicKey: Uint8Array;
  public signature: Uint8Array;
  public signer: url.URL;
  public signerVersion: number;
  public timestamp?: number;
  public vote?: VoteType;
  public transactionHash?: Uint8Array;

  asObject() {
    return {
      type: this.type,
      publicKey: Buffer.from(this.publicKey).toString("hex"),
      signature: Buffer.from(this.signature).toString("hex"),
      signer: this.signer.toString(),
      signerVersion: this.signerVersion,
      timestamp: this.timestamp && this.timestamp,
      vote: this.vote && this.vote.toString(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export class BlockEntry {
  public account: url.URL;
  public chain: string;
  public index: number;

  asObject() {
    return {
      account: this.account.toString(),
      chain: this.chain,
      index: this.index,
    };
  }
}

export class BlockLedger {
  public readonly type = AccountType.BlockLedger;
  public url: url.URL;
  public index: number;
  public time: Date;
  public entries: BlockEntry[];

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      index: this.index,
      time: this.time,
      entries: this.entries?.map((v) => v.asObject()),
    };
  }
}

export class BlockValidatorAnchor {
  public readonly type = TransactionType.BlockValidatorAnchor;
  public source: url.URL;
  public majorBlockIndex: number;
  public minorBlockIndex: number;
  public rootChainIndex: number;
  public rootChainAnchor: Uint8Array;
  public stateTreeAnchor: Uint8Array;
  public acmeBurnt: BN;

  asObject() {
    return {
      type: this.type,
      source: this.source.toString(),
      majorBlockIndex: this.majorBlockIndex,
      minorBlockIndex: this.minorBlockIndex,
      rootChainIndex: this.rootChainIndex,
      rootChainAnchor: Buffer.from(this.rootChainAnchor).toString("hex"),
      stateTreeAnchor: Buffer.from(this.stateTreeAnchor).toString("hex"),
      acmeBurnt: this.acmeBurnt.toString(),
    };
  }
}

export class BurnTokens {
  public readonly type = TransactionType.BurnTokens;
  public amount: BN;

  asObject() {
    return {
      type: this.type,
      amount: this.amount.toString(),
    };
  }
}

export class ChainParams {
  public data: Uint8Array;
  public isUpdate: boolean;

  asObject() {
    return {
      data: Buffer.from(this.data).toString("hex"),
      isUpdate: this.isUpdate,
    };
  }
}

export class CreateDataAccount {
  public readonly type = TransactionType.CreateDataAccount;
  public url: url.URL;
  public authorities?: url.URL[];

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      authorities: this.authorities?.map((v) => v.toString()),
    };
  }
}

export class CreateIdentity {
  public readonly type = TransactionType.CreateIdentity;
  public url: url.URL;
  public keyHash?: Uint8Array;
  public keyBookUrl?: url.URL;
  public authorities?: url.URL[];

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      keyHash: this.keyHash && Buffer.from(this.keyHash).toString("hex"),
      keyBookUrl: this.keyBookUrl && this.keyBookUrl.toString(),
      authorities: this.authorities?.map((v) => v.toString()),
    };
  }
}

export class CreateKeyBook {
  public readonly type = TransactionType.CreateKeyBook;
  public url: url.URL;
  public publicKeyHash: Uint8Array;
  public authorities?: url.URL[];

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      publicKeyHash: Buffer.from(this.publicKeyHash).toString("hex"),
      authorities: this.authorities?.map((v) => v.toString()),
    };
  }
}

export class CreateKeyPage {
  public readonly type = TransactionType.CreateKeyPage;
  public keys: KeySpecParams[];

  asObject() {
    return {
      type: this.type,
      keys: this.keys?.map((v) => v.asObject()),
    };
  }
}

export class CreateLiteTokenAccount {
  public readonly type = TransactionType.CreateLiteTokenAccount;

  asObject() {
    return {
      type: this.type,
    };
  }
}

export class CreateToken {
  public readonly type = TransactionType.CreateToken;
  public url: url.URL;
  public symbol: string;
  public precision: number;
  public properties?: url.URL;
  public supplyLimit?: BN;
  public authorities?: url.URL[];

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      symbol: this.symbol,
      precision: this.precision,
      properties: this.properties && this.properties.toString(),
      supplyLimit: this.supplyLimit && this.supplyLimit.toString(),
      authorities: this.authorities?.map((v) => v.toString()),
    };
  }
}

export class CreateTokenAccount {
  public readonly type = TransactionType.CreateTokenAccount;
  public url: url.URL;
  public tokenUrl: url.URL;
  public authorities?: url.URL[];
  public proof?: TokenIssuerProof;

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      tokenUrl: this.tokenUrl.toString(),
      authorities: this.authorities?.map((v) => v.toString()),
      proof: this.proof && this.proof.asObject(),
    };
  }
}

export class DataAccount {
  public readonly type = AccountType.DataAccount;
  public url: url.URL;
  public authorities: AuthorityEntry[];
  public entry?: DataEntry;

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      authorities: this.authorities?.map((v) => v.asObject()),
      entry: this.entry && this.entry.asObject(),
    };
  }
}

export class DelegatedSignature {
  public readonly type = SignatureType.Delegated;
  public signature: Signature;
  public delegator: url.URL;

  asObject() {
    return {
      type: this.type,
      signature: this.signature.asObject(),
      delegator: this.delegator.toString(),
    };
  }
}

export class DirectoryAnchor {
  public readonly type = TransactionType.DirectoryAnchor;
  public source: url.URL;
  public majorBlockIndex: number;
  public minorBlockIndex: number;
  public rootChainIndex: number;
  public rootChainAnchor: Uint8Array;
  public stateTreeAnchor: Uint8Array;
  public updates: NetworkAccountUpdate[];
  public receipts: PartitionAnchorReceipt[];
  public makeMajorBlock: number;
  public makeMajorBlockTime: Date;

  asObject() {
    return {
      type: this.type,
      source: this.source.toString(),
      majorBlockIndex: this.majorBlockIndex,
      minorBlockIndex: this.minorBlockIndex,
      rootChainIndex: this.rootChainIndex,
      rootChainAnchor: Buffer.from(this.rootChainAnchor).toString("hex"),
      stateTreeAnchor: Buffer.from(this.stateTreeAnchor).toString("hex"),
      updates: this.updates?.map((v) => v.asObject()),
      receipts: this.receipts?.map((v) => v.asObject()),
      makeMajorBlock: this.makeMajorBlock,
      makeMajorBlockTime: this.makeMajorBlockTime,
    };
  }
}

export class DisableAccountAuthOperation {
  public readonly type = AccountAuthOperationType.Disable;
  public authority: url.URL;

  asObject() {
    return {
      type: this.type,
      authority: this.authority.toString(),
    };
  }
}

export class ED25519Signature {
  public readonly type = SignatureType.ED25519;
  public publicKey: Uint8Array;
  public signature: Uint8Array;
  public signer: url.URL;
  public signerVersion: number;
  public timestamp?: number;
  public vote?: VoteType;
  public transactionHash?: Uint8Array;

  asObject() {
    return {
      type: this.type,
      publicKey: Buffer.from(this.publicKey).toString("hex"),
      signature: Buffer.from(this.signature).toString("hex"),
      signer: this.signer.toString(),
      signerVersion: this.signerVersion,
      timestamp: this.timestamp && this.timestamp,
      vote: this.vote && this.vote.toString(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export class ETHSignature {
  public readonly type = SignatureType.ETH;
  public publicKey: Uint8Array;
  public signature: Uint8Array;
  public signer: url.URL;
  public signerVersion: number;
  public timestamp?: number;
  public vote?: VoteType;
  public transactionHash?: Uint8Array;

  asObject() {
    return {
      type: this.type,
      publicKey: Buffer.from(this.publicKey).toString("hex"),
      signature: Buffer.from(this.signature).toString("hex"),
      signer: this.signer.toString(),
      signerVersion: this.signerVersion,
      timestamp: this.timestamp && this.timestamp,
      vote: this.vote && this.vote.toString(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export class EmptyResult {
  public readonly type = TransactionType.Unknown;

  asObject() {
    return {
      type: this.type,
    };
  }
}

export class EnableAccountAuthOperation {
  public readonly type = AccountAuthOperationType.Enable;
  public authority: url.URL;

  asObject() {
    return {
      type: this.type,
      authority: this.authority.toString(),
    };
  }
}

export class Envelope {
  public signatures: Signature[];
  public txHash?: Uint8Array;
  public transaction?: Transaction[];

  asObject() {
    return {
      signatures: this.signatures?.map((v) => v.asObject()),
      txHash: this.txHash && Buffer.from(this.txHash).toString("hex"),
      transaction: this.transaction?.map((v) => v.asObject()),
    };
  }
}

export class FactomDataEntry {
  public accountId: Uint8Array;
  public data: Uint8Array;
  public extIds: Uint8Array[];

  asObject() {
    return {
      accountId: Buffer.from(this.accountId).toString("hex"),
      data: Buffer.from(this.data).toString("hex"),
      extIds: this.extIds?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export class FactomDataEntryWrapper {
  public readonly type = DataEntryType.Factom;
  public accountId: Uint8Array;
  public data: Uint8Array;
  public extIds: Uint8Array[];

  asObject() {
    return {
      type: this.type,
      accountId: Buffer.from(this.accountId).toString("hex"),
      data: Buffer.from(this.data).toString("hex"),
      extIds: this.extIds?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export class FeeSchedule {
  public createIdentitySliding: Fee[];

  asObject() {
    return {
      createIdentitySliding: this.createIdentitySliding?.map((v) => v.toString()),
    };
  }
}

export class IndexEntry {
  public source: number;
  public anchor: number;
  public blockIndex: number;
  public blockTime: Date;
  public rootIndexIndex: number;

  asObject() {
    return {
      source: this.source,
      anchor: this.anchor,
      blockIndex: this.blockIndex,
      blockTime: this.blockTime,
      rootIndexIndex: this.rootIndexIndex,
    };
  }
}

export class InternalSignature {
  public readonly type = SignatureType.Internal;
  public cause: Uint8Array;
  public transactionHash: Uint8Array;

  asObject() {
    return {
      type: this.type,
      cause: Buffer.from(this.cause).toString("hex"),
      transactionHash: Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export class IssueTokens {
  public readonly type = TransactionType.IssueTokens;
  public recipient: url.URL;
  public amount: BN;
  public to: TokenRecipient[];

  asObject() {
    return {
      type: this.type,
      recipient: this.recipient.toString(),
      amount: this.amount.toString(),
      to: this.to?.map((v) => v.asObject()),
    };
  }
}

export class KeyBook {
  public readonly type = AccountType.KeyBook;
  public url: url.URL;
  public bookType: BookType;
  public authorities: AuthorityEntry[];
  public pageCount: number;

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      bookType: this.bookType.toString(),
      authorities: this.authorities?.map((v) => v.asObject()),
      pageCount: this.pageCount,
    };
  }
}

export class KeyPage {
  public readonly type = AccountType.KeyPage;
  public url: url.URL;
  public creditBalance: number;
  public acceptThreshold: number;
  public rejectThreshold: number;
  public responseThreshold: number;
  public blockThreshold: number;
  public version: number;
  public keys: KeySpec[];
  public transactionBlacklist?: AllowedTransactions;

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      creditBalance: this.creditBalance,
      acceptThreshold: this.acceptThreshold,
      rejectThreshold: this.rejectThreshold,
      responseThreshold: this.responseThreshold,
      blockThreshold: this.blockThreshold,
      version: this.version,
      keys: this.keys?.map((v) => v.asObject()),
      transactionBlacklist: this.transactionBlacklist && this.transactionBlacklist.toString(),
    };
  }
}

export class KeySpec {
  public publicKeyHash: Uint8Array;
  public lastUsedOn: number;
  public delegate: url.URL;

  asObject() {
    return {
      publicKeyHash: Buffer.from(this.publicKeyHash).toString("hex"),
      lastUsedOn: this.lastUsedOn,
      delegate: this.delegate.toString(),
    };
  }
}

export class KeySpecParams {
  public keyHash: Uint8Array;
  public delegate?: url.URL;

  asObject() {
    return {
      keyHash: Buffer.from(this.keyHash).toString("hex"),
      delegate: this.delegate && this.delegate.toString(),
    };
  }
}

export class LegacyED25519Signature {
  public readonly type = SignatureType.LegacyED25519;
  public timestamp: number;
  public publicKey: Uint8Array;
  public signature: Uint8Array;
  public signer: url.URL;
  public signerVersion: number;
  public vote?: VoteType;
  public transactionHash?: Uint8Array;

  asObject() {
    return {
      type: this.type,
      timestamp: this.timestamp,
      publicKey: Buffer.from(this.publicKey).toString("hex"),
      signature: Buffer.from(this.signature).toString("hex"),
      signer: this.signer.toString(),
      signerVersion: this.signerVersion,
      vote: this.vote && this.vote.toString(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export class LiteDataAccount {
  public readonly type = AccountType.LiteDataAccount;
  public url: url.URL;

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
    };
  }
}

export class LiteIdentity {
  public readonly type = AccountType.LiteIdentity;
  public url: url.URL;
  public creditBalance: number;
  public lastUsedOn: number;

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      creditBalance: this.creditBalance,
      lastUsedOn: this.lastUsedOn,
    };
  }
}

export class LiteTokenAccount {
  public readonly type = AccountType.LiteTokenAccount;
  public url: url.URL;
  public tokenUrl: url.URL;
  public balance: BN;
  public lockHeight: number;

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      tokenUrl: this.tokenUrl.toString(),
      balance: this.balance.toString(),
      lockHeight: this.lockHeight,
    };
  }
}

export class LockAccount {
  public readonly type = TransactionType.LockAccount;
  public height: number;

  asObject() {
    return {
      type: this.type,
      height: this.height,
    };
  }
}

export class NetworkAccountUpdate {
  public name: string;
  public body: TransactionBody;

  asObject() {
    return {
      name: this.name,
      body: this.body.asObject(),
    };
  }
}

export class NetworkDefinition {
  public networkName: string;
  public version: number;
  public partitions: PartitionInfo[];
  public validators: ValidatorInfo[];

  asObject() {
    return {
      networkName: this.networkName,
      version: this.version,
      partitions: this.partitions?.map((v) => v.asObject()),
      validators: this.validators?.map((v) => v.asObject()),
    };
  }
}

export class NetworkGlobals {
  public operatorAcceptThreshold: Rational;
  public validatorAcceptThreshold: Rational;
  public majorBlockSchedule: string;
  public anchorEmptyBlocks: boolean;
  public feeSchedule: FeeSchedule;
  public limits: NetworkLimits;

  asObject() {
    return {
      operatorAcceptThreshold: this.operatorAcceptThreshold.asObject(),
      validatorAcceptThreshold: this.validatorAcceptThreshold.asObject(),
      majorBlockSchedule: this.majorBlockSchedule,
      anchorEmptyBlocks: this.anchorEmptyBlocks,
      feeSchedule: this.feeSchedule.asObject(),
      limits: this.limits.asObject(),
    };
  }
}

export class NetworkLimits {
  public dataEntryParts: number;
  public accountAuthorities: number;
  public bookPages: number;
  public pageEntries: number;
  public identityAccounts: number;

  asObject() {
    return {
      dataEntryParts: this.dataEntryParts,
      accountAuthorities: this.accountAuthorities,
      bookPages: this.bookPages,
      pageEntries: this.pageEntries,
      identityAccounts: this.identityAccounts,
    };
  }
}

export class PartitionAnchor {
  public source: url.URL;
  public majorBlockIndex: number;
  public minorBlockIndex: number;
  public rootChainIndex: number;
  public rootChainAnchor: Uint8Array;
  public stateTreeAnchor: Uint8Array;

  asObject() {
    return {
      source: this.source.toString(),
      majorBlockIndex: this.majorBlockIndex,
      minorBlockIndex: this.minorBlockIndex,
      rootChainIndex: this.rootChainIndex,
      rootChainAnchor: Buffer.from(this.rootChainAnchor).toString("hex"),
      stateTreeAnchor: Buffer.from(this.stateTreeAnchor).toString("hex"),
    };
  }
}

export class PartitionAnchorReceipt {
  public anchor: PartitionAnchor;
  public rootChainReceipt: managed.Receipt;

  asObject() {
    return {
      anchor: this.anchor.asObject(),
      rootChainReceipt: this.rootChainReceipt.asObject(),
    };
  }
}

export class PartitionInfo {
  public id: string;
  public type: PartitionType;

  asObject() {
    return {
      id: this.id,
      type: this.type.toString(),
    };
  }
}

export class PartitionSignature {
  public readonly type = SignatureType.Partition;
  public sourceNetwork: url.URL;
  public destinationNetwork: url.URL;
  public sequenceNumber: number;
  public transactionHash?: Uint8Array;

  asObject() {
    return {
      type: this.type,
      sourceNetwork: this.sourceNetwork.toString(),
      destinationNetwork: this.destinationNetwork.toString(),
      sequenceNumber: this.sequenceNumber,
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export class PartitionSyntheticLedger {
  public url: url.URL;
  public produced: number;
  public received: number;
  public delivered: number;
  public pending: url.TxID[];

  asObject() {
    return {
      url: this.url.toString(),
      produced: this.produced,
      received: this.received,
      delivered: this.delivered,
      pending: this.pending?.map((v) => v.toString()),
    };
  }
}

export class RCD1Signature {
  public readonly type = SignatureType.RCD1;
  public publicKey: Uint8Array;
  public signature: Uint8Array;
  public signer: url.URL;
  public signerVersion: number;
  public timestamp?: number;
  public vote?: VoteType;
  public transactionHash?: Uint8Array;

  asObject() {
    return {
      type: this.type,
      publicKey: Buffer.from(this.publicKey).toString("hex"),
      signature: Buffer.from(this.signature).toString("hex"),
      signer: this.signer.toString(),
      signerVersion: this.signerVersion,
      timestamp: this.timestamp && this.timestamp,
      vote: this.vote && this.vote.toString(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export class Rational {
  public numerator: number;
  public denominator: number;

  asObject() {
    return {
      numerator: this.numerator,
      denominator: this.denominator,
    };
  }
}

export class ReceiptSignature {
  public readonly type = SignatureType.Receipt;
  public sourceNetwork: url.URL;
  public proof: managed.Receipt;
  public transactionHash?: Uint8Array;

  asObject() {
    return {
      type: this.type,
      sourceNetwork: this.sourceNetwork.toString(),
      proof: this.proof.asObject(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export class RemoteSignature {
  public readonly type = SignatureType.Remote;
  public destination: url.URL;
  public signature: Signature;
  public cause: Uint8Array[];

  asObject() {
    return {
      type: this.type,
      destination: this.destination.toString(),
      signature: this.signature.asObject(),
      cause: this.cause?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export class RemoteTransaction {
  public readonly type = TransactionType.Remote;
  public hash?: Uint8Array;

  asObject() {
    return {
      type: this.type,
      hash: this.hash && Buffer.from(this.hash).toString("hex"),
    };
  }
}

export class RemoveAccountAuthorityOperation {
  public readonly type = AccountAuthOperationType.RemoveAuthority;
  public authority: url.URL;

  asObject() {
    return {
      type: this.type,
      authority: this.authority.toString(),
    };
  }
}

export class RemoveKeyOperation {
  public readonly type = KeyPageOperationType.Remove;
  public entry: KeySpecParams;

  asObject() {
    return {
      type: this.type,
      entry: this.entry.asObject(),
    };
  }
}

export class Route {
  public length: number;
  public value: number;
  public partition: string;

  asObject() {
    return {
      length: this.length,
      value: this.value,
      partition: this.partition,
    };
  }
}

export class RouteOverride {
  public account: url.URL;
  public partition: string;

  asObject() {
    return {
      account: this.account.toString(),
      partition: this.partition,
    };
  }
}

export class RoutingTable {
  public overrides: RouteOverride[];
  public routes: Route[];

  asObject() {
    return {
      overrides: this.overrides?.map((v) => v.asObject()),
      routes: this.routes?.map((v) => v.asObject()),
    };
  }
}

export class SendTokens {
  public readonly type = TransactionType.SendTokens;
  public hash?: Uint8Array;
  public meta?: unknown;
  public to: TokenRecipient[];

  asObject() {
    return {
      type: this.type,
      hash: this.hash && Buffer.from(this.hash).toString("hex"),
      meta: this.meta && this.meta,
      to: this.to?.map((v) => v.asObject()),
    };
  }
}

export class SetThresholdKeyPageOperation {
  public readonly type = KeyPageOperationType.SetThreshold;
  public threshold: number;

  asObject() {
    return {
      type: this.type,
      threshold: this.threshold,
    };
  }
}

export class SignatureSet {
  public readonly type = SignatureType.Set;
  public vote?: VoteType;
  public signer: url.URL;
  public authority: url.URL;
  public transactionHash?: Uint8Array;
  public signatures: Signature[];

  asObject() {
    return {
      type: this.type,
      vote: this.vote && this.vote.toString(),
      signer: this.signer.toString(),
      authority: this.authority.toString(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
      signatures: this.signatures?.map((v) => v.asObject()),
    };
  }
}

export class SyntheticBurnTokens {
  public readonly type = TransactionType.SyntheticBurnTokens;
  public cause: url.TxID;
  public source: url.URL;
  public initiator: url.URL;
  public feeRefund: number;
  public amount: BN;
  public isRefund: boolean;

  asObject() {
    return {
      type: this.type,
      cause: this.cause.toString(),
      source: this.source.toString(),
      initiator: this.initiator.toString(),
      feeRefund: this.feeRefund,
      amount: this.amount.toString(),
      isRefund: this.isRefund,
    };
  }
}

export class SyntheticCreateIdentity {
  public readonly type = TransactionType.SyntheticCreateIdentity;
  public cause: url.TxID;
  public source: url.URL;
  public initiator: url.URL;
  public feeRefund: number;
  public accounts: Account[];

  asObject() {
    return {
      type: this.type,
      cause: this.cause.toString(),
      source: this.source.toString(),
      initiator: this.initiator.toString(),
      feeRefund: this.feeRefund,
      accounts: this.accounts?.map((v) => v.asObject()),
    };
  }
}

export class SyntheticDepositCredits {
  public readonly type = TransactionType.SyntheticDepositCredits;
  public cause: url.TxID;
  public source: url.URL;
  public initiator: url.URL;
  public feeRefund: number;
  public amount: number;
  public acmeRefundAmount: BN;
  public isRefund: boolean;

  asObject() {
    return {
      type: this.type,
      cause: this.cause.toString(),
      source: this.source.toString(),
      initiator: this.initiator.toString(),
      feeRefund: this.feeRefund,
      amount: this.amount,
      acmeRefundAmount: this.acmeRefundAmount.toString(),
      isRefund: this.isRefund,
    };
  }
}

export class SyntheticDepositTokens {
  public readonly type = TransactionType.SyntheticDepositTokens;
  public cause: url.TxID;
  public source: url.URL;
  public initiator: url.URL;
  public feeRefund: number;
  public token: url.URL;
  public amount: BN;
  public isIssuer: boolean;
  public isRefund: boolean;

  asObject() {
    return {
      type: this.type,
      cause: this.cause.toString(),
      source: this.source.toString(),
      initiator: this.initiator.toString(),
      feeRefund: this.feeRefund,
      token: this.token.toString(),
      amount: this.amount.toString(),
      isIssuer: this.isIssuer,
      isRefund: this.isRefund,
    };
  }
}

export class SyntheticForwardTransaction {
  public readonly type = TransactionType.SyntheticForwardTransaction;
  public signatures: RemoteSignature[];
  public transaction?: Transaction;

  asObject() {
    return {
      type: this.type,
      signatures: this.signatures?.map((v) => v.asObject()),
      transaction: this.transaction && this.transaction.asObject(),
    };
  }
}

export class SyntheticLedger {
  public readonly type = AccountType.SyntheticLedger;
  public url: url.URL;
  public sequence: PartitionSyntheticLedger[];

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      sequence: this.sequence?.map((v) => v.asObject()),
    };
  }
}

export class SyntheticOrigin {
  public cause: url.TxID;
  public initiator: url.URL;
  public feeRefund: number;

  asObject() {
    return {
      cause: this.cause.toString(),
      initiator: this.initiator.toString(),
      feeRefund: this.feeRefund,
    };
  }
}

export class SyntheticWriteData {
  public readonly type = TransactionType.SyntheticWriteData;
  public cause: url.TxID;
  public source: url.URL;
  public initiator: url.URL;
  public feeRefund: number;
  public entry: DataEntry;

  asObject() {
    return {
      type: this.type,
      cause: this.cause.toString(),
      source: this.source.toString(),
      initiator: this.initiator.toString(),
      feeRefund: this.feeRefund,
      entry: this.entry.asObject(),
    };
  }
}

export class SystemGenesis {
  public readonly type = TransactionType.SystemGenesis;

  asObject() {
    return {
      type: this.type,
    };
  }
}

export class SystemLedger {
  public readonly type = AccountType.SystemLedger;
  public url: url.URL;
  public index: number;
  public timestamp: Date;
  public acmeBurnt: BN;
  public pendingUpdates: NetworkAccountUpdate[];
  public anchor: AnchorBody;

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      index: this.index,
      timestamp: this.timestamp,
      acmeBurnt: this.acmeBurnt.toString(),
      pendingUpdates: this.pendingUpdates?.map((v) => v.asObject()),
      anchor: this.anchor.asObject(),
    };
  }
}

export class SystemWriteData {
  public readonly type = TransactionType.SystemWriteData;
  public entry: DataEntry;
  public writeToState?: boolean;

  asObject() {
    return {
      type: this.type,
      entry: this.entry.asObject(),
      writeToState: this.writeToState && this.writeToState,
    };
  }
}

export class TokenAccount {
  public readonly type = AccountType.TokenAccount;
  public url: url.URL;
  public authorities: AuthorityEntry[];
  public tokenUrl: url.URL;
  public balance: BN;

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      authorities: this.authorities?.map((v) => v.asObject()),
      tokenUrl: this.tokenUrl.toString(),
      balance: this.balance.toString(),
    };
  }
}

export class TokenIssuer {
  public readonly type = AccountType.TokenIssuer;
  public url: url.URL;
  public authorities: AuthorityEntry[];
  public symbol: string;
  public precision: number;
  public properties: url.URL;
  public issued: BN;
  public supplyLimit?: BN;

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      authorities: this.authorities?.map((v) => v.asObject()),
      symbol: this.symbol,
      precision: this.precision,
      properties: this.properties.toString(),
      issued: this.issued.toString(),
      supplyLimit: this.supplyLimit && this.supplyLimit.toString(),
    };
  }
}

export class TokenIssuerProof {
  public transaction: CreateToken;
  public receipt: managed.Receipt;

  asObject() {
    return {
      transaction: this.transaction.asObject(),
      receipt: this.receipt.asObject(),
    };
  }
}

export class TokenRecipient {
  public url: url.URL;
  public amount: BN;

  asObject() {
    return {
      url: this.url.toString(),
      amount: this.amount.toString(),
    };
  }
}

export class Transaction {
  public header: TransactionHeader;
  public body: TransactionBody;

  asObject() {
    return {
      header: this.header.asObject(),
      body: this.body.asObject(),
    };
  }
}

export class TransactionHeader {
  public principal: url.URL;
  public initiator: Uint8Array;
  public memo?: string;
  public metadata?: Uint8Array;

  asObject() {
    return {
      principal: this.principal.toString(),
      initiator: Buffer.from(this.initiator).toString("hex"),
      memo: this.memo && this.memo,
      metadata: this.metadata && Buffer.from(this.metadata).toString("hex"),
    };
  }
}

export class TransactionStatus {
  public txID: url.TxID;
  public code: errors2.Status;
  public error: errors2.Error;
  public result: TransactionResult;
  public received: number;
  public initiator: url.URL;
  public signers: Signer[];
  public sourceNetwork: url.URL;
  public destinationNetwork: url.URL;
  public sequenceNumber: number;
  public gotDirectoryReceipt: boolean;
  public proof: managed.Receipt;
  public anchorSigners: Uint8Array[];

  asObject() {
    return {
      txID: this.txID.toString(),
      code: this.code.toString(),
      error: this.error.asObject(),
      result: this.result.asObject(),
      received: this.received,
      initiator: this.initiator.toString(),
      signers: this.signers?.map((v) => v.asObject()),
      sourceNetwork: this.sourceNetwork.toString(),
      destinationNetwork: this.destinationNetwork.toString(),
      sequenceNumber: this.sequenceNumber,
      gotDirectoryReceipt: this.gotDirectoryReceipt,
      proof: this.proof.asObject(),
      anchorSigners: this.anchorSigners?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export class TxIdSet {
  public entries: url.TxID[];

  asObject() {
    return {
      entries: this.entries?.map((v) => v.toString()),
    };
  }
}

export class UnknownAccount {
  public readonly type = AccountType.Unknown;
  public url: url.URL;

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
    };
  }
}

export class UnknownSigner {
  public readonly type = AccountType.UnknownSigner;
  public url: url.URL;
  public version: number;

  asObject() {
    return {
      type: this.type,
      url: this.url.toString(),
      version: this.version,
    };
  }
}

export class UpdateAccountAuth {
  public readonly type = TransactionType.UpdateAccountAuth;
  public operations: AccountAuthOperation[];

  asObject() {
    return {
      type: this.type,
      operations: this.operations?.map((v) => v.asObject()),
    };
  }
}

export class UpdateAllowedKeyPageOperation {
  public readonly type = KeyPageOperationType.UpdateAllowed;
  public allow?: TransactionType[];
  public deny?: TransactionType[];

  asObject() {
    return {
      type: this.type,
      allow: this.allow?.map((v) => v.toString()),
      deny: this.deny?.map((v) => v.toString()),
    };
  }
}

export class UpdateKey {
  public readonly type = TransactionType.UpdateKey;
  public newKeyHash: Uint8Array;

  asObject() {
    return {
      type: this.type,
      newKeyHash: Buffer.from(this.newKeyHash).toString("hex"),
    };
  }
}

export class UpdateKeyOperation {
  public readonly type = KeyPageOperationType.Update;
  public oldEntry: KeySpecParams;
  public newEntry: KeySpecParams;

  asObject() {
    return {
      type: this.type,
      oldEntry: this.oldEntry.asObject(),
      newEntry: this.newEntry.asObject(),
    };
  }
}

export class UpdateKeyPage {
  public readonly type = TransactionType.UpdateKeyPage;
  public operation: KeyPageOperation[];

  asObject() {
    return {
      type: this.type,
      operation: this.operation?.map((v) => v.asObject()),
    };
  }
}

export class ValidatorInfo {
  public publicKey: Uint8Array;
  public publicKeyHash: Uint8Array;
  public operator: url.URL;
  public partitions: ValidatorPartitionInfo[];

  asObject() {
    return {
      publicKey: Buffer.from(this.publicKey).toString("hex"),
      publicKeyHash: Buffer.from(this.publicKeyHash).toString("hex"),
      operator: this.operator.toString(),
      partitions: this.partitions?.map((v) => v.asObject()),
    };
  }
}

export class ValidatorPartitionInfo {
  public id: string;
  public active: boolean;

  asObject() {
    return {
      id: this.id,
      active: this.active,
    };
  }
}

export class WriteData {
  public readonly type = TransactionType.WriteData;
  public entry: DataEntry;
  public scratch?: boolean;
  public writeToState?: boolean;

  asObject() {
    return {
      type: this.type,
      entry: this.entry.asObject(),
      scratch: this.scratch && this.scratch,
      writeToState: this.writeToState && this.writeToState,
    };
  }
}

export class WriteDataResult {
  public readonly type = TransactionType.WriteData;
  public entryHash: Uint8Array;
  public accountUrl: url.URL;
  public accountID: Uint8Array;

  asObject() {
    return {
      type: this.type,
      entryHash: Buffer.from(this.entryHash).toString("hex"),
      accountUrl: this.accountUrl.toString(),
      accountID: Buffer.from(this.accountID).toString("hex"),
    };
  }
}

export class WriteDataTo {
  public readonly type = TransactionType.WriteDataTo;
  public recipient: url.URL;
  public entry: DataEntry;

  asObject() {
    return {
      type: this.type,
      recipient: this.recipient.toString(),
      entry: this.entry.asObject(),
    };
  }
}
