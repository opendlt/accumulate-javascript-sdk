import * as types from ".";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */

export type Account =
  | types.ADI
  | types.AnchorLedger
  | types.BlockLedger
  | types.DataAccount
  | types.KeyBook
  | types.KeyPage
  | types.LiteDataAccount
  | types.LiteIdentity
  | types.LiteTokenAccount
  | types.SyntheticLedger
  | types.SystemLedger
  | types.TokenAccount
  | types.TokenIssuer
  | types.UnknownAccount
  | types.UnknownSigner;

export namespace Account {
  export type Args =
    | types.ADI
    | types.ADI.ArgsWithType
    | types.AnchorLedger
    | types.AnchorLedger.ArgsWithType
    | types.BlockLedger
    | types.BlockLedger.ArgsWithType
    | types.DataAccount
    | types.DataAccount.ArgsWithType
    | types.KeyBook
    | types.KeyBook.ArgsWithType
    | types.KeyPage
    | types.KeyPage.ArgsWithType
    | types.LiteDataAccount
    | types.LiteDataAccount.ArgsWithType
    | types.LiteIdentity
    | types.LiteIdentity.ArgsWithType
    | types.LiteTokenAccount
    | types.LiteTokenAccount.ArgsWithType
    | types.SyntheticLedger
    | types.SyntheticLedger.ArgsWithType
    | types.SystemLedger
    | types.SystemLedger.ArgsWithType
    | types.TokenAccount
    | types.TokenAccount.ArgsWithType
    | types.TokenIssuer
    | types.TokenIssuer.ArgsWithType
    | types.UnknownAccount
    | types.UnknownAccount.ArgsWithType
    | types.UnknownSigner
    | types.UnknownSigner.ArgsWithType;

  export function fromObject(obj: Args): Account {
    if (obj instanceof types.ADI) return obj;
    if (obj instanceof types.AnchorLedger) return obj;
    if (obj instanceof types.BlockLedger) return obj;
    if (obj instanceof types.DataAccount) return obj;
    if (obj instanceof types.KeyBook) return obj;
    if (obj instanceof types.KeyPage) return obj;
    if (obj instanceof types.LiteDataAccount) return obj;
    if (obj instanceof types.LiteIdentity) return obj;
    if (obj instanceof types.LiteTokenAccount) return obj;
    if (obj instanceof types.SyntheticLedger) return obj;
    if (obj instanceof types.SystemLedger) return obj;
    if (obj instanceof types.TokenAccount) return obj;
    if (obj instanceof types.TokenIssuer) return obj;
    if (obj instanceof types.UnknownAccount) return obj;
    if (obj instanceof types.UnknownSigner) return obj;

    switch (obj.type) {
      case (types.AccountType.Identity, "identity"):
        return new types.ADI(obj);
      case (types.AccountType.AnchorLedger, "anchorLedger"):
        return new types.AnchorLedger(obj);
      case (types.AccountType.BlockLedger, "blockLedger"):
        return new types.BlockLedger(obj);
      case (types.AccountType.DataAccount, "dataAccount"):
        return new types.DataAccount(obj);
      case (types.AccountType.KeyBook, "keyBook"):
        return new types.KeyBook(obj);
      case (types.AccountType.KeyPage, "keyPage"):
        return new types.KeyPage(obj);
      case (types.AccountType.LiteDataAccount, "liteDataAccount"):
        return new types.LiteDataAccount(obj);
      case (types.AccountType.LiteIdentity, "liteIdentity"):
        return new types.LiteIdentity(obj);
      case (types.AccountType.LiteTokenAccount, "liteTokenAccount"):
        return new types.LiteTokenAccount(obj);
      case (types.AccountType.SyntheticLedger, "syntheticLedger"):
        return new types.SyntheticLedger(obj);
      case (types.AccountType.SystemLedger, "systemLedger"):
        return new types.SystemLedger(obj);
      case (types.AccountType.TokenAccount, "tokenAccount"):
        return new types.TokenAccount(obj);
      case (types.AccountType.TokenIssuer, "tokenIssuer"):
        return new types.TokenIssuer(obj);
      case (types.AccountType.Unknown, "unknown"):
        return new types.UnknownAccount(obj);
      case (types.AccountType.UnknownSigner, "unknownSigner"):
        return new types.UnknownSigner(obj);
    }

    throw new Error(`Unknown account '${obj.type}'`);
  }
}

export type DataEntry = types.AccumulateDataEntry | types.FactomDataEntryWrapper;

export namespace DataEntry {
  export type Args =
    | types.AccumulateDataEntry
    | types.AccumulateDataEntry.ArgsWithType
    | types.FactomDataEntryWrapper
    | types.FactomDataEntryWrapper.ArgsWithType;

  export function fromObject(obj: Args): DataEntry {
    if (obj instanceof types.AccumulateDataEntry) return obj;
    if (obj instanceof types.FactomDataEntryWrapper) return obj;

    switch (obj.type) {
      case (types.DataEntryType.Accumulate, "accumulate"):
        return new types.AccumulateDataEntry(obj);
      case (types.DataEntryType.Factom, "factom"):
        return new types.FactomDataEntryWrapper(obj);
    }

    throw new Error(`Unknown data entry '${obj.type}'`);
  }
}

export type TransactionBody =
  | types.AcmeFaucet
  | types.AddCredits
  | types.BlockValidatorAnchor
  | types.BurnTokens
  | types.CreateDataAccount
  | types.CreateIdentity
  | types.CreateKeyBook
  | types.CreateKeyPage
  | types.CreateLiteTokenAccount
  | types.CreateToken
  | types.CreateTokenAccount
  | types.DirectoryAnchor
  | types.IssueTokens
  | types.LockAccount
  | types.RemoteTransaction
  | types.SendTokens
  | types.SyntheticBurnTokens
  | types.SyntheticCreateIdentity
  | types.SyntheticDepositCredits
  | types.SyntheticDepositTokens
  | types.SyntheticForwardTransaction
  | types.SyntheticWriteData
  | types.SystemGenesis
  | types.SystemWriteData
  | types.UpdateAccountAuth
  | types.UpdateKey
  | types.UpdateKeyPage
  | types.WriteData
  | types.WriteDataTo;

export namespace TransactionBody {
  export type Args =
    | types.AcmeFaucet
    | types.AcmeFaucet.ArgsWithType
    | types.AddCredits
    | types.AddCredits.ArgsWithType
    | types.BlockValidatorAnchor
    | types.BlockValidatorAnchor.ArgsWithType
    | types.BurnTokens
    | types.BurnTokens.ArgsWithType
    | types.CreateDataAccount
    | types.CreateDataAccount.ArgsWithType
    | types.CreateIdentity
    | types.CreateIdentity.ArgsWithType
    | types.CreateKeyBook
    | types.CreateKeyBook.ArgsWithType
    | types.CreateKeyPage
    | types.CreateKeyPage.ArgsWithType
    | types.CreateLiteTokenAccount
    | types.CreateLiteTokenAccount.ArgsWithType
    | types.CreateToken
    | types.CreateToken.ArgsWithType
    | types.CreateTokenAccount
    | types.CreateTokenAccount.ArgsWithType
    | types.DirectoryAnchor
    | types.DirectoryAnchor.ArgsWithType
    | types.IssueTokens
    | types.IssueTokens.ArgsWithType
    | types.LockAccount
    | types.LockAccount.ArgsWithType
    | types.RemoteTransaction
    | types.RemoteTransaction.ArgsWithType
    | types.SendTokens
    | types.SendTokens.ArgsWithType
    | types.SyntheticBurnTokens
    | types.SyntheticBurnTokens.ArgsWithType
    | types.SyntheticCreateIdentity
    | types.SyntheticCreateIdentity.ArgsWithType
    | types.SyntheticDepositCredits
    | types.SyntheticDepositCredits.ArgsWithType
    | types.SyntheticDepositTokens
    | types.SyntheticDepositTokens.ArgsWithType
    | types.SyntheticForwardTransaction
    | types.SyntheticForwardTransaction.ArgsWithType
    | types.SyntheticWriteData
    | types.SyntheticWriteData.ArgsWithType
    | types.SystemGenesis
    | types.SystemGenesis.ArgsWithType
    | types.SystemWriteData
    | types.SystemWriteData.ArgsWithType
    | types.UpdateAccountAuth
    | types.UpdateAccountAuth.ArgsWithType
    | types.UpdateKey
    | types.UpdateKey.ArgsWithType
    | types.UpdateKeyPage
    | types.UpdateKeyPage.ArgsWithType
    | types.WriteData
    | types.WriteData.ArgsWithType
    | types.WriteDataTo
    | types.WriteDataTo.ArgsWithType;

  export function fromObject(obj: Args): TransactionBody {
    if (obj instanceof types.AcmeFaucet) return obj;
    if (obj instanceof types.AddCredits) return obj;
    if (obj instanceof types.BlockValidatorAnchor) return obj;
    if (obj instanceof types.BurnTokens) return obj;
    if (obj instanceof types.CreateDataAccount) return obj;
    if (obj instanceof types.CreateIdentity) return obj;
    if (obj instanceof types.CreateKeyBook) return obj;
    if (obj instanceof types.CreateKeyPage) return obj;
    if (obj instanceof types.CreateLiteTokenAccount) return obj;
    if (obj instanceof types.CreateToken) return obj;
    if (obj instanceof types.CreateTokenAccount) return obj;
    if (obj instanceof types.DirectoryAnchor) return obj;
    if (obj instanceof types.IssueTokens) return obj;
    if (obj instanceof types.LockAccount) return obj;
    if (obj instanceof types.RemoteTransaction) return obj;
    if (obj instanceof types.SendTokens) return obj;
    if (obj instanceof types.SyntheticBurnTokens) return obj;
    if (obj instanceof types.SyntheticCreateIdentity) return obj;
    if (obj instanceof types.SyntheticDepositCredits) return obj;
    if (obj instanceof types.SyntheticDepositTokens) return obj;
    if (obj instanceof types.SyntheticForwardTransaction) return obj;
    if (obj instanceof types.SyntheticWriteData) return obj;
    if (obj instanceof types.SystemGenesis) return obj;
    if (obj instanceof types.SystemWriteData) return obj;
    if (obj instanceof types.UpdateAccountAuth) return obj;
    if (obj instanceof types.UpdateKey) return obj;
    if (obj instanceof types.UpdateKeyPage) return obj;
    if (obj instanceof types.WriteData) return obj;
    if (obj instanceof types.WriteDataTo) return obj;

    switch (obj.type) {
      case (types.TransactionType.AcmeFaucet, "acmeFaucet"):
        return new types.AcmeFaucet(obj);
      case (types.TransactionType.AddCredits, "addCredits"):
        return new types.AddCredits(obj);
      case (types.TransactionType.BlockValidatorAnchor, "blockValidatorAnchor"):
        return new types.BlockValidatorAnchor(obj);
      case (types.TransactionType.BurnTokens, "burnTokens"):
        return new types.BurnTokens(obj);
      case (types.TransactionType.CreateDataAccount, "createDataAccount"):
        return new types.CreateDataAccount(obj);
      case (types.TransactionType.CreateIdentity, "createIdentity"):
        return new types.CreateIdentity(obj);
      case (types.TransactionType.CreateKeyBook, "createKeyBook"):
        return new types.CreateKeyBook(obj);
      case (types.TransactionType.CreateKeyPage, "createKeyPage"):
        return new types.CreateKeyPage(obj);
      case (types.TransactionType.CreateLiteTokenAccount, "createLiteTokenAccount"):
        return new types.CreateLiteTokenAccount(obj);
      case (types.TransactionType.CreateToken, "createToken"):
        return new types.CreateToken(obj);
      case (types.TransactionType.CreateTokenAccount, "createTokenAccount"):
        return new types.CreateTokenAccount(obj);
      case (types.TransactionType.DirectoryAnchor, "directoryAnchor"):
        return new types.DirectoryAnchor(obj);
      case (types.TransactionType.IssueTokens, "issueTokens"):
        return new types.IssueTokens(obj);
      case (types.TransactionType.LockAccount, "lockAccount"):
        return new types.LockAccount(obj);
      case (types.TransactionType.Remote, "remote"):
        return new types.RemoteTransaction(obj);
      case (types.TransactionType.SendTokens, "sendTokens"):
        return new types.SendTokens(obj);
      case (types.TransactionType.SyntheticBurnTokens, "syntheticBurnTokens"):
        return new types.SyntheticBurnTokens(obj);
      case (types.TransactionType.SyntheticCreateIdentity, "syntheticCreateIdentity"):
        return new types.SyntheticCreateIdentity(obj);
      case (types.TransactionType.SyntheticDepositCredits, "syntheticDepositCredits"):
        return new types.SyntheticDepositCredits(obj);
      case (types.TransactionType.SyntheticDepositTokens, "syntheticDepositTokens"):
        return new types.SyntheticDepositTokens(obj);
      case (types.TransactionType.SyntheticForwardTransaction, "syntheticForwardTransaction"):
        return new types.SyntheticForwardTransaction(obj);
      case (types.TransactionType.SyntheticWriteData, "syntheticWriteData"):
        return new types.SyntheticWriteData(obj);
      case (types.TransactionType.SystemGenesis, "systemGenesis"):
        return new types.SystemGenesis(obj);
      case (types.TransactionType.SystemWriteData, "systemWriteData"):
        return new types.SystemWriteData(obj);
      case (types.TransactionType.UpdateAccountAuth, "updateAccountAuth"):
        return new types.UpdateAccountAuth(obj);
      case (types.TransactionType.UpdateKey, "updateKey"):
        return new types.UpdateKey(obj);
      case (types.TransactionType.UpdateKeyPage, "updateKeyPage"):
        return new types.UpdateKeyPage(obj);
      case (types.TransactionType.WriteData, "writeData"):
        return new types.WriteData(obj);
      case (types.TransactionType.WriteDataTo, "writeDataTo"):
        return new types.WriteDataTo(obj);
    }

    throw new Error(`Unknown transaction body '${obj.type}'`);
  }
}

export type AccountAuthOperation =
  | types.AddAccountAuthorityOperation
  | types.DisableAccountAuthOperation
  | types.EnableAccountAuthOperation
  | types.RemoveAccountAuthorityOperation;

export namespace AccountAuthOperation {
  export type Args =
    | types.AddAccountAuthorityOperation
    | types.AddAccountAuthorityOperation.ArgsWithType
    | types.DisableAccountAuthOperation
    | types.DisableAccountAuthOperation.ArgsWithType
    | types.EnableAccountAuthOperation
    | types.EnableAccountAuthOperation.ArgsWithType
    | types.RemoveAccountAuthorityOperation
    | types.RemoveAccountAuthorityOperation.ArgsWithType;

  export function fromObject(obj: Args): AccountAuthOperation {
    if (obj instanceof types.AddAccountAuthorityOperation) return obj;
    if (obj instanceof types.DisableAccountAuthOperation) return obj;
    if (obj instanceof types.EnableAccountAuthOperation) return obj;
    if (obj instanceof types.RemoveAccountAuthorityOperation) return obj;

    switch (obj.type) {
      case (types.AccountAuthOperationType.AddAuthority, "addAuthority"):
        return new types.AddAccountAuthorityOperation(obj);
      case (types.AccountAuthOperationType.Disable, "disable"):
        return new types.DisableAccountAuthOperation(obj);
      case (types.AccountAuthOperationType.Enable, "enable"):
        return new types.EnableAccountAuthOperation(obj);
      case (types.AccountAuthOperationType.RemoveAuthority, "removeAuthority"):
        return new types.RemoveAccountAuthorityOperation(obj);
    }

    throw new Error(`Unknown account auth operation '${obj.type}'`);
  }
}

export type KeyPageOperation =
  | types.AddKeyOperation
  | types.RemoveKeyOperation
  | types.SetThresholdKeyPageOperation
  | types.UpdateAllowedKeyPageOperation
  | types.UpdateKeyOperation;

export namespace KeyPageOperation {
  export type Args =
    | types.AddKeyOperation
    | types.AddKeyOperation.ArgsWithType
    | types.RemoveKeyOperation
    | types.RemoveKeyOperation.ArgsWithType
    | types.SetThresholdKeyPageOperation
    | types.SetThresholdKeyPageOperation.ArgsWithType
    | types.UpdateAllowedKeyPageOperation
    | types.UpdateAllowedKeyPageOperation.ArgsWithType
    | types.UpdateKeyOperation
    | types.UpdateKeyOperation.ArgsWithType;

  export function fromObject(obj: Args): KeyPageOperation {
    if (obj instanceof types.AddKeyOperation) return obj;
    if (obj instanceof types.RemoveKeyOperation) return obj;
    if (obj instanceof types.SetThresholdKeyPageOperation) return obj;
    if (obj instanceof types.UpdateAllowedKeyPageOperation) return obj;
    if (obj instanceof types.UpdateKeyOperation) return obj;

    switch (obj.type) {
      case (types.KeyPageOperationType.Add, "add"):
        return new types.AddKeyOperation(obj);
      case (types.KeyPageOperationType.Remove, "remove"):
        return new types.RemoveKeyOperation(obj);
      case (types.KeyPageOperationType.SetThreshold, "setThreshold"):
        return new types.SetThresholdKeyPageOperation(obj);
      case (types.KeyPageOperationType.UpdateAllowed, "updateAllowed"):
        return new types.UpdateAllowedKeyPageOperation(obj);
      case (types.KeyPageOperationType.Update, "update"):
        return new types.UpdateKeyOperation(obj);
    }

    throw new Error(`Unknown key page operation '${obj.type}'`);
  }
}

export type Signature =
  | types.BTCLegacySignature
  | types.BTCSignature
  | types.DelegatedSignature
  | types.ED25519Signature
  | types.ETHSignature
  | types.InternalSignature
  | types.LegacyED25519Signature
  | types.PartitionSignature
  | types.RCD1Signature
  | types.ReceiptSignature
  | types.RemoteSignature
  | types.SignatureSet;

export namespace Signature {
  export type Args =
    | types.BTCLegacySignature
    | types.BTCLegacySignature.ArgsWithType
    | types.BTCSignature
    | types.BTCSignature.ArgsWithType
    | types.DelegatedSignature
    | types.DelegatedSignature.ArgsWithType
    | types.ED25519Signature
    | types.ED25519Signature.ArgsWithType
    | types.ETHSignature
    | types.ETHSignature.ArgsWithType
    | types.InternalSignature
    | types.InternalSignature.ArgsWithType
    | types.LegacyED25519Signature
    | types.LegacyED25519Signature.ArgsWithType
    | types.PartitionSignature
    | types.PartitionSignature.ArgsWithType
    | types.RCD1Signature
    | types.RCD1Signature.ArgsWithType
    | types.ReceiptSignature
    | types.ReceiptSignature.ArgsWithType
    | types.RemoteSignature
    | types.RemoteSignature.ArgsWithType
    | types.SignatureSet
    | types.SignatureSet.ArgsWithType;

  export function fromObject(obj: Args): Signature {
    if (obj instanceof types.BTCLegacySignature) return obj;
    if (obj instanceof types.BTCSignature) return obj;
    if (obj instanceof types.DelegatedSignature) return obj;
    if (obj instanceof types.ED25519Signature) return obj;
    if (obj instanceof types.ETHSignature) return obj;
    if (obj instanceof types.InternalSignature) return obj;
    if (obj instanceof types.LegacyED25519Signature) return obj;
    if (obj instanceof types.PartitionSignature) return obj;
    if (obj instanceof types.RCD1Signature) return obj;
    if (obj instanceof types.ReceiptSignature) return obj;
    if (obj instanceof types.RemoteSignature) return obj;
    if (obj instanceof types.SignatureSet) return obj;

    switch (obj.type) {
      case (types.SignatureType.BTCLegacy, "btclegacy"):
        return new types.BTCLegacySignature(obj);
      case (types.SignatureType.BTC, "btc"):
        return new types.BTCSignature(obj);
      case (types.SignatureType.Delegated, "delegated"):
        return new types.DelegatedSignature(obj);
      case (types.SignatureType.ED25519, "ed25519"):
        return new types.ED25519Signature(obj);
      case (types.SignatureType.ETH, "eth"):
        return new types.ETHSignature(obj);
      case (types.SignatureType.Internal, "internal"):
        return new types.InternalSignature(obj);
      case (types.SignatureType.LegacyED25519, "legacyED25519"):
        return new types.LegacyED25519Signature(obj);
      case (types.SignatureType.Partition, "partition"):
        return new types.PartitionSignature(obj);
      case (types.SignatureType.RCD1, "rcd1"):
        return new types.RCD1Signature(obj);
      case (types.SignatureType.Receipt, "receipt"):
        return new types.ReceiptSignature(obj);
      case (types.SignatureType.Remote, "remote"):
        return new types.RemoteSignature(obj);
      case (types.SignatureType.Set, "set"):
        return new types.SignatureSet(obj);
    }

    throw new Error(`Unknown signature '${obj.type}'`);
  }
}
