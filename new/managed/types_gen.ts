import { ChainType } from ".";
import { encodeAs } from "../encoding";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */

export namespace MerkleState {
  export type Args = {
    count?: number;
    pending?: (Uint8Array | string)[];
    hashList?: (Uint8Array | string)[];
  };
}
export class MerkleState {
  @encodeAs.field(1).uint
  public count?: number;
  @encodeAs.field(2).repeatable.bytes
  public pending?: Uint8Array[];
  @encodeAs.field(3).repeatable.bytes
  public hashList?: Uint8Array[];

  constructor(args: MerkleState.Args) {
    this.count = args.count == undefined ? undefined : args.count;
    this.pending =
      args.pending == undefined
        ? undefined
        : args.pending.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
    this.hashList =
      args.hashList == undefined
        ? undefined
        : args.hashList.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
  }

  asObject(): MerkleState.Args {
    return {
      count: this.count && this.count,
      pending: this.pending && this.pending?.map((v) => Buffer.from(v).toString("hex")),
      hashList: this.hashList && this.hashList?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export namespace Receipt {
  export type Args = {
    start?: Uint8Array | string;
    startIndex?: number;
    end?: Uint8Array | string;
    endIndex?: number;
    anchor?: Uint8Array | string;
    entries?: (ReceiptEntry | ReceiptEntry.Args)[];
  };
}
export class Receipt {
  @encodeAs.field(1).bytes
  public start?: Uint8Array;
  @encodeAs.field(2).int
  public startIndex?: number;
  @encodeAs.field(3).bytes
  public end?: Uint8Array;
  @encodeAs.field(4).int
  public endIndex?: number;
  @encodeAs.field(5).bytes
  public anchor?: Uint8Array;
  @encodeAs.field(6).repeatable.reference
  public entries?: ReceiptEntry[];

  constructor(args: Receipt.Args) {
    this.start =
      args.start == undefined
        ? undefined
        : args.start instanceof Uint8Array
        ? args.start
        : Buffer.from(args.start, "hex");
    this.startIndex = args.startIndex == undefined ? undefined : args.startIndex;
    this.end =
      args.end == undefined
        ? undefined
        : args.end instanceof Uint8Array
        ? args.end
        : Buffer.from(args.end, "hex");
    this.endIndex = args.endIndex == undefined ? undefined : args.endIndex;
    this.anchor =
      args.anchor == undefined
        ? undefined
        : args.anchor instanceof Uint8Array
        ? args.anchor
        : Buffer.from(args.anchor, "hex");
    this.entries =
      args.entries == undefined
        ? undefined
        : args.entries.map((v) => (v instanceof ReceiptEntry ? v : new ReceiptEntry(v)));
  }

  asObject(): Receipt.Args {
    return {
      start: this.start && Buffer.from(this.start).toString("hex"),
      startIndex: this.startIndex && this.startIndex,
      end: this.end && Buffer.from(this.end).toString("hex"),
      endIndex: this.endIndex && this.endIndex,
      anchor: this.anchor && Buffer.from(this.anchor).toString("hex"),
      entries: this.entries && this.entries?.map((v) => v.asObject()),
    };
  }
}

export namespace ReceiptEntry {
  export type Args = {
    right?: boolean;
    hash?: Uint8Array | string;
  };
}
export class ReceiptEntry {
  @encodeAs.field(1).bool
  public right?: boolean;
  @encodeAs.field(2).bytes
  public hash?: Uint8Array;

  constructor(args: ReceiptEntry.Args) {
    this.right = args.right == undefined ? undefined : args.right;
    this.hash =
      args.hash == undefined
        ? undefined
        : args.hash instanceof Uint8Array
        ? args.hash
        : Buffer.from(args.hash, "hex");
  }

  asObject(): ReceiptEntry.Args {
    return {
      right: this.right && this.right,
      hash: this.hash && Buffer.from(this.hash).toString("hex"),
    };
  }
}

export namespace ReceiptList {
  export type Args = {
    merkleState?: MerkleState | MerkleState.Args;
    elements?: (Uint8Array | string)[];
    receipt?: Receipt | Receipt.Args;
    continuedReceipt?: Receipt | Receipt.Args;
  };
}
export class ReceiptList {
  @encodeAs.field(1).reference
  public merkleState?: MerkleState;
  @encodeAs.field(2).repeatable.bytes
  public elements?: Uint8Array[];
  @encodeAs.field(3).reference
  public receipt?: Receipt;
  @encodeAs.field(4).reference
  public continuedReceipt?: Receipt;

  constructor(args: ReceiptList.Args) {
    this.merkleState =
      args.merkleState == undefined
        ? undefined
        : args.merkleState instanceof MerkleState
        ? args.merkleState
        : new MerkleState(args.merkleState);
    this.elements =
      args.elements == undefined
        ? undefined
        : args.elements.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
    this.receipt =
      args.receipt == undefined
        ? undefined
        : args.receipt instanceof Receipt
        ? args.receipt
        : new Receipt(args.receipt);
    this.continuedReceipt =
      args.continuedReceipt == undefined
        ? undefined
        : args.continuedReceipt instanceof Receipt
        ? args.continuedReceipt
        : new Receipt(args.continuedReceipt);
  }

  asObject(): ReceiptList.Args {
    return {
      merkleState: this.merkleState && this.merkleState.asObject(),
      elements: this.elements && this.elements?.map((v) => Buffer.from(v).toString("hex")),
      receipt: this.receipt && this.receipt.asObject(),
      continuedReceipt: this.continuedReceipt && this.continuedReceipt.asObject(),
    };
  }
}

export namespace Snapshot {
  export type Args = {
    name?: string;
    type?: ChainType.Args;
    markPower?: number;
    head?: MerkleState | MerkleState.Args;
    markPoints?: (MerkleState | MerkleState.Args)[];
  };
}
export class Snapshot {
  @encodeAs.field(1).string
  public name?: string;
  @encodeAs.field(2).enum
  public type?: ChainType;
  @encodeAs.field(3).uint
  public markPower?: number;
  @encodeAs.field(4).reference
  public head?: MerkleState;
  @encodeAs.field(5).repeatable.reference
  public markPoints?: MerkleState[];

  constructor(args: Snapshot.Args) {
    this.name = args.name == undefined ? undefined : args.name;
    this.type = args.type == undefined ? undefined : ChainType.fromObject(args.type);
    this.markPower = args.markPower == undefined ? undefined : args.markPower;
    this.head =
      args.head == undefined
        ? undefined
        : args.head instanceof MerkleState
        ? args.head
        : new MerkleState(args.head);
    this.markPoints =
      args.markPoints == undefined
        ? undefined
        : args.markPoints.map((v) => (v instanceof MerkleState ? v : new MerkleState(v)));
  }

  asObject(): Snapshot.Args {
    return {
      name: this.name && this.name,
      type: this.type && this.type.toString(),
      markPower: this.markPower && this.markPower,
      head: this.head && this.head.asObject(),
      markPoints: this.markPoints && this.markPoints?.map((v) => v.asObject()),
    };
  }
}
