import { ChainType } from ".";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */

export namespace MerkleState {
  export type Args = {
    count: number;
    pending: (Uint8Array | string)[];
    hashList: (Uint8Array | string)[];
  };
}
export class MerkleState {
  public count: number;
  public pending: Uint8Array[];
  public hashList: Uint8Array[];

  constructor(args: MerkleState.Args) {
    this.count = args.count;
    this.pending = args.pending.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
    this.hashList = args.hashList.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
  }

  asObject() {
    return {
      count: this.count,
      pending: this.pending?.map((v) => Buffer.from(v).toString("hex")),
      hashList: this.hashList?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export namespace Receipt {
  export type Args = {
    start: Uint8Array | string;
    startIndex: number;
    end: Uint8Array | string;
    endIndex: number;
    anchor: Uint8Array | string;
    entries: (ReceiptEntry | ReceiptEntry.Args)[];
  };
}
export class Receipt {
  public start: Uint8Array;
  public startIndex: number;
  public end: Uint8Array;
  public endIndex: number;
  public anchor: Uint8Array;
  public entries: ReceiptEntry[];

  constructor(args: Receipt.Args) {
    this.start = args.start instanceof Uint8Array ? args.start : Buffer.from(args.start, "hex");
    this.startIndex = args.startIndex;
    this.end = args.end instanceof Uint8Array ? args.end : Buffer.from(args.end, "hex");
    this.endIndex = args.endIndex;
    this.anchor = args.anchor instanceof Uint8Array ? args.anchor : Buffer.from(args.anchor, "hex");
    this.entries = args.entries.map((v) => (v instanceof ReceiptEntry ? v : new ReceiptEntry(v)));
  }

  asObject() {
    return {
      start: Buffer.from(this.start).toString("hex"),
      startIndex: this.startIndex,
      end: Buffer.from(this.end).toString("hex"),
      endIndex: this.endIndex,
      anchor: Buffer.from(this.anchor).toString("hex"),
      entries: this.entries?.map((v) => v.asObject()),
    };
  }
}

export namespace ReceiptEntry {
  export type Args = {
    right: boolean;
    hash: Uint8Array | string;
  };
}
export class ReceiptEntry {
  public right: boolean;
  public hash: Uint8Array;

  constructor(args: ReceiptEntry.Args) {
    this.right = args.right;
    this.hash = args.hash instanceof Uint8Array ? args.hash : Buffer.from(args.hash, "hex");
  }

  asObject() {
    return {
      right: this.right,
      hash: Buffer.from(this.hash).toString("hex"),
    };
  }
}

export namespace ReceiptList {
  export type Args = {
    merkleState: MerkleState | MerkleState.Args;
    elements: (Uint8Array | string)[];
    receipt: Receipt | Receipt.Args;
    continuedReceipt: Receipt | Receipt.Args;
  };
}
export class ReceiptList {
  public merkleState: MerkleState;
  public elements: Uint8Array[];
  public receipt: Receipt;
  public continuedReceipt: Receipt;

  constructor(args: ReceiptList.Args) {
    this.merkleState =
      args.merkleState instanceof MerkleState
        ? args.merkleState
        : new MerkleState(args.merkleState);
    this.elements = args.elements.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
    this.receipt = args.receipt instanceof Receipt ? args.receipt : new Receipt(args.receipt);
    this.continuedReceipt =
      args.continuedReceipt instanceof Receipt
        ? args.continuedReceipt
        : new Receipt(args.continuedReceipt);
  }

  asObject() {
    return {
      merkleState: this.merkleState.asObject(),
      elements: this.elements?.map((v) => Buffer.from(v).toString("hex")),
      receipt: this.receipt.asObject(),
      continuedReceipt: this.continuedReceipt.asObject(),
    };
  }
}

export namespace Snapshot {
  export type Args = {
    name: string;
    type: ChainType.Args;
    markPower: number;
    head: MerkleState | MerkleState.Args;
    markPoints: (MerkleState | MerkleState.Args)[];
  };
}
export class Snapshot {
  public name: string;
  public type: ChainType;
  public markPower: number;
  public head: MerkleState;
  public markPoints: MerkleState[];

  constructor(args: Snapshot.Args) {
    this.name = args.name;
    this.type = ChainType.fromObject(args.type);
    this.markPower = args.markPower;
    this.head = args.head instanceof MerkleState ? args.head : new MerkleState(args.head);
    this.markPoints = args.markPoints.map((v) =>
      v instanceof MerkleState ? v : new MerkleState(v)
    );
  }

  asObject() {
    return {
      name: this.name,
      type: this.type.toString(),
      markPower: this.markPower,
      head: this.head.asObject(),
      markPoints: this.markPoints?.map((v) => v.asObject()),
    };
  }
}
