import { encodeAs } from "../encoding";
import { NodeType } from "./config";
import * as protocol from "./protocol";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */

export namespace Describe {
  export type Args = {
    networkType?: protocol.PartitionType.Args;
    partitionId?: string;
    localAddress?: string;
    network?: Network | Network.Args;
  };
}
export class Describe {
  @encodeAs.field(1).enum
  public networkType?: protocol.PartitionType;
  @encodeAs.field(2).string
  public partitionId?: string;
  @encodeAs.field(3).string
  public localAddress?: string;
  @encodeAs.field(4).reference
  public network?: Network;

  constructor(args: Describe.Args) {
    this.networkType =
      args.networkType == undefined
        ? undefined
        : protocol.PartitionType.fromObject(args.networkType);
    this.partitionId = args.partitionId == undefined ? undefined : args.partitionId;
    this.localAddress = args.localAddress == undefined ? undefined : args.localAddress;
    this.network =
      args.network == undefined
        ? undefined
        : args.network instanceof Network
        ? args.network
        : new Network(args.network);
  }

  copy() {
    return new Describe(this.asObject());
  }

  asObject(): Describe.Args {
    return {
      networkType: this.networkType && protocol.PartitionType.getName(this.networkType),
      partitionId: this.partitionId && this.partitionId,
      localAddress: this.localAddress && this.localAddress,
      network: this.network && this.network.asObject(),
    };
  }
}

export namespace Network {
  export type Args = {
    id?: string;
    partitions?: (Partition | Partition.Args)[];
  };
}
export class Network {
  @encodeAs.field(1).string
  public id?: string;
  @encodeAs.field(2).repeatable.reference
  public partitions?: Partition[];

  constructor(args: Network.Args) {
    this.id = args.id == undefined ? undefined : args.id;
    this.partitions =
      args.partitions == undefined
        ? undefined
        : args.partitions.map((v) => (v instanceof Partition ? v : new Partition(v)));
  }

  copy() {
    return new Network(this.asObject());
  }

  asObject(): Network.Args {
    return {
      id: this.id && this.id,
      partitions: this.partitions && this.partitions?.map((v) => v.asObject()),
    };
  }
}

export namespace Node {
  export type Args = {
    address?: string;
    type?: NodeType.Args;
  };
}
export class Node {
  @encodeAs.field(1).string
  public address?: string;
  @encodeAs.field(2).enum
  public type?: NodeType;

  constructor(args: Node.Args) {
    this.address = args.address == undefined ? undefined : args.address;
    this.type = args.type == undefined ? undefined : NodeType.fromObject(args.type);
  }

  copy() {
    return new Node(this.asObject());
  }

  asObject(): Node.Args {
    return {
      address: this.address && this.address,
      type: this.type && NodeType.getName(this.type),
    };
  }
}

export namespace Partition {
  export type Args = {
    id?: string;
    type?: protocol.PartitionType.Args;
    basePort?: number;
    nodes?: (Node | Node.Args)[];
  };
}
export class Partition {
  @encodeAs.field(1).string
  public id?: string;
  @encodeAs.field(2).enum
  public type?: protocol.PartitionType;
  @encodeAs.field(3).int
  public basePort?: number;
  @encodeAs.field(4).repeatable.reference
  public nodes?: Node[];

  constructor(args: Partition.Args) {
    this.id = args.id == undefined ? undefined : args.id;
    this.type = args.type == undefined ? undefined : protocol.PartitionType.fromObject(args.type);
    this.basePort = args.basePort == undefined ? undefined : args.basePort;
    this.nodes =
      args.nodes == undefined
        ? undefined
        : args.nodes.map((v) => (v instanceof Node ? v : new Node(v)));
  }

  copy() {
    return new Partition(this.asObject());
  }

  asObject(): Partition.Args {
    return {
      id: this.id && this.id,
      type: this.type && protocol.PartitionType.getName(this.type),
      basePort: this.basePort && this.basePort,
      nodes: this.nodes && this.nodes?.map((v) => v.asObject()),
    };
  }
}
