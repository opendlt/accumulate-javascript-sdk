import { encodeAs } from "../encoding";
import { NodeType, NodeTypeArgs } from "./config";
import * as protocol from "./protocol";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */

export type DescribeArgs = {
  networkType?: protocol.PartitionTypeArgs;
  partitionId?: string;
  network?: Network | NetworkArgs;
};
export class Describe {
  @encodeAs.field(1).enum
  public networkType?: protocol.PartitionType;
  @encodeAs.field(2).string
  public partitionId?: string;
  @encodeAs.field(3).reference
  public network?: Network;

  constructor(args: DescribeArgs) {
    this.networkType =
      args.networkType == undefined
        ? undefined
        : protocol.PartitionType.fromObject(args.networkType);
    this.partitionId = args.partitionId == undefined ? undefined : args.partitionId;
    this.network =
      args.network == undefined
        ? undefined
        : args.network instanceof Network
        ? args.network
        : new Network(args.network);
  }

  copy() {
    return new Describe(this.asObject());
  }

  asObject(): DescribeArgs {
    return {
      networkType: this.networkType && protocol.PartitionType.getName(this.networkType),
      partitionId: this.partitionId && this.partitionId,
      network: this.network && this.network.asObject(),
    };
  }
}

export type NetworkArgs = {
  id?: string;
};
export class Network {
  @encodeAs.field(1).string
  public id?: string;

  constructor(args: NetworkArgs) {
    this.id = args.id == undefined ? undefined : args.id;
  }

  copy() {
    return new Network(this.asObject());
  }

  asObject(): NetworkArgs {
    return {
      id: this.id && this.id,
    };
  }
}

export type NodeArgs = {
  address?: string;
  type?: NodeTypeArgs;
};
export class Node {
  @encodeAs.field(1).string
  public address?: string;
  @encodeAs.field(2).enum
  public type?: NodeType;

  constructor(args: NodeArgs) {
    this.address = args.address == undefined ? undefined : args.address;
    this.type = args.type == undefined ? undefined : NodeType.fromObject(args.type);
  }

  copy() {
    return new Node(this.asObject());
  }

  asObject(): NodeArgs {
    return {
      address: this.address && this.address,
      type: this.type && NodeType.getName(this.type),
    };
  }
}

export type PartitionArgs = {
  id?: string;
  type?: protocol.PartitionTypeArgs;
  basePort?: number;
  nodes?: (Node | NodeArgs)[];
};
export class Partition {
  @encodeAs.field(1).string
  public id?: string;
  @encodeAs.field(2).enum
  public type?: protocol.PartitionType;
  @encodeAs.field(3).int
  public basePort?: number;
  @encodeAs.field(4).repeatable.reference
  public nodes?: Node[];

  constructor(args: PartitionArgs) {
    this.id = args.id == undefined ? undefined : args.id;
    this.type = args.type == undefined ? undefined : protocol.PartitionType.fromObject(args.type);
    this.basePort = args.basePort == undefined ? undefined : args.basePort;
    this.nodes =
      args.nodes == undefined
        ? undefined
        : args.nodes.map((v) => (v instanceof Node ? v : new Node(v)));
  }

  copy() {
    return new Partition(this.asObject());
  }

  asObject(): PartitionArgs {
    return {
      id: this.id && this.id,
      type: this.type && protocol.PartitionType.getName(this.type),
      basePort: this.basePort && this.basePort,
      nodes: this.nodes && this.nodes?.map((v) => v.asObject()),
    };
  }
}
