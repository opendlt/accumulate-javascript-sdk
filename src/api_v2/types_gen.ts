import BN from "bn.js";
import { BlockFilterMode, BlockFilterModeArgs, TxFetchMode, TxFetchModeArgs } from ".";
import { AccumulateTxID as TxID, TxIDArgs } from "../address/txid";
import { AccumulateURL as URL, URLArgs } from "../address/url";
import { encodeAs } from "../encoding";
import * as errors2 from "../errors";
import * as merkle from "../merkle";
import * as messaging from "../messaging";
import * as core from "../network";
import * as config from "./config";
import * as protocol from "./protocol";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */

export type ChainEntryArgs = {
  height?: number;
  entry?: Uint8Array | string;
  state?: (Uint8Array | string)[];
  value?: any;
};
export class ChainEntry {
  public height?: number;
  public entry?: Uint8Array;
  public state?: Uint8Array[];
  public value?: any;

  constructor(args: ChainEntryArgs) {
    this.height = args.height == undefined ? undefined : args.height;
    this.entry =
      args.entry == undefined
        ? undefined
        : args.entry instanceof Uint8Array
        ? args.entry
        : Buffer.from(args.entry, "hex");
    this.state =
      args.state == undefined
        ? undefined
        : args.state.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
    this.value = args.value == undefined ? undefined : args.value;
  }

  copy() {
    return new ChainEntry(this.asObject());
  }

  asObject(): ChainEntryArgs {
    return {
      height: this.height && this.height,
      entry: this.entry && Buffer.from(this.entry).toString("hex"),
      state: this.state && this.state?.map((v) => Buffer.from(v).toString("hex")),
      value: this.value && this.value,
    };
  }
}

export type ChainIdQueryArgs = {
  chainId?: Uint8Array | string;
};
export class ChainIdQuery {
  public chainId?: Uint8Array;

  constructor(args: ChainIdQueryArgs) {
    this.chainId =
      args.chainId == undefined
        ? undefined
        : args.chainId instanceof Uint8Array
        ? args.chainId
        : Buffer.from(args.chainId, "hex");
  }

  copy() {
    return new ChainIdQuery(this.asObject());
  }

  asObject(): ChainIdQueryArgs {
    return {
      chainId: this.chainId && Buffer.from(this.chainId).toString("hex"),
    };
  }
}

export type ChainQueryResponseArgs = {
  type?: string;
  mainChain?: MerkleState | MerkleStateArgs;
  chains?: (ChainState | ChainStateArgs)[];
  data?: any;
  chainId?: Uint8Array | string;
  receipt?: GeneralReceipt | GeneralReceiptArgs;
};
export class ChainQueryResponse {
  public type?: string;
  public mainChain?: MerkleState;
  public chains?: ChainState[];
  public data?: any;
  public chainId?: Uint8Array;
  public receipt?: GeneralReceipt;

  constructor(args: ChainQueryResponseArgs) {
    this.type = args.type == undefined ? undefined : args.type;
    this.mainChain =
      args.mainChain == undefined
        ? undefined
        : args.mainChain instanceof MerkleState
        ? args.mainChain
        : new MerkleState(args.mainChain);
    this.chains =
      args.chains == undefined
        ? undefined
        : args.chains.map((v) => (v instanceof ChainState ? v : new ChainState(v)));
    this.data = args.data == undefined ? undefined : args.data;
    this.chainId =
      args.chainId == undefined
        ? undefined
        : args.chainId instanceof Uint8Array
        ? args.chainId
        : Buffer.from(args.chainId, "hex");
    this.receipt =
      args.receipt == undefined
        ? undefined
        : args.receipt instanceof GeneralReceipt
        ? args.receipt
        : new GeneralReceipt(args.receipt);
  }

  copy() {
    return new ChainQueryResponse(this.asObject());
  }

  asObject(): ChainQueryResponseArgs {
    return {
      type: this.type && this.type,
      mainChain: this.mainChain && this.mainChain.asObject(),
      chains: this.chains && this.chains?.map((v) => v.asObject()),
      data: this.data && this.data,
      chainId: this.chainId && Buffer.from(this.chainId).toString("hex"),
      receipt: this.receipt && this.receipt.asObject(),
    };
  }
}

export type ChainStateArgs = {
  name?: string;
  type?: protocol.ChainTypeArgs;
  height?: number;
  roots?: (Uint8Array | string)[];
};
export class ChainState {
  @encodeAs.field(1).string
  public name?: string;
  @encodeAs.field(2).enum
  public type?: protocol.ChainType;
  @encodeAs.field(3).uint
  public height?: number;
  @encodeAs.field(4).repeatable.bytes
  public roots?: Uint8Array[];

  constructor(args: ChainStateArgs) {
    this.name = args.name == undefined ? undefined : args.name;
    this.type = args.type == undefined ? undefined : protocol.ChainType.fromObject(args.type);
    this.height = args.height == undefined ? undefined : args.height;
    this.roots =
      args.roots == undefined
        ? undefined
        : args.roots.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
  }

  copy() {
    return new ChainState(this.asObject());
  }

  asObject(): ChainStateArgs {
    return {
      name: this.name && this.name,
      type: this.type && protocol.ChainType.getName(this.type),
      height: this.height && this.height,
      roots: this.roots && this.roots?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export type DataEntryQueryArgs = {
  url?: URLArgs;
  entryHash?: Uint8Array | string;
};
export class DataEntryQuery {
  @encodeAs.field(1).url
  public url?: URL;
  @encodeAs.field(2).hash
  public entryHash?: Uint8Array;

  constructor(args: DataEntryQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.entryHash =
      args.entryHash == undefined
        ? undefined
        : args.entryHash instanceof Uint8Array
        ? args.entryHash
        : Buffer.from(args.entryHash, "hex");
  }

  copy() {
    return new DataEntryQuery(this.asObject());
  }

  asObject(): DataEntryQueryArgs {
    return {
      url: this.url && this.url.toString(),
      entryHash: this.entryHash && Buffer.from(this.entryHash).toString("hex"),
    };
  }
}

export type DataEntryQueryResponseArgs = {
  entryHash?: Uint8Array | string;
  entry?: protocol.DataEntry | protocol.DataEntryArgs;
  txId?: TxIDArgs;
  causeTxId?: TxIDArgs;
};
export class DataEntryQueryResponse {
  @encodeAs.field(1).hash
  public entryHash?: Uint8Array;
  @encodeAs.field(2).union
  public entry?: protocol.DataEntry;
  @encodeAs.field(3).txid
  public txId?: TxID;
  @encodeAs.field(4).txid
  public causeTxId?: TxID;

  constructor(args: DataEntryQueryResponseArgs) {
    this.entryHash =
      args.entryHash == undefined
        ? undefined
        : args.entryHash instanceof Uint8Array
        ? args.entryHash
        : Buffer.from(args.entryHash, "hex");
    this.entry = args.entry == undefined ? undefined : protocol.DataEntry.fromObject(args.entry);
    this.txId = args.txId == undefined ? undefined : TxID.parse(args.txId);
    this.causeTxId = args.causeTxId == undefined ? undefined : TxID.parse(args.causeTxId);
  }

  copy() {
    return new DataEntryQueryResponse(this.asObject());
  }

  asObject(): DataEntryQueryResponseArgs {
    return {
      entryHash: this.entryHash && Buffer.from(this.entryHash).toString("hex"),
      entry: this.entry && this.entry.asObject(),
      txId: this.txId && this.txId.toString(),
      causeTxId: this.causeTxId && this.causeTxId.toString(),
    };
  }
}

export type DataEntrySetQueryArgs = {
  url?: URLArgs;
  start?: number;
  count?: number;
  expand?: boolean;
  height?: number;
  scratch?: boolean;
  prove?: boolean;
  includeRemote?: boolean;
};
export class DataEntrySetQuery {
  public url?: URL;
  public start?: number;
  public count?: number;
  public expand?: boolean;
  public height?: number;
  public scratch?: boolean;
  public prove?: boolean;
  public includeRemote?: boolean;

  constructor(args: DataEntrySetQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.start = args.start == undefined ? undefined : args.start;
    this.count = args.count == undefined ? undefined : args.count;
    this.expand = args.expand == undefined ? undefined : args.expand;
    this.height = args.height == undefined ? undefined : args.height;
    this.scratch = args.scratch == undefined ? undefined : args.scratch;
    this.prove = args.prove == undefined ? undefined : args.prove;
    this.includeRemote = args.includeRemote == undefined ? undefined : args.includeRemote;
  }

  copy() {
    return new DataEntrySetQuery(this.asObject());
  }

  asObject(): DataEntrySetQueryArgs {
    return {
      url: this.url && this.url.toString(),
      start: this.start && this.start,
      count: this.count && this.count,
      expand: this.expand && this.expand,
      height: this.height && this.height,
      scratch: this.scratch && this.scratch,
      prove: this.prove && this.prove,
      includeRemote: this.includeRemote && this.includeRemote,
    };
  }
}

export type DescriptionResponseArgs = {
  partitionId?: string;
  networkType?: protocol.PartitionTypeArgs;
  network?: config.Network | config.NetworkArgs;
  networkAnchor?: Uint8Array | string;
  values?: core.GlobalValues | core.GlobalValuesArgs;
  error?: errors2.Error | errors2.ErrorArgs;
};
export class DescriptionResponse {
  public partitionId?: string;
  public networkType?: protocol.PartitionType;
  public network?: config.Network;
  public networkAnchor?: Uint8Array;
  public values?: core.GlobalValues;
  public error?: errors2.Error;

  constructor(args: DescriptionResponseArgs) {
    this.partitionId = args.partitionId == undefined ? undefined : args.partitionId;
    this.networkType =
      args.networkType == undefined
        ? undefined
        : protocol.PartitionType.fromObject(args.networkType);
    this.network =
      args.network == undefined
        ? undefined
        : args.network instanceof config.Network
        ? args.network
        : new config.Network(args.network);
    this.networkAnchor =
      args.networkAnchor == undefined
        ? undefined
        : args.networkAnchor instanceof Uint8Array
        ? args.networkAnchor
        : Buffer.from(args.networkAnchor, "hex");
    this.values =
      args.values == undefined
        ? undefined
        : args.values instanceof core.GlobalValues
        ? args.values
        : new core.GlobalValues(args.values);
    this.error =
      args.error == undefined
        ? undefined
        : args.error instanceof errors2.Error
        ? args.error
        : new errors2.Error(args.error);
  }

  copy() {
    return new DescriptionResponse(this.asObject());
  }

  asObject(): DescriptionResponseArgs {
    return {
      partitionId: this.partitionId && this.partitionId,
      networkType: this.networkType && protocol.PartitionType.getName(this.networkType),
      network: this.network && this.network.asObject(),
      networkAnchor: this.networkAnchor && Buffer.from(this.networkAnchor).toString("hex"),
      values: this.values && this.values.asObject(),
      error: this.error && this.error.asObject(),
    };
  }
}

export type DirectoryQueryArgs = {
  url?: URLArgs;
  start?: number;
  count?: number;
  expand?: boolean;
  height?: number;
  scratch?: boolean;
  prove?: boolean;
  includeRemote?: boolean;
};
export class DirectoryQuery {
  public url?: URL;
  public start?: number;
  public count?: number;
  public expand?: boolean;
  public height?: number;
  public scratch?: boolean;
  public prove?: boolean;
  public includeRemote?: boolean;

  constructor(args: DirectoryQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.start = args.start == undefined ? undefined : args.start;
    this.count = args.count == undefined ? undefined : args.count;
    this.expand = args.expand == undefined ? undefined : args.expand;
    this.height = args.height == undefined ? undefined : args.height;
    this.scratch = args.scratch == undefined ? undefined : args.scratch;
    this.prove = args.prove == undefined ? undefined : args.prove;
    this.includeRemote = args.includeRemote == undefined ? undefined : args.includeRemote;
  }

  copy() {
    return new DirectoryQuery(this.asObject());
  }

  asObject(): DirectoryQueryArgs {
    return {
      url: this.url && this.url.toString(),
      start: this.start && this.start,
      count: this.count && this.count,
      expand: this.expand && this.expand,
      height: this.height && this.height,
      scratch: this.scratch && this.scratch,
      prove: this.prove && this.prove,
      includeRemote: this.includeRemote && this.includeRemote,
    };
  }
}

export type ExecuteRequestArgs = {
  envelope?: messaging.Envelope | messaging.EnvelopeArgs;
  checkOnly?: boolean;
};
export class ExecuteRequest {
  public envelope?: messaging.Envelope;
  public checkOnly?: boolean;

  constructor(args: ExecuteRequestArgs) {
    this.envelope =
      args.envelope == undefined
        ? undefined
        : args.envelope instanceof messaging.Envelope
        ? args.envelope
        : new messaging.Envelope(args.envelope);
    this.checkOnly = args.checkOnly == undefined ? undefined : args.checkOnly;
  }

  copy() {
    return new ExecuteRequest(this.asObject());
  }

  asObject(): ExecuteRequestArgs {
    return {
      envelope: this.envelope && this.envelope.asObject(),
      checkOnly: this.checkOnly && this.checkOnly,
    };
  }
}

export type GeneralQueryArgs = {
  url?: URLArgs;
  expand?: boolean;
  height?: number;
  scratch?: boolean;
  prove?: boolean;
  includeRemote?: boolean;
};
export class GeneralQuery {
  public url?: URL;
  public expand?: boolean;
  public height?: number;
  public scratch?: boolean;
  public prove?: boolean;
  public includeRemote?: boolean;

  constructor(args: GeneralQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.expand = args.expand == undefined ? undefined : args.expand;
    this.height = args.height == undefined ? undefined : args.height;
    this.scratch = args.scratch == undefined ? undefined : args.scratch;
    this.prove = args.prove == undefined ? undefined : args.prove;
    this.includeRemote = args.includeRemote == undefined ? undefined : args.includeRemote;
  }

  copy() {
    return new GeneralQuery(this.asObject());
  }

  asObject(): GeneralQueryArgs {
    return {
      url: this.url && this.url.toString(),
      expand: this.expand && this.expand,
      height: this.height && this.height,
      scratch: this.scratch && this.scratch,
      prove: this.prove && this.prove,
      includeRemote: this.includeRemote && this.includeRemote,
    };
  }
}

export type GeneralReceiptArgs = {
  localBlock?: number;
  localBlockTime?: Date | string;
  directoryBlock?: number;
  majorBlock?: number;
  proof?: merkle.Receipt | merkle.ReceiptArgs;
  error?: string;
};
export class GeneralReceipt {
  @encodeAs.field(1).uint
  public localBlock?: number;
  @encodeAs.field(2).time
  public localBlockTime?: Date;
  @encodeAs.field(3).uint
  public directoryBlock?: number;
  @encodeAs.field(4).uint
  public majorBlock?: number;
  @encodeAs.field(5).reference
  public proof?: merkle.Receipt;
  @encodeAs.field(6).string
  public error?: string;

  constructor(args: GeneralReceiptArgs) {
    this.localBlock = args.localBlock == undefined ? undefined : args.localBlock;
    this.localBlockTime =
      args.localBlockTime == undefined
        ? undefined
        : args.localBlockTime instanceof Date
        ? args.localBlockTime
        : new Date(args.localBlockTime);
    this.directoryBlock = args.directoryBlock == undefined ? undefined : args.directoryBlock;
    this.majorBlock = args.majorBlock == undefined ? undefined : args.majorBlock;
    this.proof =
      args.proof == undefined
        ? undefined
        : args.proof instanceof merkle.Receipt
        ? args.proof
        : new merkle.Receipt(args.proof);
    this.error = args.error == undefined ? undefined : args.error;
  }

  copy() {
    return new GeneralReceipt(this.asObject());
  }

  asObject(): GeneralReceiptArgs {
    return {
      localBlock: this.localBlock && this.localBlock,
      localBlockTime: this.localBlockTime && this.localBlockTime,
      directoryBlock: this.directoryBlock && this.directoryBlock,
      majorBlock: this.majorBlock && this.majorBlock,
      proof: this.proof && this.proof.asObject(),
      error: this.error && this.error,
    };
  }
}

export type KeyPageArgs = {
  version?: number;
};
export class KeyPage {
  public version?: number;

  constructor(args: KeyPageArgs) {
    this.version = args.version == undefined ? undefined : args.version;
  }

  copy() {
    return new KeyPage(this.asObject());
  }

  asObject(): KeyPageArgs {
    return {
      version: this.version && this.version,
    };
  }
}

export type KeyPageIndexQueryArgs = {
  url?: URLArgs;
  key?: Uint8Array | string;
};
export class KeyPageIndexQuery {
  public url?: URL;
  public key?: Uint8Array;

  constructor(args: KeyPageIndexQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.key =
      args.key == undefined
        ? undefined
        : args.key instanceof Uint8Array
        ? args.key
        : Buffer.from(args.key, "hex");
  }

  copy() {
    return new KeyPageIndexQuery(this.asObject());
  }

  asObject(): KeyPageIndexQueryArgs {
    return {
      url: this.url && this.url.toString(),
      key: this.key && Buffer.from(this.key).toString("hex"),
    };
  }
}

export type MajorBlocksQueryArgs = {
  url?: URLArgs;
  start?: number;
  count?: number;
};
export class MajorBlocksQuery {
  public url?: URL;
  public start?: number;
  public count?: number;

  constructor(args: MajorBlocksQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.start = args.start == undefined ? undefined : args.start;
    this.count = args.count == undefined ? undefined : args.count;
  }

  copy() {
    return new MajorBlocksQuery(this.asObject());
  }

  asObject(): MajorBlocksQueryArgs {
    return {
      url: this.url && this.url.toString(),
      start: this.start && this.start,
      count: this.count && this.count,
    };
  }
}

export type MajorQueryResponseArgs = {
  majorBlockIndex?: number;
  majorBlockTime?: Date | string;
  minorBlocks?: (MinorBlock | MinorBlockArgs)[];
};
export class MajorQueryResponse {
  public majorBlockIndex?: number;
  public majorBlockTime?: Date;
  public minorBlocks?: MinorBlock[];

  constructor(args: MajorQueryResponseArgs) {
    this.majorBlockIndex = args.majorBlockIndex == undefined ? undefined : args.majorBlockIndex;
    this.majorBlockTime =
      args.majorBlockTime == undefined
        ? undefined
        : args.majorBlockTime instanceof Date
        ? args.majorBlockTime
        : new Date(args.majorBlockTime);
    this.minorBlocks =
      args.minorBlocks == undefined
        ? undefined
        : args.minorBlocks.map((v) => (v instanceof MinorBlock ? v : new MinorBlock(v)));
  }

  copy() {
    return new MajorQueryResponse(this.asObject());
  }

  asObject(): MajorQueryResponseArgs {
    return {
      majorBlockIndex: this.majorBlockIndex && this.majorBlockIndex,
      majorBlockTime: this.majorBlockTime && this.majorBlockTime,
      minorBlocks: this.minorBlocks && this.minorBlocks?.map((v) => v.asObject()),
    };
  }
}

export type MerkleStateArgs = {
  height?: number;
  roots?: (Uint8Array | string)[];
};
export class MerkleState {
  public height?: number;
  public roots?: Uint8Array[];

  constructor(args: MerkleStateArgs) {
    this.height = args.height == undefined ? undefined : args.height;
    this.roots =
      args.roots == undefined
        ? undefined
        : args.roots.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
  }

  copy() {
    return new MerkleState(this.asObject());
  }

  asObject(): MerkleStateArgs {
    return {
      height: this.height && this.height,
      roots: this.roots && this.roots?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export type MetricsQueryArgs = {
  metric?: string;
  duration?: number;
};
export class MetricsQuery {
  public metric?: string;
  public duration?: number;

  constructor(args: MetricsQueryArgs) {
    this.metric = args.metric == undefined ? undefined : args.metric;
    this.duration = args.duration == undefined ? undefined : args.duration;
  }

  copy() {
    return new MetricsQuery(this.asObject());
  }

  asObject(): MetricsQueryArgs {
    return {
      metric: this.metric && this.metric,
      duration: this.duration && this.duration,
    };
  }
}

export type MetricsResponseArgs = {
  value?: any;
};
export class MetricsResponse {
  public value?: any;

  constructor(args: MetricsResponseArgs) {
    this.value = args.value == undefined ? undefined : args.value;
  }

  copy() {
    return new MetricsResponse(this.asObject());
  }

  asObject(): MetricsResponseArgs {
    return {
      value: this.value && this.value,
    };
  }
}

export type MinorBlockArgs = {
  blockIndex?: number;
  blockTime?: Date | string;
};
export class MinorBlock {
  public blockIndex?: number;
  public blockTime?: Date;

  constructor(args: MinorBlockArgs) {
    this.blockIndex = args.blockIndex == undefined ? undefined : args.blockIndex;
    this.blockTime =
      args.blockTime == undefined
        ? undefined
        : args.blockTime instanceof Date
        ? args.blockTime
        : new Date(args.blockTime);
  }

  copy() {
    return new MinorBlock(this.asObject());
  }

  asObject(): MinorBlockArgs {
    return {
      blockIndex: this.blockIndex && this.blockIndex,
      blockTime: this.blockTime && this.blockTime,
    };
  }
}

export type MinorBlocksQueryArgs = {
  url?: URLArgs;
  start?: number;
  count?: number;
  txFetchMode?: TxFetchModeArgs;
  blockFilterMode?: BlockFilterModeArgs;
};
export class MinorBlocksQuery {
  public url?: URL;
  public start?: number;
  public count?: number;
  public txFetchMode?: TxFetchMode;
  public blockFilterMode?: BlockFilterMode;

  constructor(args: MinorBlocksQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.start = args.start == undefined ? undefined : args.start;
    this.count = args.count == undefined ? undefined : args.count;
    this.txFetchMode =
      args.txFetchMode == undefined ? undefined : TxFetchMode.fromObject(args.txFetchMode);
    this.blockFilterMode =
      args.blockFilterMode == undefined
        ? undefined
        : BlockFilterMode.fromObject(args.blockFilterMode);
  }

  copy() {
    return new MinorBlocksQuery(this.asObject());
  }

  asObject(): MinorBlocksQueryArgs {
    return {
      url: this.url && this.url.toString(),
      start: this.start && this.start,
      count: this.count && this.count,
      txFetchMode: this.txFetchMode && TxFetchMode.getName(this.txFetchMode),
      blockFilterMode: this.blockFilterMode && BlockFilterMode.getName(this.blockFilterMode),
    };
  }
}

export type MinorQueryResponseArgs = {
  blockIndex?: number;
  blockTime?: Date | string;
  txCount?: number;
  txIds?: (Uint8Array | string)[];
  transactions?: (TransactionQueryResponse | TransactionQueryResponseArgs)[];
};
export class MinorQueryResponse {
  public blockIndex?: number;
  public blockTime?: Date;
  public txCount?: number;
  public txIds?: Uint8Array[];
  public transactions?: TransactionQueryResponse[];

  constructor(args: MinorQueryResponseArgs) {
    this.blockIndex = args.blockIndex == undefined ? undefined : args.blockIndex;
    this.blockTime =
      args.blockTime == undefined
        ? undefined
        : args.blockTime instanceof Date
        ? args.blockTime
        : new Date(args.blockTime);
    this.txCount = args.txCount == undefined ? undefined : args.txCount;
    this.txIds =
      args.txIds == undefined
        ? undefined
        : args.txIds.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
    this.transactions =
      args.transactions == undefined
        ? undefined
        : args.transactions.map((v) =>
            v instanceof TransactionQueryResponse ? v : new TransactionQueryResponse(v)
          );
  }

  copy() {
    return new MinorQueryResponse(this.asObject());
  }

  asObject(): MinorQueryResponseArgs {
    return {
      blockIndex: this.blockIndex && this.blockIndex,
      blockTime: this.blockTime && this.blockTime,
      txCount: this.txCount && this.txCount,
      txIds: this.txIds && this.txIds?.map((v) => Buffer.from(v).toString("hex")),
      transactions: this.transactions && this.transactions?.map((v) => v.asObject()),
    };
  }
}

export type MultiResponseArgs = {
  type?: string;
  items?: any[];
  start?: number;
  count?: number;
  total?: number;
  otherItems?: any[];
};
export class MultiResponse {
  public type?: string;
  public items?: any[];
  public start?: number;
  public count?: number;
  public total?: number;
  public otherItems?: any[];

  constructor(args: MultiResponseArgs) {
    this.type = args.type == undefined ? undefined : args.type;
    this.items = args.items == undefined ? undefined : args.items.map((v) => v);
    this.start = args.start == undefined ? undefined : args.start;
    this.count = args.count == undefined ? undefined : args.count;
    this.total = args.total == undefined ? undefined : args.total;
    this.otherItems = args.otherItems == undefined ? undefined : args.otherItems.map((v) => v);
  }

  copy() {
    return new MultiResponse(this.asObject());
  }

  asObject(): MultiResponseArgs {
    return {
      type: this.type && this.type,
      items: this.items && this.items?.map((v) => v),
      start: this.start && this.start,
      count: this.count && this.count,
      total: this.total && this.total,
      otherItems: this.otherItems && this.otherItems?.map((v) => v),
    };
  }
}

export type QueryOptionsArgs = {
  expand?: boolean;
  height?: number;
  scratch?: boolean;
  prove?: boolean;
  includeRemote?: boolean;
};
export class QueryOptions {
  public expand?: boolean;
  public height?: number;
  public scratch?: boolean;
  public prove?: boolean;
  public includeRemote?: boolean;

  constructor(args: QueryOptionsArgs) {
    this.expand = args.expand == undefined ? undefined : args.expand;
    this.height = args.height == undefined ? undefined : args.height;
    this.scratch = args.scratch == undefined ? undefined : args.scratch;
    this.prove = args.prove == undefined ? undefined : args.prove;
    this.includeRemote = args.includeRemote == undefined ? undefined : args.includeRemote;
  }

  copy() {
    return new QueryOptions(this.asObject());
  }

  asObject(): QueryOptionsArgs {
    return {
      expand: this.expand && this.expand,
      height: this.height && this.height,
      scratch: this.scratch && this.scratch,
      prove: this.prove && this.prove,
      includeRemote: this.includeRemote && this.includeRemote,
    };
  }
}

export type QueryPaginationArgs = {
  start?: number;
  count?: number;
};
export class QueryPagination {
  public start?: number;
  public count?: number;

  constructor(args: QueryPaginationArgs) {
    this.start = args.start == undefined ? undefined : args.start;
    this.count = args.count == undefined ? undefined : args.count;
  }

  copy() {
    return new QueryPagination(this.asObject());
  }

  asObject(): QueryPaginationArgs {
    return {
      start: this.start && this.start,
      count: this.count && this.count,
    };
  }
}

export type ResponseDataEntryArgs = {
  entryHash?: Uint8Array | string;
  entry?: protocol.DataEntry | protocol.DataEntryArgs;
  txId?: TxIDArgs;
  causeTxId?: TxIDArgs;
};
export class ResponseDataEntry {
  @encodeAs.field(1).hash
  public entryHash?: Uint8Array;
  @encodeAs.field(2).union
  public entry?: protocol.DataEntry;
  @encodeAs.field(3).txid
  public txId?: TxID;
  @encodeAs.field(4).txid
  public causeTxId?: TxID;

  constructor(args: ResponseDataEntryArgs) {
    this.entryHash =
      args.entryHash == undefined
        ? undefined
        : args.entryHash instanceof Uint8Array
        ? args.entryHash
        : Buffer.from(args.entryHash, "hex");
    this.entry = args.entry == undefined ? undefined : protocol.DataEntry.fromObject(args.entry);
    this.txId = args.txId == undefined ? undefined : TxID.parse(args.txId);
    this.causeTxId = args.causeTxId == undefined ? undefined : TxID.parse(args.causeTxId);
  }

  copy() {
    return new ResponseDataEntry(this.asObject());
  }

  asObject(): ResponseDataEntryArgs {
    return {
      entryHash: this.entryHash && Buffer.from(this.entryHash).toString("hex"),
      entry: this.entry && this.entry.asObject(),
      txId: this.txId && this.txId.toString(),
      causeTxId: this.causeTxId && this.causeTxId.toString(),
    };
  }
}

export type ResponseDataEntrySetArgs = {
  dataEntries?: (ResponseDataEntry | ResponseDataEntryArgs)[];
  total?: number;
};
export class ResponseDataEntrySet {
  @encodeAs.field(1).repeatable.reference
  public dataEntries?: ResponseDataEntry[];
  @encodeAs.field(2).uint
  public total?: number;

  constructor(args: ResponseDataEntrySetArgs) {
    this.dataEntries =
      args.dataEntries == undefined
        ? undefined
        : args.dataEntries.map((v) =>
            v instanceof ResponseDataEntry ? v : new ResponseDataEntry(v)
          );
    this.total = args.total == undefined ? undefined : args.total;
  }

  copy() {
    return new ResponseDataEntrySet(this.asObject());
  }

  asObject(): ResponseDataEntrySetArgs {
    return {
      dataEntries: this.dataEntries && this.dataEntries?.map((v) => v.asObject()),
      total: this.total && this.total,
    };
  }
}

export type ResponseKeyPageIndexArgs = {
  authority?: URLArgs;
  signer?: URLArgs;
  index?: number;
};
export class ResponseKeyPageIndex {
  @encodeAs.field(1).url
  public authority?: URL;
  @encodeAs.field(2).url
  public signer?: URL;
  @encodeAs.field(3).keepEmpty.uint
  public index?: number;

  constructor(args: ResponseKeyPageIndexArgs) {
    this.authority = args.authority == undefined ? undefined : URL.parse(args.authority);
    this.signer = args.signer == undefined ? undefined : URL.parse(args.signer);
    this.index = args.index == undefined ? undefined : args.index;
  }

  copy() {
    return new ResponseKeyPageIndex(this.asObject());
  }

  asObject(): ResponseKeyPageIndexArgs {
    return {
      authority: this.authority && this.authority.toString(),
      signer: this.signer && this.signer.toString(),
      index: this.index && this.index,
    };
  }
}

export type SignatureBookArgs = {
  authority?: URLArgs;
  pages?: (SignaturePage | SignaturePageArgs)[];
};
export class SignatureBook {
  public authority?: URL;
  public pages?: SignaturePage[];

  constructor(args: SignatureBookArgs) {
    this.authority = args.authority == undefined ? undefined : URL.parse(args.authority);
    this.pages =
      args.pages == undefined
        ? undefined
        : args.pages.map((v) => (v instanceof SignaturePage ? v : new SignaturePage(v)));
  }

  copy() {
    return new SignatureBook(this.asObject());
  }

  asObject(): SignatureBookArgs {
    return {
      authority: this.authority && this.authority.toString(),
      pages: this.pages && this.pages?.map((v) => v.asObject()),
    };
  }
}

export type SignaturePageArgs = {
  signer?: SignerMetadata | SignerMetadataArgs;
  signatures?: (protocol.Signature | protocol.SignatureArgs)[];
};
export class SignaturePage {
  public signer?: SignerMetadata;
  public signatures?: protocol.Signature[];

  constructor(args: SignaturePageArgs) {
    this.signer =
      args.signer == undefined
        ? undefined
        : args.signer instanceof SignerMetadata
        ? args.signer
        : new SignerMetadata(args.signer);
    this.signatures =
      args.signatures == undefined
        ? undefined
        : args.signatures.map((v) => protocol.Signature.fromObject(v));
  }

  copy() {
    return new SignaturePage(this.asObject());
  }

  asObject(): SignaturePageArgs {
    return {
      signer: this.signer && this.signer.asObject(),
      signatures: this.signatures && this.signatures?.map((v) => v.asObject()),
    };
  }
}

export type SignerArgs = {
  publicKey?: Uint8Array | string;
  timestamp?: number;
  url?: URLArgs;
  version?: number;
  signatureType?: protocol.SignatureTypeArgs;
  useSimpleHash?: boolean;
};
export class Signer {
  public publicKey?: Uint8Array;
  public timestamp?: number;
  public url?: URL;
  public version?: number;
  public signatureType?: protocol.SignatureType;
  public useSimpleHash?: boolean;

  constructor(args: SignerArgs) {
    this.publicKey =
      args.publicKey == undefined
        ? undefined
        : args.publicKey instanceof Uint8Array
        ? args.publicKey
        : Buffer.from(args.publicKey, "hex");
    this.timestamp = args.timestamp == undefined ? undefined : args.timestamp;
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.version = args.version == undefined ? undefined : args.version;
    this.signatureType =
      args.signatureType == undefined
        ? undefined
        : protocol.SignatureType.fromObject(args.signatureType);
    this.useSimpleHash = args.useSimpleHash == undefined ? undefined : args.useSimpleHash;
  }

  copy() {
    return new Signer(this.asObject());
  }

  asObject(): SignerArgs {
    return {
      publicKey: this.publicKey && Buffer.from(this.publicKey).toString("hex"),
      timestamp: this.timestamp && this.timestamp,
      url: this.url && this.url.toString(),
      version: this.version && this.version,
      signatureType: this.signatureType && protocol.SignatureType.getName(this.signatureType),
      useSimpleHash: this.useSimpleHash && this.useSimpleHash,
    };
  }
}

export type SignerMetadataArgs = {
  type?: protocol.AccountTypeArgs;
  url?: URLArgs;
  acceptThreshold?: number;
};
export class SignerMetadata {
  public type?: protocol.AccountType;
  public url?: URL;
  public acceptThreshold?: number;

  constructor(args: SignerMetadataArgs) {
    this.type = args.type == undefined ? undefined : protocol.AccountType.fromObject(args.type);
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.acceptThreshold = args.acceptThreshold == undefined ? undefined : args.acceptThreshold;
  }

  copy() {
    return new SignerMetadata(this.asObject());
  }

  asObject(): SignerMetadataArgs {
    return {
      type: this.type && protocol.AccountType.getName(this.type),
      url: this.url && this.url.toString(),
      acceptThreshold: this.acceptThreshold && this.acceptThreshold,
    };
  }
}

export type StatusResponseArgs = {
  ok?: boolean;
  bvnHeight?: number;
  dnHeight?: number;
  bvnTime?: Date | string;
  dnTime?: Date | string;
  lastDirectoryAnchorHeight?: number;
  bvnRootHash?: Uint8Array | string;
  dnRootHash?: Uint8Array | string;
  bvnBptHash?: Uint8Array | string;
  dnBptHash?: Uint8Array | string;
};
export class StatusResponse {
  public ok?: boolean;
  public bvnHeight?: number;
  public dnHeight?: number;
  public bvnTime?: Date;
  public dnTime?: Date;
  public lastDirectoryAnchorHeight?: number;
  public bvnRootHash?: Uint8Array;
  public dnRootHash?: Uint8Array;
  public bvnBptHash?: Uint8Array;
  public dnBptHash?: Uint8Array;

  constructor(args: StatusResponseArgs) {
    this.ok = args.ok == undefined ? undefined : args.ok;
    this.bvnHeight = args.bvnHeight == undefined ? undefined : args.bvnHeight;
    this.dnHeight = args.dnHeight == undefined ? undefined : args.dnHeight;
    this.bvnTime =
      args.bvnTime == undefined
        ? undefined
        : args.bvnTime instanceof Date
        ? args.bvnTime
        : new Date(args.bvnTime);
    this.dnTime =
      args.dnTime == undefined
        ? undefined
        : args.dnTime instanceof Date
        ? args.dnTime
        : new Date(args.dnTime);
    this.lastDirectoryAnchorHeight =
      args.lastDirectoryAnchorHeight == undefined ? undefined : args.lastDirectoryAnchorHeight;
    this.bvnRootHash =
      args.bvnRootHash == undefined
        ? undefined
        : args.bvnRootHash instanceof Uint8Array
        ? args.bvnRootHash
        : Buffer.from(args.bvnRootHash, "hex");
    this.dnRootHash =
      args.dnRootHash == undefined
        ? undefined
        : args.dnRootHash instanceof Uint8Array
        ? args.dnRootHash
        : Buffer.from(args.dnRootHash, "hex");
    this.bvnBptHash =
      args.bvnBptHash == undefined
        ? undefined
        : args.bvnBptHash instanceof Uint8Array
        ? args.bvnBptHash
        : Buffer.from(args.bvnBptHash, "hex");
    this.dnBptHash =
      args.dnBptHash == undefined
        ? undefined
        : args.dnBptHash instanceof Uint8Array
        ? args.dnBptHash
        : Buffer.from(args.dnBptHash, "hex");
  }

  copy() {
    return new StatusResponse(this.asObject());
  }

  asObject(): StatusResponseArgs {
    return {
      ok: this.ok && this.ok,
      bvnHeight: this.bvnHeight && this.bvnHeight,
      dnHeight: this.dnHeight && this.dnHeight,
      bvnTime: this.bvnTime && this.bvnTime,
      dnTime: this.dnTime && this.dnTime,
      lastDirectoryAnchorHeight: this.lastDirectoryAnchorHeight && this.lastDirectoryAnchorHeight,
      bvnRootHash: this.bvnRootHash && Buffer.from(this.bvnRootHash).toString("hex"),
      dnRootHash: this.dnRootHash && Buffer.from(this.dnRootHash).toString("hex"),
      bvnBptHash: this.bvnBptHash && Buffer.from(this.bvnBptHash).toString("hex"),
      dnBptHash: this.dnBptHash && Buffer.from(this.dnBptHash).toString("hex"),
    };
  }
}

export type SyntheticTransactionRequestArgs = {
  source?: URLArgs;
  destination?: URLArgs;
  sequenceNumber?: number;
  anchor?: boolean;
};
export class SyntheticTransactionRequest {
  public source?: URL;
  public destination?: URL;
  public sequenceNumber?: number;
  public anchor?: boolean;

  constructor(args: SyntheticTransactionRequestArgs) {
    this.source = args.source == undefined ? undefined : URL.parse(args.source);
    this.destination = args.destination == undefined ? undefined : URL.parse(args.destination);
    this.sequenceNumber = args.sequenceNumber == undefined ? undefined : args.sequenceNumber;
    this.anchor = args.anchor == undefined ? undefined : args.anchor;
  }

  copy() {
    return new SyntheticTransactionRequest(this.asObject());
  }

  asObject(): SyntheticTransactionRequestArgs {
    return {
      source: this.source && this.source.toString(),
      destination: this.destination && this.destination.toString(),
      sequenceNumber: this.sequenceNumber && this.sequenceNumber,
      anchor: this.anchor && this.anchor,
    };
  }
}

export type TokenDepositArgs = {
  url?: URLArgs;
  amount?: BN | string | number;
  txid?: Uint8Array | string;
};
export class TokenDeposit {
  public url?: URL;
  public amount?: BN;
  public txid?: Uint8Array;

  constructor(args: TokenDepositArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.amount =
      args.amount == undefined
        ? undefined
        : args.amount instanceof BN
        ? args.amount
        : new BN(args.amount);
    this.txid =
      args.txid == undefined
        ? undefined
        : args.txid instanceof Uint8Array
        ? args.txid
        : Buffer.from(args.txid, "hex");
  }

  copy() {
    return new TokenDeposit(this.asObject());
  }

  asObject(): TokenDepositArgs {
    return {
      url: this.url && this.url.toString(),
      amount: this.amount && this.amount.toString(),
      txid: this.txid && Buffer.from(this.txid).toString("hex"),
    };
  }
}

export type TokenSendArgs = {
  from?: URLArgs;
  to?: (TokenDeposit | TokenDepositArgs)[];
};
export class TokenSend {
  public from?: URL;
  public to?: TokenDeposit[];

  constructor(args: TokenSendArgs) {
    this.from = args.from == undefined ? undefined : URL.parse(args.from);
    this.to =
      args.to == undefined
        ? undefined
        : args.to.map((v) => (v instanceof TokenDeposit ? v : new TokenDeposit(v)));
  }

  copy() {
    return new TokenSend(this.asObject());
  }

  asObject(): TokenSendArgs {
    return {
      from: this.from && this.from.toString(),
      to: this.to && this.to?.map((v) => v.asObject()),
    };
  }
}

export type TransactionQueryResponseArgs = {
  type?: string;
  mainChain?: MerkleState | MerkleStateArgs;
  data?: any;
  origin?: URLArgs;
  transactionHash?: Uint8Array | string;
  txid?: TxIDArgs;
  transaction?: protocol.Transaction | protocol.TransactionArgs;
  signatures?: (protocol.Signature | protocol.SignatureArgs)[];
  status?: protocol.TransactionStatus | protocol.TransactionStatusArgs;
  produced?: TxIDArgs[];
  receipts?: (TxReceipt | TxReceiptArgs)[];
  signatureBooks?: (SignatureBook | SignatureBookArgs)[];
};
export class TransactionQueryResponse {
  public type?: string;
  public mainChain?: MerkleState;
  public data?: any;
  public origin?: URL;
  public transactionHash?: Uint8Array;
  public txid?: TxID;
  public transaction?: protocol.Transaction;
  public signatures?: protocol.Signature[];
  public status?: protocol.TransactionStatus;
  public produced?: TxID[];
  public receipts?: TxReceipt[];
  public signatureBooks?: SignatureBook[];

  constructor(args: TransactionQueryResponseArgs) {
    this.type = args.type == undefined ? undefined : args.type;
    this.mainChain =
      args.mainChain == undefined
        ? undefined
        : args.mainChain instanceof MerkleState
        ? args.mainChain
        : new MerkleState(args.mainChain);
    this.data = args.data == undefined ? undefined : args.data;
    this.origin = args.origin == undefined ? undefined : URL.parse(args.origin);
    this.transactionHash =
      args.transactionHash == undefined
        ? undefined
        : args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
    this.txid = args.txid == undefined ? undefined : TxID.parse(args.txid);
    this.transaction =
      args.transaction == undefined
        ? undefined
        : args.transaction instanceof protocol.Transaction
        ? args.transaction
        : new protocol.Transaction(args.transaction);
    this.signatures =
      args.signatures == undefined
        ? undefined
        : args.signatures.map((v) => protocol.Signature.fromObject(v));
    this.status =
      args.status == undefined
        ? undefined
        : args.status instanceof protocol.TransactionStatus
        ? args.status
        : new protocol.TransactionStatus(args.status);
    this.produced =
      args.produced == undefined ? undefined : args.produced.map((v) => TxID.parse(v));
    this.receipts =
      args.receipts == undefined
        ? undefined
        : args.receipts.map((v) => (v instanceof TxReceipt ? v : new TxReceipt(v)));
    this.signatureBooks =
      args.signatureBooks == undefined
        ? undefined
        : args.signatureBooks.map((v) => (v instanceof SignatureBook ? v : new SignatureBook(v)));
  }

  copy() {
    return new TransactionQueryResponse(this.asObject());
  }

  asObject(): TransactionQueryResponseArgs {
    return {
      type: this.type && this.type,
      mainChain: this.mainChain && this.mainChain.asObject(),
      data: this.data && this.data,
      origin: this.origin && this.origin.toString(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
      txid: this.txid && this.txid.toString(),
      transaction: this.transaction && this.transaction.asObject(),
      signatures: this.signatures && this.signatures?.map((v) => v.asObject()),
      status: this.status && this.status.asObject(),
      produced: this.produced && this.produced?.map((v) => v.toString()),
      receipts: this.receipts && this.receipts?.map((v) => v.asObject()),
      signatureBooks: this.signatureBooks && this.signatureBooks?.map((v) => v.asObject()),
    };
  }
}

export type TxHistoryQueryArgs = {
  url?: URLArgs;
  start?: number;
  count?: number;
  scratch?: boolean;
};
export class TxHistoryQuery {
  public url?: URL;
  public start?: number;
  public count?: number;
  public scratch?: boolean;

  constructor(args: TxHistoryQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.start = args.start == undefined ? undefined : args.start;
    this.count = args.count == undefined ? undefined : args.count;
    this.scratch = args.scratch == undefined ? undefined : args.scratch;
  }

  copy() {
    return new TxHistoryQuery(this.asObject());
  }

  asObject(): TxHistoryQueryArgs {
    return {
      url: this.url && this.url.toString(),
      start: this.start && this.start,
      count: this.count && this.count,
      scratch: this.scratch && this.scratch,
    };
  }
}

export type TxReceiptArgs = {
  localBlock?: number;
  localBlockTime?: Date | string;
  directoryBlock?: number;
  majorBlock?: number;
  proof?: merkle.Receipt | merkle.ReceiptArgs;
  error?: string;
  account?: URLArgs;
  chain?: string;
};
export class TxReceipt {
  @encodeAs.field(1, 1).uint
  public localBlock?: number;
  @encodeAs.field(1, 2).time
  public localBlockTime?: Date;
  @encodeAs.field(1, 3).uint
  public directoryBlock?: number;
  @encodeAs.field(1, 4).uint
  public majorBlock?: number;
  @encodeAs.field(1, 5).reference
  public proof?: merkle.Receipt;
  @encodeAs.field(1, 6).string
  public error?: string;
  @encodeAs.field(2).url
  public account?: URL;
  @encodeAs.field(3).string
  public chain?: string;

  constructor(args: TxReceiptArgs) {
    this.localBlock = args.localBlock == undefined ? undefined : args.localBlock;
    this.localBlockTime =
      args.localBlockTime == undefined
        ? undefined
        : args.localBlockTime instanceof Date
        ? args.localBlockTime
        : new Date(args.localBlockTime);
    this.directoryBlock = args.directoryBlock == undefined ? undefined : args.directoryBlock;
    this.majorBlock = args.majorBlock == undefined ? undefined : args.majorBlock;
    this.proof =
      args.proof == undefined
        ? undefined
        : args.proof instanceof merkle.Receipt
        ? args.proof
        : new merkle.Receipt(args.proof);
    this.error = args.error == undefined ? undefined : args.error;
    this.account = args.account == undefined ? undefined : URL.parse(args.account);
    this.chain = args.chain == undefined ? undefined : args.chain;
  }

  copy() {
    return new TxReceipt(this.asObject());
  }

  asObject(): TxReceiptArgs {
    return {
      localBlock: this.localBlock && this.localBlock,
      localBlockTime: this.localBlockTime && this.localBlockTime,
      directoryBlock: this.directoryBlock && this.directoryBlock,
      majorBlock: this.majorBlock && this.majorBlock,
      proof: this.proof && this.proof.asObject(),
      error: this.error && this.error,
      account: this.account && this.account.toString(),
      chain: this.chain && this.chain,
    };
  }
}

export type TxRequestArgs = {
  checkOnly?: boolean;
  isEnvelope?: boolean;
  origin?: URLArgs;
  signer?: Signer | SignerArgs;
  signature?: Uint8Array | string;
  keyPage?: KeyPage | KeyPageArgs;
  txHash?: Uint8Array | string;
  payload?: any;
  memo?: string;
  metadata?: Uint8Array | string;
};
export class TxRequest {
  public checkOnly?: boolean;
  public isEnvelope?: boolean;
  public origin?: URL;
  public signer?: Signer;
  public signature?: Uint8Array;
  public keyPage?: KeyPage;
  public txHash?: Uint8Array;
  public payload?: any;
  public memo?: string;
  public metadata?: Uint8Array;

  constructor(args: TxRequestArgs) {
    this.checkOnly = args.checkOnly == undefined ? undefined : args.checkOnly;
    this.isEnvelope = args.isEnvelope == undefined ? undefined : args.isEnvelope;
    this.origin = args.origin == undefined ? undefined : URL.parse(args.origin);
    this.signer =
      args.signer == undefined
        ? undefined
        : args.signer instanceof Signer
        ? args.signer
        : new Signer(args.signer);
    this.signature =
      args.signature == undefined
        ? undefined
        : args.signature instanceof Uint8Array
        ? args.signature
        : Buffer.from(args.signature, "hex");
    this.keyPage =
      args.keyPage == undefined
        ? undefined
        : args.keyPage instanceof KeyPage
        ? args.keyPage
        : new KeyPage(args.keyPage);
    this.txHash =
      args.txHash == undefined
        ? undefined
        : args.txHash instanceof Uint8Array
        ? args.txHash
        : Buffer.from(args.txHash, "hex");
    this.payload = args.payload == undefined ? undefined : args.payload;
    this.memo = args.memo == undefined ? undefined : args.memo;
    this.metadata =
      args.metadata == undefined
        ? undefined
        : args.metadata instanceof Uint8Array
        ? args.metadata
        : Buffer.from(args.metadata, "hex");
  }

  copy() {
    return new TxRequest(this.asObject());
  }

  asObject(): TxRequestArgs {
    return {
      checkOnly: this.checkOnly && this.checkOnly,
      isEnvelope: this.isEnvelope && this.isEnvelope,
      origin: this.origin && this.origin.toString(),
      signer: this.signer && this.signer.asObject(),
      signature: this.signature && Buffer.from(this.signature).toString("hex"),
      keyPage: this.keyPage && this.keyPage.asObject(),
      txHash: this.txHash && Buffer.from(this.txHash).toString("hex"),
      payload: this.payload && this.payload,
      memo: this.memo && this.memo,
      metadata: this.metadata && Buffer.from(this.metadata).toString("hex"),
    };
  }
}

export type TxResponseArgs = {
  transactionHash?: Uint8Array | string;
  txid?: TxIDArgs;
  signatureHashes?: (Uint8Array | string)[];
  simpleHash?: Uint8Array | string;
  code?: number;
  message?: string;
  delivered?: boolean;
  result?: any;
};
export class TxResponse {
  public transactionHash?: Uint8Array;
  public txid?: TxID;
  public signatureHashes?: Uint8Array[];
  public simpleHash?: Uint8Array;
  public code?: number;
  public message?: string;
  public delivered?: boolean;
  public result?: any;

  constructor(args: TxResponseArgs) {
    this.transactionHash =
      args.transactionHash == undefined
        ? undefined
        : args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
    this.txid = args.txid == undefined ? undefined : TxID.parse(args.txid);
    this.signatureHashes =
      args.signatureHashes == undefined
        ? undefined
        : args.signatureHashes.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
    this.simpleHash =
      args.simpleHash == undefined
        ? undefined
        : args.simpleHash instanceof Uint8Array
        ? args.simpleHash
        : Buffer.from(args.simpleHash, "hex");
    this.code = args.code == undefined ? undefined : args.code;
    this.message = args.message == undefined ? undefined : args.message;
    this.delivered = args.delivered == undefined ? undefined : args.delivered;
    this.result = args.result == undefined ? undefined : args.result;
  }

  copy() {
    return new TxResponse(this.asObject());
  }

  asObject(): TxResponseArgs {
    return {
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
      txid: this.txid && this.txid.toString(),
      signatureHashes:
        this.signatureHashes && this.signatureHashes?.map((v) => Buffer.from(v).toString("hex")),
      simpleHash: this.simpleHash && Buffer.from(this.simpleHash).toString("hex"),
      code: this.code && this.code,
      message: this.message && this.message,
      delivered: this.delivered && this.delivered,
      result: this.result && this.result,
    };
  }
}

export type TxnQueryArgs = {
  expand?: boolean;
  height?: number;
  scratch?: boolean;
  prove?: boolean;
  includeRemote?: boolean;
  txid?: Uint8Array | string;
  txIdUrl?: TxIDArgs;
  wait?: number;
  ignorePending?: boolean;
};
export class TxnQuery {
  public expand?: boolean;
  public height?: number;
  public scratch?: boolean;
  public prove?: boolean;
  public includeRemote?: boolean;
  public txid?: Uint8Array;
  public txIdUrl?: TxID;
  public wait?: number;
  public ignorePending?: boolean;

  constructor(args: TxnQueryArgs) {
    this.expand = args.expand == undefined ? undefined : args.expand;
    this.height = args.height == undefined ? undefined : args.height;
    this.scratch = args.scratch == undefined ? undefined : args.scratch;
    this.prove = args.prove == undefined ? undefined : args.prove;
    this.includeRemote = args.includeRemote == undefined ? undefined : args.includeRemote;
    this.txid =
      args.txid == undefined
        ? undefined
        : args.txid instanceof Uint8Array
        ? args.txid
        : Buffer.from(args.txid, "hex");
    this.txIdUrl = args.txIdUrl == undefined ? undefined : TxID.parse(args.txIdUrl);
    this.wait = args.wait == undefined ? undefined : args.wait;
    this.ignorePending = args.ignorePending == undefined ? undefined : args.ignorePending;
  }

  copy() {
    return new TxnQuery(this.asObject());
  }

  asObject(): TxnQueryArgs {
    return {
      expand: this.expand && this.expand,
      height: this.height && this.height,
      scratch: this.scratch && this.scratch,
      prove: this.prove && this.prove,
      includeRemote: this.includeRemote && this.includeRemote,
      txid: this.txid && Buffer.from(this.txid).toString("hex"),
      txIdUrl: this.txIdUrl && this.txIdUrl.toString(),
      wait: this.wait && this.wait,
      ignorePending: this.ignorePending && this.ignorePending,
    };
  }
}

export type UrlQueryArgs = {
  url?: URLArgs;
};
export class UrlQuery {
  public url?: URL;

  constructor(args: UrlQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
  }

  copy() {
    return new UrlQuery(this.asObject());
  }

  asObject(): UrlQueryArgs {
    return {
      url: this.url && this.url.toString(),
    };
  }
}

export type VersionResponseArgs = {
  version?: string;
  commit?: string;
  versionIsKnown?: boolean;
  isTestNet?: boolean;
};
export class VersionResponse {
  public version?: string;
  public commit?: string;
  public versionIsKnown?: boolean;
  public isTestNet?: boolean;

  constructor(args: VersionResponseArgs) {
    this.version = args.version == undefined ? undefined : args.version;
    this.commit = args.commit == undefined ? undefined : args.commit;
    this.versionIsKnown = args.versionIsKnown == undefined ? undefined : args.versionIsKnown;
    this.isTestNet = args.isTestNet == undefined ? undefined : args.isTestNet;
  }

  copy() {
    return new VersionResponse(this.asObject());
  }

  asObject(): VersionResponseArgs {
    return {
      version: this.version && this.version,
      commit: this.commit && this.commit,
      versionIsKnown: this.versionIsKnown && this.versionIsKnown,
      isTestNet: this.isTestNet && this.isTestNet,
    };
  }
}
