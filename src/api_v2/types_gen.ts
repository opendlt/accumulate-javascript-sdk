import { BlockFilterMode, BlockFilterModeArgs, TxFetchMode, TxFetchModeArgs } from ".";
import { AccumulateTxID as TxID, TxIDArgs } from "../address/txid";
import { AccumulateURL as URL, URLArgs } from "../address/url";
import { Buffer } from "../common/buffer";
import { encodeAs } from "../encoding";
import * as errors2 from "../errors";
import * as merkle from "../merkle";
import * as messaging from "../messaging";
import * as core from "../network";
import * as config from "./config";
import * as protocol from "./protocol";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */

export type ChainEntryArgs = {
  height?: number;
  entry?: Uint8Array | string;
  state?: (Uint8Array | string | undefined)[];
  value?: any;
};
export class ChainEntry {
  public height?: number;
  public entry?: Uint8Array;
  public state?: (Uint8Array | undefined)[];
  public value?: any;

  constructor(args: ChainEntryArgs) {
    this.height = args.height == undefined ? undefined : args.height;
    this.entry =
      args.entry == undefined
        ? undefined
        : args.entry instanceof Uint8Array
          ? args.entry
          : Buffer.from(args.entry, "hex");
    this.state =
      args.state == undefined
        ? undefined
        : args.state.map((v) =>
            v == undefined ? undefined : v instanceof Uint8Array ? v : Buffer.from(v, "hex"),
          );
    this.value = args.value == undefined ? undefined : args.value;
  }

  copy() {
    return new ChainEntry(this.asObject());
  }

  asObject(): ChainEntryArgs {
    return {
      height: this.height === undefined ? undefined : this.height,
      entry:
        this.entry === undefined
          ? undefined
          : this.entry && Buffer.from(this.entry).toString("hex"),
      state:
        this.state === undefined
          ? undefined
          : this.state?.map((v) =>
              v == undefined ? undefined : v && Buffer.from(v).toString("hex"),
            ),
      value: this.value === undefined ? undefined : this.value,
    };
  }
}

export type ChainIdQueryArgs = {
  chainId?: Uint8Array | string;
};
export class ChainIdQuery {
  public chainId?: Uint8Array;

  constructor(args: ChainIdQueryArgs) {
    this.chainId =
      args.chainId == undefined
        ? undefined
        : args.chainId instanceof Uint8Array
          ? args.chainId
          : Buffer.from(args.chainId, "hex");
  }

  copy() {
    return new ChainIdQuery(this.asObject());
  }

  asObject(): ChainIdQueryArgs {
    return {
      chainId:
        this.chainId === undefined
          ? undefined
          : this.chainId && Buffer.from(this.chainId).toString("hex"),
    };
  }
}

export type ChainQueryResponseArgs = {
  type?: string;
  mainChain?: MerkleState | MerkleStateArgs;
  chains?: (ChainState | ChainStateArgs | undefined)[];
  data?: any;
  chainId?: Uint8Array | string;
  receipt?: GeneralReceipt | GeneralReceiptArgs;
  lastBlockTime?: Date | string;
};
export class ChainQueryResponse {
  public type?: string;
  public mainChain?: MerkleState;
  public chains?: (ChainState | undefined)[];
  public data?: any;
  public chainId?: Uint8Array;
  public receipt?: GeneralReceipt;
  public lastBlockTime?: Date;

  constructor(args: ChainQueryResponseArgs) {
    this.type = args.type == undefined ? undefined : args.type;
    this.mainChain =
      args.mainChain == undefined
        ? undefined
        : args.mainChain instanceof MerkleState
          ? args.mainChain
          : new MerkleState(args.mainChain);
    this.chains =
      args.chains == undefined
        ? undefined
        : args.chains.map((v) =>
            v == undefined ? undefined : v instanceof ChainState ? v : new ChainState(v),
          );
    this.data = args.data == undefined ? undefined : args.data;
    this.chainId =
      args.chainId == undefined
        ? undefined
        : args.chainId instanceof Uint8Array
          ? args.chainId
          : Buffer.from(args.chainId, "hex");
    this.receipt =
      args.receipt == undefined
        ? undefined
        : args.receipt instanceof GeneralReceipt
          ? args.receipt
          : new GeneralReceipt(args.receipt);
    this.lastBlockTime =
      args.lastBlockTime == undefined
        ? undefined
        : args.lastBlockTime instanceof Date
          ? args.lastBlockTime
          : new Date(args.lastBlockTime);
  }

  copy() {
    return new ChainQueryResponse(this.asObject());
  }

  asObject(): ChainQueryResponseArgs {
    return {
      type: this.type === undefined ? undefined : this.type,
      mainChain: this.mainChain === undefined ? undefined : this.mainChain.asObject(),
      chains:
        this.chains === undefined
          ? undefined
          : this.chains?.map((v) => (v == undefined ? undefined : v.asObject())),
      data: this.data === undefined ? undefined : this.data,
      chainId:
        this.chainId === undefined
          ? undefined
          : this.chainId && Buffer.from(this.chainId).toString("hex"),
      receipt: this.receipt === undefined ? undefined : this.receipt.asObject(),
      lastBlockTime: this.lastBlockTime === undefined ? undefined : this.lastBlockTime,
    };
  }
}

export type ChainStateArgs = {
  name?: string;
  type?: protocol.ChainTypeArgs;
  height?: number;
  roots?: (Uint8Array | string | undefined)[];
};
export class ChainState {
  @(encodeAs.field(1).string)
  public name?: string;
  @(encodeAs.field(2).enum)
  public type?: protocol.ChainType;
  @(encodeAs.field(3).uint)
  public height?: number;
  @(encodeAs.field(4).repeatable.bytes)
  public roots?: (Uint8Array | undefined)[];

  constructor(args: ChainStateArgs) {
    this.name = args.name == undefined ? undefined : args.name;
    this.type = args.type == undefined ? undefined : protocol.ChainType.fromObject(args.type);
    this.height = args.height == undefined ? undefined : args.height;
    this.roots =
      args.roots == undefined
        ? undefined
        : args.roots.map((v) =>
            v == undefined ? undefined : v instanceof Uint8Array ? v : Buffer.from(v, "hex"),
          );
  }

  copy() {
    return new ChainState(this.asObject());
  }

  asObject(): ChainStateArgs {
    return {
      name: this.name === undefined ? undefined : this.name,
      type: this.type === undefined ? undefined : protocol.ChainType.getName(this.type),
      height: this.height === undefined ? undefined : this.height,
      roots:
        this.roots === undefined
          ? undefined
          : this.roots?.map((v) =>
              v == undefined ? undefined : v && Buffer.from(v).toString("hex"),
            ),
    };
  }
}

export type DataEntryQueryArgs = {
  url?: URLArgs;
  entryHash?: Uint8Array | string;
};
export class DataEntryQuery {
  @(encodeAs.field(1).url)
  public url?: URL;
  @(encodeAs.field(2).hash)
  public entryHash?: Uint8Array;

  constructor(args: DataEntryQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.entryHash =
      args.entryHash == undefined
        ? undefined
        : args.entryHash instanceof Uint8Array
          ? args.entryHash
          : Buffer.from(args.entryHash, "hex");
  }

  copy() {
    return new DataEntryQuery(this.asObject());
  }

  asObject(): DataEntryQueryArgs {
    return {
      url: this.url === undefined ? undefined : this.url.toString(),
      entryHash:
        this.entryHash === undefined
          ? undefined
          : this.entryHash && Buffer.from(this.entryHash).toString("hex"),
    };
  }
}

export type DataEntryQueryResponseArgs = {
  entryHash?: Uint8Array | string;
  entry?: protocol.DataEntry | protocol.DataEntryArgs;
  txId?: TxIDArgs;
  causeTxId?: TxIDArgs;
  lastBlockTime?: Date | string;
};
export class DataEntryQueryResponse {
  @(encodeAs.field(1).hash)
  public entryHash?: Uint8Array;
  @(encodeAs.field(2).union)
  public entry?: protocol.DataEntry;
  @(encodeAs.field(3).txid)
  public txId?: TxID;
  @(encodeAs.field(4).txid)
  public causeTxId?: TxID;
  @(encodeAs.field(5).time)
  public lastBlockTime?: Date;

  constructor(args: DataEntryQueryResponseArgs) {
    this.entryHash =
      args.entryHash == undefined
        ? undefined
        : args.entryHash instanceof Uint8Array
          ? args.entryHash
          : Buffer.from(args.entryHash, "hex");
    this.entry = args.entry == undefined ? undefined : protocol.DataEntry.fromObject(args.entry);
    this.txId = args.txId == undefined ? undefined : TxID.parse(args.txId);
    this.causeTxId = args.causeTxId == undefined ? undefined : TxID.parse(args.causeTxId);
    this.lastBlockTime =
      args.lastBlockTime == undefined
        ? undefined
        : args.lastBlockTime instanceof Date
          ? args.lastBlockTime
          : new Date(args.lastBlockTime);
  }

  copy() {
    return new DataEntryQueryResponse(this.asObject());
  }

  asObject(): DataEntryQueryResponseArgs {
    return {
      entryHash:
        this.entryHash === undefined
          ? undefined
          : this.entryHash && Buffer.from(this.entryHash).toString("hex"),
      entry: this.entry === undefined ? undefined : this.entry.asObject(),
      txId: this.txId === undefined ? undefined : this.txId.toString(),
      causeTxId: this.causeTxId === undefined ? undefined : this.causeTxId.toString(),
      lastBlockTime: this.lastBlockTime === undefined ? undefined : this.lastBlockTime,
    };
  }
}

export type DataEntrySetQueryArgs = {
  url?: URLArgs;
  start?: number;
  count?: number;
  expand?: boolean;
  height?: number;
  scratch?: boolean;
  prove?: boolean;
  includeRemote?: boolean;
};
export class DataEntrySetQuery {
  public url?: URL;
  public start?: number;
  public count?: number;
  public expand?: boolean;
  public height?: number;
  public scratch?: boolean;
  public prove?: boolean;
  public includeRemote?: boolean;

  constructor(args: DataEntrySetQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.start = args.start == undefined ? undefined : args.start;
    this.count = args.count == undefined ? undefined : args.count;
    this.expand = args.expand == undefined ? undefined : args.expand;
    this.height = args.height == undefined ? undefined : args.height;
    this.scratch = args.scratch == undefined ? undefined : args.scratch;
    this.prove = args.prove == undefined ? undefined : args.prove;
    this.includeRemote = args.includeRemote == undefined ? undefined : args.includeRemote;
  }

  copy() {
    return new DataEntrySetQuery(this.asObject());
  }

  asObject(): DataEntrySetQueryArgs {
    return {
      url: this.url === undefined ? undefined : this.url.toString(),
      start: this.start === undefined ? undefined : this.start,
      count: this.count === undefined ? undefined : this.count,
      expand: this.expand === undefined ? undefined : this.expand,
      height: this.height === undefined ? undefined : this.height,
      scratch: this.scratch === undefined ? undefined : this.scratch,
      prove: this.prove === undefined ? undefined : this.prove,
      includeRemote: this.includeRemote === undefined ? undefined : this.includeRemote,
    };
  }
}

export type DescriptionResponseArgs = {
  partitionId?: string;
  networkType?: protocol.PartitionTypeArgs;
  network?: NetworkDescription | NetworkDescriptionArgs;
  networkAnchor?: Uint8Array | string;
  values?: core.GlobalValues | core.GlobalValuesArgs;
  error?: errors2.Error | errors2.ErrorArgs;
};
export class DescriptionResponse {
  public partitionId?: string;
  public networkType?: protocol.PartitionType;
  public network?: NetworkDescription;
  public networkAnchor?: Uint8Array;
  public values?: core.GlobalValues;
  public error?: errors2.Error;

  constructor(args: DescriptionResponseArgs) {
    this.partitionId = args.partitionId == undefined ? undefined : args.partitionId;
    this.networkType =
      args.networkType == undefined
        ? undefined
        : protocol.PartitionType.fromObject(args.networkType);
    this.network =
      args.network == undefined
        ? undefined
        : args.network instanceof NetworkDescription
          ? args.network
          : new NetworkDescription(args.network);
    this.networkAnchor =
      args.networkAnchor == undefined
        ? undefined
        : args.networkAnchor instanceof Uint8Array
          ? args.networkAnchor
          : Buffer.from(args.networkAnchor, "hex");
    this.values =
      args.values == undefined
        ? undefined
        : args.values instanceof core.GlobalValues
          ? args.values
          : new core.GlobalValues(args.values);
    this.error =
      args.error == undefined
        ? undefined
        : args.error instanceof errors2.Error
          ? args.error
          : new errors2.Error(args.error);
  }

  copy() {
    return new DescriptionResponse(this.asObject());
  }

  asObject(): DescriptionResponseArgs {
    return {
      partitionId: this.partitionId === undefined ? undefined : this.partitionId,
      networkType:
        this.networkType === undefined
          ? undefined
          : protocol.PartitionType.getName(this.networkType),
      network: this.network === undefined ? undefined : this.network.asObject(),
      networkAnchor:
        this.networkAnchor === undefined
          ? undefined
          : this.networkAnchor && Buffer.from(this.networkAnchor).toString("hex"),
      values: this.values === undefined ? undefined : this.values.asObject(),
      error: this.error === undefined ? undefined : this.error.asObject(),
    };
  }
}

export type DirectoryQueryArgs = {
  url?: URLArgs;
  start?: number;
  count?: number;
  expand?: boolean;
  height?: number;
  scratch?: boolean;
  prove?: boolean;
  includeRemote?: boolean;
};
export class DirectoryQuery {
  public url?: URL;
  public start?: number;
  public count?: number;
  public expand?: boolean;
  public height?: number;
  public scratch?: boolean;
  public prove?: boolean;
  public includeRemote?: boolean;

  constructor(args: DirectoryQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.start = args.start == undefined ? undefined : args.start;
    this.count = args.count == undefined ? undefined : args.count;
    this.expand = args.expand == undefined ? undefined : args.expand;
    this.height = args.height == undefined ? undefined : args.height;
    this.scratch = args.scratch == undefined ? undefined : args.scratch;
    this.prove = args.prove == undefined ? undefined : args.prove;
    this.includeRemote = args.includeRemote == undefined ? undefined : args.includeRemote;
  }

  copy() {
    return new DirectoryQuery(this.asObject());
  }

  asObject(): DirectoryQueryArgs {
    return {
      url: this.url === undefined ? undefined : this.url.toString(),
      start: this.start === undefined ? undefined : this.start,
      count: this.count === undefined ? undefined : this.count,
      expand: this.expand === undefined ? undefined : this.expand,
      height: this.height === undefined ? undefined : this.height,
      scratch: this.scratch === undefined ? undefined : this.scratch,
      prove: this.prove === undefined ? undefined : this.prove,
      includeRemote: this.includeRemote === undefined ? undefined : this.includeRemote,
    };
  }
}

export type ExecuteRequestArgs = {
  envelope?: messaging.Envelope | messaging.EnvelopeArgs;
  checkOnly?: boolean;
};
export class ExecuteRequest {
  public envelope?: messaging.Envelope;
  public checkOnly?: boolean;

  constructor(args: ExecuteRequestArgs) {
    this.envelope =
      args.envelope == undefined
        ? undefined
        : args.envelope instanceof messaging.Envelope
          ? args.envelope
          : new messaging.Envelope(args.envelope);
    this.checkOnly = args.checkOnly == undefined ? undefined : args.checkOnly;
  }

  copy() {
    return new ExecuteRequest(this.asObject());
  }

  asObject(): ExecuteRequestArgs {
    return {
      envelope: this.envelope === undefined ? undefined : this.envelope.asObject(),
      checkOnly: this.checkOnly === undefined ? undefined : this.checkOnly,
    };
  }
}

export type GeneralQueryArgs = {
  url?: URLArgs;
  expand?: boolean;
  height?: number;
  scratch?: boolean;
  prove?: boolean;
  includeRemote?: boolean;
};
export class GeneralQuery {
  public url?: URL;
  public expand?: boolean;
  public height?: number;
  public scratch?: boolean;
  public prove?: boolean;
  public includeRemote?: boolean;

  constructor(args: GeneralQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.expand = args.expand == undefined ? undefined : args.expand;
    this.height = args.height == undefined ? undefined : args.height;
    this.scratch = args.scratch == undefined ? undefined : args.scratch;
    this.prove = args.prove == undefined ? undefined : args.prove;
    this.includeRemote = args.includeRemote == undefined ? undefined : args.includeRemote;
  }

  copy() {
    return new GeneralQuery(this.asObject());
  }

  asObject(): GeneralQueryArgs {
    return {
      url: this.url === undefined ? undefined : this.url.toString(),
      expand: this.expand === undefined ? undefined : this.expand,
      height: this.height === undefined ? undefined : this.height,
      scratch: this.scratch === undefined ? undefined : this.scratch,
      prove: this.prove === undefined ? undefined : this.prove,
      includeRemote: this.includeRemote === undefined ? undefined : this.includeRemote,
    };
  }
}

export type GeneralReceiptArgs = {
  localBlock?: number;
  localBlockTime?: Date | string;
  directoryBlock?: number;
  majorBlock?: number;
  proof?: merkle.Receipt | merkle.ReceiptArgs;
  error?: string;
};
export class GeneralReceipt {
  @(encodeAs.field(1).uint)
  public localBlock?: number;
  @(encodeAs.field(2).time)
  public localBlockTime?: Date;
  @(encodeAs.field(3).uint)
  public directoryBlock?: number;
  @(encodeAs.field(4).uint)
  public majorBlock?: number;
  @(encodeAs.field(5).reference)
  public proof?: merkle.Receipt;
  @(encodeAs.field(6).string)
  public error?: string;

  constructor(args: GeneralReceiptArgs) {
    this.localBlock = args.localBlock == undefined ? undefined : args.localBlock;
    this.localBlockTime =
      args.localBlockTime == undefined
        ? undefined
        : args.localBlockTime instanceof Date
          ? args.localBlockTime
          : new Date(args.localBlockTime);
    this.directoryBlock = args.directoryBlock == undefined ? undefined : args.directoryBlock;
    this.majorBlock = args.majorBlock == undefined ? undefined : args.majorBlock;
    this.proof =
      args.proof == undefined
        ? undefined
        : args.proof instanceof merkle.Receipt
          ? args.proof
          : new merkle.Receipt(args.proof);
    this.error = args.error == undefined ? undefined : args.error;
  }

  copy() {
    return new GeneralReceipt(this.asObject());
  }

  asObject(): GeneralReceiptArgs {
    return {
      localBlock: this.localBlock === undefined ? undefined : this.localBlock,
      localBlockTime: this.localBlockTime === undefined ? undefined : this.localBlockTime,
      directoryBlock: this.directoryBlock === undefined ? undefined : this.directoryBlock,
      majorBlock: this.majorBlock === undefined ? undefined : this.majorBlock,
      proof: this.proof === undefined ? undefined : this.proof.asObject(),
      error: this.error === undefined ? undefined : this.error,
    };
  }
}

export type KeyPageArgs = {
  version?: number;
};
export class KeyPage {
  public version?: number;

  constructor(args: KeyPageArgs) {
    this.version = args.version == undefined ? undefined : args.version;
  }

  copy() {
    return new KeyPage(this.asObject());
  }

  asObject(): KeyPageArgs {
    return {
      version: this.version === undefined ? undefined : this.version,
    };
  }
}

export type KeyPageIndexQueryArgs = {
  url?: URLArgs;
  key?: Uint8Array | string;
};
export class KeyPageIndexQuery {
  public url?: URL;
  public key?: Uint8Array;

  constructor(args: KeyPageIndexQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.key =
      args.key == undefined
        ? undefined
        : args.key instanceof Uint8Array
          ? args.key
          : Buffer.from(args.key, "hex");
  }

  copy() {
    return new KeyPageIndexQuery(this.asObject());
  }

  asObject(): KeyPageIndexQueryArgs {
    return {
      url: this.url === undefined ? undefined : this.url.toString(),
      key: this.key === undefined ? undefined : this.key && Buffer.from(this.key).toString("hex"),
    };
  }
}

export type MajorBlocksQueryArgs = {
  url?: URLArgs;
  start?: number;
  count?: number;
};
export class MajorBlocksQuery {
  public url?: URL;
  public start?: number;
  public count?: number;

  constructor(args: MajorBlocksQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.start = args.start == undefined ? undefined : args.start;
    this.count = args.count == undefined ? undefined : args.count;
  }

  copy() {
    return new MajorBlocksQuery(this.asObject());
  }

  asObject(): MajorBlocksQueryArgs {
    return {
      url: this.url === undefined ? undefined : this.url.toString(),
      start: this.start === undefined ? undefined : this.start,
      count: this.count === undefined ? undefined : this.count,
    };
  }
}

export type MajorQueryResponseArgs = {
  majorBlockIndex?: number;
  majorBlockTime?: Date | string;
  minorBlocks?: (MinorBlock | MinorBlockArgs | undefined)[];
  lastBlockTime?: Date | string;
};
export class MajorQueryResponse {
  public majorBlockIndex?: number;
  public majorBlockTime?: Date;
  public minorBlocks?: (MinorBlock | undefined)[];
  public lastBlockTime?: Date;

  constructor(args: MajorQueryResponseArgs) {
    this.majorBlockIndex = args.majorBlockIndex == undefined ? undefined : args.majorBlockIndex;
    this.majorBlockTime =
      args.majorBlockTime == undefined
        ? undefined
        : args.majorBlockTime instanceof Date
          ? args.majorBlockTime
          : new Date(args.majorBlockTime);
    this.minorBlocks =
      args.minorBlocks == undefined
        ? undefined
        : args.minorBlocks.map((v) =>
            v == undefined ? undefined : v instanceof MinorBlock ? v : new MinorBlock(v),
          );
    this.lastBlockTime =
      args.lastBlockTime == undefined
        ? undefined
        : args.lastBlockTime instanceof Date
          ? args.lastBlockTime
          : new Date(args.lastBlockTime);
  }

  copy() {
    return new MajorQueryResponse(this.asObject());
  }

  asObject(): MajorQueryResponseArgs {
    return {
      majorBlockIndex: this.majorBlockIndex === undefined ? undefined : this.majorBlockIndex,
      majorBlockTime: this.majorBlockTime === undefined ? undefined : this.majorBlockTime,
      minorBlocks:
        this.minorBlocks === undefined
          ? undefined
          : this.minorBlocks?.map((v) => (v == undefined ? undefined : v.asObject())),
      lastBlockTime: this.lastBlockTime === undefined ? undefined : this.lastBlockTime,
    };
  }
}

export type MerkleStateArgs = {
  height?: number;
  roots?: (Uint8Array | string | undefined)[];
};
export class MerkleState {
  public height?: number;
  public roots?: (Uint8Array | undefined)[];

  constructor(args: MerkleStateArgs) {
    this.height = args.height == undefined ? undefined : args.height;
    this.roots =
      args.roots == undefined
        ? undefined
        : args.roots.map((v) =>
            v == undefined ? undefined : v instanceof Uint8Array ? v : Buffer.from(v, "hex"),
          );
  }

  copy() {
    return new MerkleState(this.asObject());
  }

  asObject(): MerkleStateArgs {
    return {
      height: this.height === undefined ? undefined : this.height,
      roots:
        this.roots === undefined
          ? undefined
          : this.roots?.map((v) =>
              v == undefined ? undefined : v && Buffer.from(v).toString("hex"),
            ),
    };
  }
}

export type MetricsQueryArgs = {
  metric?: string;
  duration?: number;
};
export class MetricsQuery {
  public metric?: string;
  public duration?: number;

  constructor(args: MetricsQueryArgs) {
    this.metric = args.metric == undefined ? undefined : args.metric;
    this.duration = args.duration == undefined ? undefined : args.duration;
  }

  copy() {
    return new MetricsQuery(this.asObject());
  }

  asObject(): MetricsQueryArgs {
    return {
      metric: this.metric === undefined ? undefined : this.metric,
      duration: this.duration === undefined ? undefined : this.duration,
    };
  }
}

export type MetricsResponseArgs = {
  value?: any;
};
export class MetricsResponse {
  public value?: any;

  constructor(args: MetricsResponseArgs) {
    this.value = args.value == undefined ? undefined : args.value;
  }

  copy() {
    return new MetricsResponse(this.asObject());
  }

  asObject(): MetricsResponseArgs {
    return {
      value: this.value === undefined ? undefined : this.value,
    };
  }
}

export type MinorBlockArgs = {
  blockIndex?: number;
  blockTime?: Date | string;
};
export class MinorBlock {
  public blockIndex?: number;
  public blockTime?: Date;

  constructor(args: MinorBlockArgs) {
    this.blockIndex = args.blockIndex == undefined ? undefined : args.blockIndex;
    this.blockTime =
      args.blockTime == undefined
        ? undefined
        : args.blockTime instanceof Date
          ? args.blockTime
          : new Date(args.blockTime);
  }

  copy() {
    return new MinorBlock(this.asObject());
  }

  asObject(): MinorBlockArgs {
    return {
      blockIndex: this.blockIndex === undefined ? undefined : this.blockIndex,
      blockTime: this.blockTime === undefined ? undefined : this.blockTime,
    };
  }
}

export type MinorBlocksQueryArgs = {
  url?: URLArgs;
  start?: number;
  count?: number;
  txFetchMode?: TxFetchModeArgs;
  blockFilterMode?: BlockFilterModeArgs;
};
export class MinorBlocksQuery {
  public url?: URL;
  public start?: number;
  public count?: number;
  public txFetchMode?: TxFetchMode;
  public blockFilterMode?: BlockFilterMode;

  constructor(args: MinorBlocksQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.start = args.start == undefined ? undefined : args.start;
    this.count = args.count == undefined ? undefined : args.count;
    this.txFetchMode =
      args.txFetchMode == undefined ? undefined : TxFetchMode.fromObject(args.txFetchMode);
    this.blockFilterMode =
      args.blockFilterMode == undefined
        ? undefined
        : BlockFilterMode.fromObject(args.blockFilterMode);
  }

  copy() {
    return new MinorBlocksQuery(this.asObject());
  }

  asObject(): MinorBlocksQueryArgs {
    return {
      url: this.url === undefined ? undefined : this.url.toString(),
      start: this.start === undefined ? undefined : this.start,
      count: this.count === undefined ? undefined : this.count,
      txFetchMode:
        this.txFetchMode === undefined ? undefined : TxFetchMode.getName(this.txFetchMode),
      blockFilterMode:
        this.blockFilterMode === undefined
          ? undefined
          : BlockFilterMode.getName(this.blockFilterMode),
    };
  }
}

export type MinorQueryResponseArgs = {
  blockIndex?: number;
  blockTime?: Date | string;
  txCount?: number;
  txIds?: (Uint8Array | string | undefined)[];
  transactions?: (TransactionQueryResponse | TransactionQueryResponseArgs | undefined)[];
  lastBlockTime?: Date | string;
};
export class MinorQueryResponse {
  public blockIndex?: number;
  public blockTime?: Date;
  public txCount?: number;
  public txIds?: (Uint8Array | undefined)[];
  public transactions?: (TransactionQueryResponse | undefined)[];
  public lastBlockTime?: Date;

  constructor(args: MinorQueryResponseArgs) {
    this.blockIndex = args.blockIndex == undefined ? undefined : args.blockIndex;
    this.blockTime =
      args.blockTime == undefined
        ? undefined
        : args.blockTime instanceof Date
          ? args.blockTime
          : new Date(args.blockTime);
    this.txCount = args.txCount == undefined ? undefined : args.txCount;
    this.txIds =
      args.txIds == undefined
        ? undefined
        : args.txIds.map((v) =>
            v == undefined ? undefined : v instanceof Uint8Array ? v : Buffer.from(v, "hex"),
          );
    this.transactions =
      args.transactions == undefined
        ? undefined
        : args.transactions.map((v) =>
            v == undefined
              ? undefined
              : v instanceof TransactionQueryResponse
                ? v
                : new TransactionQueryResponse(v),
          );
    this.lastBlockTime =
      args.lastBlockTime == undefined
        ? undefined
        : args.lastBlockTime instanceof Date
          ? args.lastBlockTime
          : new Date(args.lastBlockTime);
  }

  copy() {
    return new MinorQueryResponse(this.asObject());
  }

  asObject(): MinorQueryResponseArgs {
    return {
      blockIndex: this.blockIndex === undefined ? undefined : this.blockIndex,
      blockTime: this.blockTime === undefined ? undefined : this.blockTime,
      txCount: this.txCount === undefined ? undefined : this.txCount,
      txIds:
        this.txIds === undefined
          ? undefined
          : this.txIds?.map((v) =>
              v == undefined ? undefined : v && Buffer.from(v).toString("hex"),
            ),
      transactions:
        this.transactions === undefined
          ? undefined
          : this.transactions?.map((v) => (v == undefined ? undefined : v.asObject())),
      lastBlockTime: this.lastBlockTime === undefined ? undefined : this.lastBlockTime,
    };
  }
}

export type MultiResponseArgs = {
  type?: string;
  items?: (any | undefined)[];
  start?: number;
  count?: number;
  total?: number;
  otherItems?: (any | undefined)[];
  lastBlockTime?: Date | string;
};
export class MultiResponse {
  public type?: string;
  public items?: (any | undefined)[];
  public start?: number;
  public count?: number;
  public total?: number;
  public otherItems?: (any | undefined)[];
  public lastBlockTime?: Date;

  constructor(args: MultiResponseArgs) {
    this.type = args.type == undefined ? undefined : args.type;
    this.items =
      args.items == undefined ? undefined : args.items.map((v) => (v == undefined ? undefined : v));
    this.start = args.start == undefined ? undefined : args.start;
    this.count = args.count == undefined ? undefined : args.count;
    this.total = args.total == undefined ? undefined : args.total;
    this.otherItems =
      args.otherItems == undefined
        ? undefined
        : args.otherItems.map((v) => (v == undefined ? undefined : v));
    this.lastBlockTime =
      args.lastBlockTime == undefined
        ? undefined
        : args.lastBlockTime instanceof Date
          ? args.lastBlockTime
          : new Date(args.lastBlockTime);
  }

  copy() {
    return new MultiResponse(this.asObject());
  }

  asObject(): MultiResponseArgs {
    return {
      type: this.type === undefined ? undefined : this.type,
      items:
        this.items === undefined
          ? undefined
          : this.items?.map((v) => (v == undefined ? undefined : v)),
      start: this.start === undefined ? undefined : this.start,
      count: this.count === undefined ? undefined : this.count,
      total: this.total === undefined ? undefined : this.total,
      otherItems:
        this.otherItems === undefined
          ? undefined
          : this.otherItems?.map((v) => (v == undefined ? undefined : v)),
      lastBlockTime: this.lastBlockTime === undefined ? undefined : this.lastBlockTime,
    };
  }
}

export type NetworkDescriptionArgs = {
  id?: string;
  partitions?: (PartitionDescription | PartitionDescriptionArgs | undefined)[];
};
export class NetworkDescription {
  @(encodeAs.field(1).string)
  public id?: string;
  @(encodeAs.field(2).repeatable.reference)
  public partitions?: (PartitionDescription | undefined)[];

  constructor(args: NetworkDescriptionArgs) {
    this.id = args.id == undefined ? undefined : args.id;
    this.partitions =
      args.partitions == undefined
        ? undefined
        : args.partitions.map((v) =>
            v == undefined
              ? undefined
              : v instanceof PartitionDescription
                ? v
                : new PartitionDescription(v),
          );
  }

  copy() {
    return new NetworkDescription(this.asObject());
  }

  asObject(): NetworkDescriptionArgs {
    return {
      id: this.id === undefined ? undefined : this.id,
      partitions:
        this.partitions === undefined
          ? undefined
          : this.partitions?.map((v) => (v == undefined ? undefined : v.asObject())),
    };
  }
}

export type NodeDescriptionArgs = {
  address?: string;
  type?: config.NodeTypeArgs;
};
export class NodeDescription {
  @(encodeAs.field(1).string)
  public address?: string;
  @(encodeAs.field(2).enum)
  public type?: config.NodeType;

  constructor(args: NodeDescriptionArgs) {
    this.address = args.address == undefined ? undefined : args.address;
    this.type = args.type == undefined ? undefined : config.NodeType.fromObject(args.type);
  }

  copy() {
    return new NodeDescription(this.asObject());
  }

  asObject(): NodeDescriptionArgs {
    return {
      address: this.address === undefined ? undefined : this.address,
      type: this.type === undefined ? undefined : config.NodeType.getName(this.type),
    };
  }
}

export type PartitionDescriptionArgs = {
  id?: string;
  type?: protocol.PartitionTypeArgs;
  basePort?: number;
  nodes?: (NodeDescription | NodeDescriptionArgs | undefined)[];
};
export class PartitionDescription {
  @(encodeAs.field(1).string)
  public id?: string;
  @(encodeAs.field(2).enum)
  public type?: protocol.PartitionType;
  @(encodeAs.field(3).int)
  public basePort?: number;
  @(encodeAs.field(4).repeatable.reference)
  public nodes?: (NodeDescription | undefined)[];

  constructor(args: PartitionDescriptionArgs) {
    this.id = args.id == undefined ? undefined : args.id;
    this.type = args.type == undefined ? undefined : protocol.PartitionType.fromObject(args.type);
    this.basePort = args.basePort == undefined ? undefined : args.basePort;
    this.nodes =
      args.nodes == undefined
        ? undefined
        : args.nodes.map((v) =>
            v == undefined ? undefined : v instanceof NodeDescription ? v : new NodeDescription(v),
          );
  }

  copy() {
    return new PartitionDescription(this.asObject());
  }

  asObject(): PartitionDescriptionArgs {
    return {
      id: this.id === undefined ? undefined : this.id,
      type: this.type === undefined ? undefined : protocol.PartitionType.getName(this.type),
      basePort: this.basePort === undefined ? undefined : this.basePort,
      nodes:
        this.nodes === undefined
          ? undefined
          : this.nodes?.map((v) => (v == undefined ? undefined : v.asObject())),
    };
  }
}

export type QueryOptionsArgs = {
  expand?: boolean;
  height?: number;
  scratch?: boolean;
  prove?: boolean;
  includeRemote?: boolean;
};
export class QueryOptions {
  public expand?: boolean;
  public height?: number;
  public scratch?: boolean;
  public prove?: boolean;
  public includeRemote?: boolean;

  constructor(args: QueryOptionsArgs) {
    this.expand = args.expand == undefined ? undefined : args.expand;
    this.height = args.height == undefined ? undefined : args.height;
    this.scratch = args.scratch == undefined ? undefined : args.scratch;
    this.prove = args.prove == undefined ? undefined : args.prove;
    this.includeRemote = args.includeRemote == undefined ? undefined : args.includeRemote;
  }

  copy() {
    return new QueryOptions(this.asObject());
  }

  asObject(): QueryOptionsArgs {
    return {
      expand: this.expand === undefined ? undefined : this.expand,
      height: this.height === undefined ? undefined : this.height,
      scratch: this.scratch === undefined ? undefined : this.scratch,
      prove: this.prove === undefined ? undefined : this.prove,
      includeRemote: this.includeRemote === undefined ? undefined : this.includeRemote,
    };
  }
}

export type QueryPaginationArgs = {
  start?: number;
  count?: number;
};
export class QueryPagination {
  public start?: number;
  public count?: number;

  constructor(args: QueryPaginationArgs) {
    this.start = args.start == undefined ? undefined : args.start;
    this.count = args.count == undefined ? undefined : args.count;
  }

  copy() {
    return new QueryPagination(this.asObject());
  }

  asObject(): QueryPaginationArgs {
    return {
      start: this.start === undefined ? undefined : this.start,
      count: this.count === undefined ? undefined : this.count,
    };
  }
}

export type ResponseDataEntryArgs = {
  entryHash?: Uint8Array | string;
  entry?: protocol.DataEntry | protocol.DataEntryArgs;
  txId?: TxIDArgs;
  causeTxId?: TxIDArgs;
  lastBlockTime?: Date | string;
};
export class ResponseDataEntry {
  @(encodeAs.field(1).hash)
  public entryHash?: Uint8Array;
  @(encodeAs.field(2).union)
  public entry?: protocol.DataEntry;
  @(encodeAs.field(3).txid)
  public txId?: TxID;
  @(encodeAs.field(4).txid)
  public causeTxId?: TxID;
  @(encodeAs.field(5).time)
  public lastBlockTime?: Date;

  constructor(args: ResponseDataEntryArgs) {
    this.entryHash =
      args.entryHash == undefined
        ? undefined
        : args.entryHash instanceof Uint8Array
          ? args.entryHash
          : Buffer.from(args.entryHash, "hex");
    this.entry = args.entry == undefined ? undefined : protocol.DataEntry.fromObject(args.entry);
    this.txId = args.txId == undefined ? undefined : TxID.parse(args.txId);
    this.causeTxId = args.causeTxId == undefined ? undefined : TxID.parse(args.causeTxId);
    this.lastBlockTime =
      args.lastBlockTime == undefined
        ? undefined
        : args.lastBlockTime instanceof Date
          ? args.lastBlockTime
          : new Date(args.lastBlockTime);
  }

  copy() {
    return new ResponseDataEntry(this.asObject());
  }

  asObject(): ResponseDataEntryArgs {
    return {
      entryHash:
        this.entryHash === undefined
          ? undefined
          : this.entryHash && Buffer.from(this.entryHash).toString("hex"),
      entry: this.entry === undefined ? undefined : this.entry.asObject(),
      txId: this.txId === undefined ? undefined : this.txId.toString(),
      causeTxId: this.causeTxId === undefined ? undefined : this.causeTxId.toString(),
      lastBlockTime: this.lastBlockTime === undefined ? undefined : this.lastBlockTime,
    };
  }
}

export type ResponseDataEntrySetArgs = {
  dataEntries?: (ResponseDataEntry | ResponseDataEntryArgs | undefined)[];
  total?: number;
  lastBlockTime?: Date | string;
};
export class ResponseDataEntrySet {
  @(encodeAs.field(1).repeatable.reference)
  public dataEntries?: (ResponseDataEntry | undefined)[];
  @(encodeAs.field(2).uint)
  public total?: number;
  @(encodeAs.field(3).time)
  public lastBlockTime?: Date;

  constructor(args: ResponseDataEntrySetArgs) {
    this.dataEntries =
      args.dataEntries == undefined
        ? undefined
        : args.dataEntries.map((v) =>
            v == undefined
              ? undefined
              : v instanceof ResponseDataEntry
                ? v
                : new ResponseDataEntry(v),
          );
    this.total = args.total == undefined ? undefined : args.total;
    this.lastBlockTime =
      args.lastBlockTime == undefined
        ? undefined
        : args.lastBlockTime instanceof Date
          ? args.lastBlockTime
          : new Date(args.lastBlockTime);
  }

  copy() {
    return new ResponseDataEntrySet(this.asObject());
  }

  asObject(): ResponseDataEntrySetArgs {
    return {
      dataEntries:
        this.dataEntries === undefined
          ? undefined
          : this.dataEntries?.map((v) => (v == undefined ? undefined : v.asObject())),
      total: this.total === undefined ? undefined : this.total,
      lastBlockTime: this.lastBlockTime === undefined ? undefined : this.lastBlockTime,
    };
  }
}

export type ResponseKeyPageIndexArgs = {
  authority?: URLArgs;
  signer?: URLArgs;
  index?: number;
  lastBlockTime?: Date | string;
};
export class ResponseKeyPageIndex {
  @(encodeAs.field(1).url)
  public authority?: URL;
  @(encodeAs.field(2).url)
  public signer?: URL;
  @(encodeAs.field(3).keepEmpty.uint)
  public index?: number;
  @(encodeAs.field(4).time)
  public lastBlockTime?: Date;

  constructor(args: ResponseKeyPageIndexArgs) {
    this.authority = args.authority == undefined ? undefined : URL.parse(args.authority);
    this.signer = args.signer == undefined ? undefined : URL.parse(args.signer);
    this.index = args.index == undefined ? undefined : args.index;
    this.lastBlockTime =
      args.lastBlockTime == undefined
        ? undefined
        : args.lastBlockTime instanceof Date
          ? args.lastBlockTime
          : new Date(args.lastBlockTime);
  }

  copy() {
    return new ResponseKeyPageIndex(this.asObject());
  }

  asObject(): ResponseKeyPageIndexArgs {
    return {
      authority: this.authority === undefined ? undefined : this.authority.toString(),
      signer: this.signer === undefined ? undefined : this.signer.toString(),
      index: this.index === undefined ? undefined : this.index,
      lastBlockTime: this.lastBlockTime === undefined ? undefined : this.lastBlockTime,
    };
  }
}

export type SignatureBookArgs = {
  authority?: URLArgs;
  pages?: (SignaturePage | SignaturePageArgs | undefined)[];
};
export class SignatureBook {
  public authority?: URL;
  public pages?: (SignaturePage | undefined)[];

  constructor(args: SignatureBookArgs) {
    this.authority = args.authority == undefined ? undefined : URL.parse(args.authority);
    this.pages =
      args.pages == undefined
        ? undefined
        : args.pages.map((v) =>
            v == undefined ? undefined : v instanceof SignaturePage ? v : new SignaturePage(v),
          );
  }

  copy() {
    return new SignatureBook(this.asObject());
  }

  asObject(): SignatureBookArgs {
    return {
      authority: this.authority === undefined ? undefined : this.authority.toString(),
      pages:
        this.pages === undefined
          ? undefined
          : this.pages?.map((v) => (v == undefined ? undefined : v.asObject())),
    };
  }
}

export type SignaturePageArgs = {
  signer?: SignerMetadata | SignerMetadataArgs;
  signatures?: (protocol.Signature | protocol.SignatureArgs | undefined)[];
};
export class SignaturePage {
  public signer?: SignerMetadata;
  public signatures?: (protocol.Signature | undefined)[];

  constructor(args: SignaturePageArgs) {
    this.signer =
      args.signer == undefined
        ? undefined
        : args.signer instanceof SignerMetadata
          ? args.signer
          : new SignerMetadata(args.signer);
    this.signatures =
      args.signatures == undefined
        ? undefined
        : args.signatures.map((v) =>
            v == undefined ? undefined : protocol.Signature.fromObject(v),
          );
  }

  copy() {
    return new SignaturePage(this.asObject());
  }

  asObject(): SignaturePageArgs {
    return {
      signer: this.signer === undefined ? undefined : this.signer.asObject(),
      signatures:
        this.signatures === undefined
          ? undefined
          : this.signatures?.map((v) => (v == undefined ? undefined : v.asObject())),
    };
  }
}

export type SignerArgs = {
  publicKey?: Uint8Array | string;
  timestamp?: number;
  url?: URLArgs;
  version?: number;
  signatureType?: protocol.SignatureTypeArgs;
  useSimpleHash?: boolean;
};
export class Signer {
  public publicKey?: Uint8Array;
  public timestamp?: number;
  public url?: URL;
  public version?: number;
  public signatureType?: protocol.SignatureType;
  public useSimpleHash?: boolean;

  constructor(args: SignerArgs) {
    this.publicKey =
      args.publicKey == undefined
        ? undefined
        : args.publicKey instanceof Uint8Array
          ? args.publicKey
          : Buffer.from(args.publicKey, "hex");
    this.timestamp = args.timestamp == undefined ? undefined : args.timestamp;
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.version = args.version == undefined ? undefined : args.version;
    this.signatureType =
      args.signatureType == undefined
        ? undefined
        : protocol.SignatureType.fromObject(args.signatureType);
    this.useSimpleHash = args.useSimpleHash == undefined ? undefined : args.useSimpleHash;
  }

  copy() {
    return new Signer(this.asObject());
  }

  asObject(): SignerArgs {
    return {
      publicKey:
        this.publicKey === undefined
          ? undefined
          : this.publicKey && Buffer.from(this.publicKey).toString("hex"),
      timestamp: this.timestamp === undefined ? undefined : this.timestamp,
      url: this.url === undefined ? undefined : this.url.toString(),
      version: this.version === undefined ? undefined : this.version,
      signatureType:
        this.signatureType === undefined
          ? undefined
          : protocol.SignatureType.getName(this.signatureType),
      useSimpleHash: this.useSimpleHash === undefined ? undefined : this.useSimpleHash,
    };
  }
}

export type SignerMetadataArgs = {
  type?: protocol.AccountTypeArgs;
  url?: URLArgs;
  acceptThreshold?: number;
};
export class SignerMetadata {
  public type?: protocol.AccountType;
  public url?: URL;
  public acceptThreshold?: number;

  constructor(args: SignerMetadataArgs) {
    this.type = args.type == undefined ? undefined : protocol.AccountType.fromObject(args.type);
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.acceptThreshold = args.acceptThreshold == undefined ? undefined : args.acceptThreshold;
  }

  copy() {
    return new SignerMetadata(this.asObject());
  }

  asObject(): SignerMetadataArgs {
    return {
      type: this.type === undefined ? undefined : protocol.AccountType.getName(this.type),
      url: this.url === undefined ? undefined : this.url.toString(),
      acceptThreshold: this.acceptThreshold === undefined ? undefined : this.acceptThreshold,
    };
  }
}

export type StatusResponseArgs = {
  ok?: boolean;
  bvnHeight?: number;
  dnHeight?: number;
  bvnTime?: Date | string;
  dnTime?: Date | string;
  lastDirectoryAnchorHeight?: number;
  bvnRootHash?: Uint8Array | string;
  dnRootHash?: Uint8Array | string;
  bvnBptHash?: Uint8Array | string;
  dnBptHash?: Uint8Array | string;
};
export class StatusResponse {
  public ok?: boolean;
  public bvnHeight?: number;
  public dnHeight?: number;
  public bvnTime?: Date;
  public dnTime?: Date;
  public lastDirectoryAnchorHeight?: number;
  public bvnRootHash?: Uint8Array;
  public dnRootHash?: Uint8Array;
  public bvnBptHash?: Uint8Array;
  public dnBptHash?: Uint8Array;

  constructor(args: StatusResponseArgs) {
    this.ok = args.ok == undefined ? undefined : args.ok;
    this.bvnHeight = args.bvnHeight == undefined ? undefined : args.bvnHeight;
    this.dnHeight = args.dnHeight == undefined ? undefined : args.dnHeight;
    this.bvnTime =
      args.bvnTime == undefined
        ? undefined
        : args.bvnTime instanceof Date
          ? args.bvnTime
          : new Date(args.bvnTime);
    this.dnTime =
      args.dnTime == undefined
        ? undefined
        : args.dnTime instanceof Date
          ? args.dnTime
          : new Date(args.dnTime);
    this.lastDirectoryAnchorHeight =
      args.lastDirectoryAnchorHeight == undefined ? undefined : args.lastDirectoryAnchorHeight;
    this.bvnRootHash =
      args.bvnRootHash == undefined
        ? undefined
        : args.bvnRootHash instanceof Uint8Array
          ? args.bvnRootHash
          : Buffer.from(args.bvnRootHash, "hex");
    this.dnRootHash =
      args.dnRootHash == undefined
        ? undefined
        : args.dnRootHash instanceof Uint8Array
          ? args.dnRootHash
          : Buffer.from(args.dnRootHash, "hex");
    this.bvnBptHash =
      args.bvnBptHash == undefined
        ? undefined
        : args.bvnBptHash instanceof Uint8Array
          ? args.bvnBptHash
          : Buffer.from(args.bvnBptHash, "hex");
    this.dnBptHash =
      args.dnBptHash == undefined
        ? undefined
        : args.dnBptHash instanceof Uint8Array
          ? args.dnBptHash
          : Buffer.from(args.dnBptHash, "hex");
  }

  copy() {
    return new StatusResponse(this.asObject());
  }

  asObject(): StatusResponseArgs {
    return {
      ok: this.ok === undefined ? undefined : this.ok,
      bvnHeight: this.bvnHeight === undefined ? undefined : this.bvnHeight,
      dnHeight: this.dnHeight === undefined ? undefined : this.dnHeight,
      bvnTime: this.bvnTime === undefined ? undefined : this.bvnTime,
      dnTime: this.dnTime === undefined ? undefined : this.dnTime,
      lastDirectoryAnchorHeight:
        this.lastDirectoryAnchorHeight === undefined ? undefined : this.lastDirectoryAnchorHeight,
      bvnRootHash:
        this.bvnRootHash === undefined
          ? undefined
          : this.bvnRootHash && Buffer.from(this.bvnRootHash).toString("hex"),
      dnRootHash:
        this.dnRootHash === undefined
          ? undefined
          : this.dnRootHash && Buffer.from(this.dnRootHash).toString("hex"),
      bvnBptHash:
        this.bvnBptHash === undefined
          ? undefined
          : this.bvnBptHash && Buffer.from(this.bvnBptHash).toString("hex"),
      dnBptHash:
        this.dnBptHash === undefined
          ? undefined
          : this.dnBptHash && Buffer.from(this.dnBptHash).toString("hex"),
    };
  }
}

export type SyntheticTransactionRequestArgs = {
  source?: URLArgs;
  destination?: URLArgs;
  sequenceNumber?: number;
  anchor?: boolean;
};
export class SyntheticTransactionRequest {
  public source?: URL;
  public destination?: URL;
  public sequenceNumber?: number;
  public anchor?: boolean;

  constructor(args: SyntheticTransactionRequestArgs) {
    this.source = args.source == undefined ? undefined : URL.parse(args.source);
    this.destination = args.destination == undefined ? undefined : URL.parse(args.destination);
    this.sequenceNumber = args.sequenceNumber == undefined ? undefined : args.sequenceNumber;
    this.anchor = args.anchor == undefined ? undefined : args.anchor;
  }

  copy() {
    return new SyntheticTransactionRequest(this.asObject());
  }

  asObject(): SyntheticTransactionRequestArgs {
    return {
      source: this.source === undefined ? undefined : this.source.toString(),
      destination: this.destination === undefined ? undefined : this.destination.toString(),
      sequenceNumber: this.sequenceNumber === undefined ? undefined : this.sequenceNumber,
      anchor: this.anchor === undefined ? undefined : this.anchor,
    };
  }
}

export type TokenDepositArgs = {
  url?: URLArgs;
  amount?: bigint | string | number;
  txid?: Uint8Array | string;
};
export class TokenDeposit {
  public url?: URL;
  public amount?: bigint;
  public txid?: Uint8Array;

  constructor(args: TokenDepositArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.amount =
      args.amount == undefined
        ? undefined
        : typeof args.amount === "bigint"
          ? args.amount
          : BigInt(args.amount);
    this.txid =
      args.txid == undefined
        ? undefined
        : args.txid instanceof Uint8Array
          ? args.txid
          : Buffer.from(args.txid, "hex");
  }

  copy() {
    return new TokenDeposit(this.asObject());
  }

  asObject(): TokenDepositArgs {
    return {
      url: this.url === undefined ? undefined : this.url.toString(),
      amount: this.amount === undefined ? undefined : this.amount.toString(),
      txid:
        this.txid === undefined ? undefined : this.txid && Buffer.from(this.txid).toString("hex"),
    };
  }
}

export type TokenSendArgs = {
  from?: URLArgs;
  to?: (TokenDeposit | TokenDepositArgs | undefined)[];
};
export class TokenSend {
  public from?: URL;
  public to?: (TokenDeposit | undefined)[];

  constructor(args: TokenSendArgs) {
    this.from = args.from == undefined ? undefined : URL.parse(args.from);
    this.to =
      args.to == undefined
        ? undefined
        : args.to.map((v) =>
            v == undefined ? undefined : v instanceof TokenDeposit ? v : new TokenDeposit(v),
          );
  }

  copy() {
    return new TokenSend(this.asObject());
  }

  asObject(): TokenSendArgs {
    return {
      from: this.from === undefined ? undefined : this.from.toString(),
      to:
        this.to === undefined
          ? undefined
          : this.to?.map((v) => (v == undefined ? undefined : v.asObject())),
    };
  }
}

export type TransactionQueryResponseArgs = {
  type?: string;
  mainChain?: MerkleState | MerkleStateArgs;
  data?: any;
  origin?: URLArgs;
  transactionHash?: Uint8Array | string;
  txid?: TxIDArgs;
  transaction?: protocol.Transaction | protocol.TransactionArgs;
  signatures?: (protocol.Signature | protocol.SignatureArgs | undefined)[];
  status?: protocol.TransactionStatus | protocol.TransactionStatusArgs;
  produced?: (TxIDArgs | undefined)[];
  receipts?: (TxReceipt | TxReceiptArgs | undefined)[];
  signatureBooks?: (SignatureBook | SignatureBookArgs | undefined)[];
  lastBlockTime?: Date | string;
};
export class TransactionQueryResponse {
  public type?: string;
  public mainChain?: MerkleState;
  public data?: any;
  public origin?: URL;
  public transactionHash?: Uint8Array;
  public txid?: TxID;
  public transaction?: protocol.Transaction;
  public signatures?: (protocol.Signature | undefined)[];
  public status?: protocol.TransactionStatus;
  public produced?: (TxID | undefined)[];
  public receipts?: (TxReceipt | undefined)[];
  public signatureBooks?: (SignatureBook | undefined)[];
  public lastBlockTime?: Date;

  constructor(args: TransactionQueryResponseArgs) {
    this.type = args.type == undefined ? undefined : args.type;
    this.mainChain =
      args.mainChain == undefined
        ? undefined
        : args.mainChain instanceof MerkleState
          ? args.mainChain
          : new MerkleState(args.mainChain);
    this.data = args.data == undefined ? undefined : args.data;
    this.origin = args.origin == undefined ? undefined : URL.parse(args.origin);
    this.transactionHash =
      args.transactionHash == undefined
        ? undefined
        : args.transactionHash instanceof Uint8Array
          ? args.transactionHash
          : Buffer.from(args.transactionHash, "hex");
    this.txid = args.txid == undefined ? undefined : TxID.parse(args.txid);
    this.transaction =
      args.transaction == undefined
        ? undefined
        : args.transaction instanceof protocol.Transaction
          ? args.transaction
          : new protocol.Transaction(args.transaction);
    this.signatures =
      args.signatures == undefined
        ? undefined
        : args.signatures.map((v) =>
            v == undefined ? undefined : protocol.Signature.fromObject(v),
          );
    this.status =
      args.status == undefined
        ? undefined
        : args.status instanceof protocol.TransactionStatus
          ? args.status
          : new protocol.TransactionStatus(args.status);
    this.produced =
      args.produced == undefined
        ? undefined
        : args.produced.map((v) => (v == undefined ? undefined : TxID.parse(v)));
    this.receipts =
      args.receipts == undefined
        ? undefined
        : args.receipts.map((v) =>
            v == undefined ? undefined : v instanceof TxReceipt ? v : new TxReceipt(v),
          );
    this.signatureBooks =
      args.signatureBooks == undefined
        ? undefined
        : args.signatureBooks.map((v) =>
            v == undefined ? undefined : v instanceof SignatureBook ? v : new SignatureBook(v),
          );
    this.lastBlockTime =
      args.lastBlockTime == undefined
        ? undefined
        : args.lastBlockTime instanceof Date
          ? args.lastBlockTime
          : new Date(args.lastBlockTime);
  }

  copy() {
    return new TransactionQueryResponse(this.asObject());
  }

  asObject(): TransactionQueryResponseArgs {
    return {
      type: this.type === undefined ? undefined : this.type,
      mainChain: this.mainChain === undefined ? undefined : this.mainChain.asObject(),
      data: this.data === undefined ? undefined : this.data,
      origin: this.origin === undefined ? undefined : this.origin.toString(),
      transactionHash:
        this.transactionHash === undefined
          ? undefined
          : this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
      txid: this.txid === undefined ? undefined : this.txid.toString(),
      transaction: this.transaction === undefined ? undefined : this.transaction.asObject(),
      signatures:
        this.signatures === undefined
          ? undefined
          : this.signatures?.map((v) => (v == undefined ? undefined : v.asObject())),
      status: this.status === undefined ? undefined : this.status.asObject(),
      produced:
        this.produced === undefined
          ? undefined
          : this.produced?.map((v) => (v == undefined ? undefined : v.toString())),
      receipts:
        this.receipts === undefined
          ? undefined
          : this.receipts?.map((v) => (v == undefined ? undefined : v.asObject())),
      signatureBooks:
        this.signatureBooks === undefined
          ? undefined
          : this.signatureBooks?.map((v) => (v == undefined ? undefined : v.asObject())),
      lastBlockTime: this.lastBlockTime === undefined ? undefined : this.lastBlockTime,
    };
  }
}

export type TxHistoryQueryArgs = {
  url?: URLArgs;
  start?: number;
  count?: number;
  scratch?: boolean;
};
export class TxHistoryQuery {
  public url?: URL;
  public start?: number;
  public count?: number;
  public scratch?: boolean;

  constructor(args: TxHistoryQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
    this.start = args.start == undefined ? undefined : args.start;
    this.count = args.count == undefined ? undefined : args.count;
    this.scratch = args.scratch == undefined ? undefined : args.scratch;
  }

  copy() {
    return new TxHistoryQuery(this.asObject());
  }

  asObject(): TxHistoryQueryArgs {
    return {
      url: this.url === undefined ? undefined : this.url.toString(),
      start: this.start === undefined ? undefined : this.start,
      count: this.count === undefined ? undefined : this.count,
      scratch: this.scratch === undefined ? undefined : this.scratch,
    };
  }
}

export type TxReceiptArgs = {
  localBlock?: number;
  localBlockTime?: Date | string;
  directoryBlock?: number;
  majorBlock?: number;
  proof?: merkle.Receipt | merkle.ReceiptArgs;
  error?: string;
  account?: URLArgs;
  chain?: string;
};
export class TxReceipt {
  @(encodeAs.field(1, 1).uint)
  public localBlock?: number;
  @(encodeAs.field(1, 2).time)
  public localBlockTime?: Date;
  @(encodeAs.field(1, 3).uint)
  public directoryBlock?: number;
  @(encodeAs.field(1, 4).uint)
  public majorBlock?: number;
  @(encodeAs.field(1, 5).reference)
  public proof?: merkle.Receipt;
  @(encodeAs.field(1, 6).string)
  public error?: string;
  @(encodeAs.field(2).url)
  public account?: URL;
  @(encodeAs.field(3).string)
  public chain?: string;

  constructor(args: TxReceiptArgs) {
    this.localBlock = args.localBlock == undefined ? undefined : args.localBlock;
    this.localBlockTime =
      args.localBlockTime == undefined
        ? undefined
        : args.localBlockTime instanceof Date
          ? args.localBlockTime
          : new Date(args.localBlockTime);
    this.directoryBlock = args.directoryBlock == undefined ? undefined : args.directoryBlock;
    this.majorBlock = args.majorBlock == undefined ? undefined : args.majorBlock;
    this.proof =
      args.proof == undefined
        ? undefined
        : args.proof instanceof merkle.Receipt
          ? args.proof
          : new merkle.Receipt(args.proof);
    this.error = args.error == undefined ? undefined : args.error;
    this.account = args.account == undefined ? undefined : URL.parse(args.account);
    this.chain = args.chain == undefined ? undefined : args.chain;
  }

  copy() {
    return new TxReceipt(this.asObject());
  }

  asObject(): TxReceiptArgs {
    return {
      localBlock: this.localBlock === undefined ? undefined : this.localBlock,
      localBlockTime: this.localBlockTime === undefined ? undefined : this.localBlockTime,
      directoryBlock: this.directoryBlock === undefined ? undefined : this.directoryBlock,
      majorBlock: this.majorBlock === undefined ? undefined : this.majorBlock,
      proof: this.proof === undefined ? undefined : this.proof.asObject(),
      error: this.error === undefined ? undefined : this.error,
      account: this.account === undefined ? undefined : this.account.toString(),
      chain: this.chain === undefined ? undefined : this.chain,
    };
  }
}

export type TxRequestArgs = {
  checkOnly?: boolean;
  isEnvelope?: boolean;
  origin?: URLArgs;
  signer?: Signer | SignerArgs;
  signature?: Uint8Array | string;
  keyPage?: KeyPage | KeyPageArgs;
  txHash?: Uint8Array | string;
  payload?: any;
  memo?: string;
  metadata?: Uint8Array | string;
};
export class TxRequest {
  public checkOnly?: boolean;
  public isEnvelope?: boolean;
  public origin?: URL;
  public signer?: Signer;
  public signature?: Uint8Array;
  public keyPage?: KeyPage;
  public txHash?: Uint8Array;
  public payload?: any;
  public memo?: string;
  public metadata?: Uint8Array;

  constructor(args: TxRequestArgs) {
    this.checkOnly = args.checkOnly == undefined ? undefined : args.checkOnly;
    this.isEnvelope = args.isEnvelope == undefined ? undefined : args.isEnvelope;
    this.origin = args.origin == undefined ? undefined : URL.parse(args.origin);
    this.signer =
      args.signer == undefined
        ? undefined
        : args.signer instanceof Signer
          ? args.signer
          : new Signer(args.signer);
    this.signature =
      args.signature == undefined
        ? undefined
        : args.signature instanceof Uint8Array
          ? args.signature
          : Buffer.from(args.signature, "hex");
    this.keyPage =
      args.keyPage == undefined
        ? undefined
        : args.keyPage instanceof KeyPage
          ? args.keyPage
          : new KeyPage(args.keyPage);
    this.txHash =
      args.txHash == undefined
        ? undefined
        : args.txHash instanceof Uint8Array
          ? args.txHash
          : Buffer.from(args.txHash, "hex");
    this.payload = args.payload == undefined ? undefined : args.payload;
    this.memo = args.memo == undefined ? undefined : args.memo;
    this.metadata =
      args.metadata == undefined
        ? undefined
        : args.metadata instanceof Uint8Array
          ? args.metadata
          : Buffer.from(args.metadata, "hex");
  }

  copy() {
    return new TxRequest(this.asObject());
  }

  asObject(): TxRequestArgs {
    return {
      checkOnly: this.checkOnly === undefined ? undefined : this.checkOnly,
      isEnvelope: this.isEnvelope === undefined ? undefined : this.isEnvelope,
      origin: this.origin === undefined ? undefined : this.origin.toString(),
      signer: this.signer === undefined ? undefined : this.signer.asObject(),
      signature:
        this.signature === undefined
          ? undefined
          : this.signature && Buffer.from(this.signature).toString("hex"),
      keyPage: this.keyPage === undefined ? undefined : this.keyPage.asObject(),
      txHash:
        this.txHash === undefined
          ? undefined
          : this.txHash && Buffer.from(this.txHash).toString("hex"),
      payload: this.payload === undefined ? undefined : this.payload,
      memo: this.memo === undefined ? undefined : this.memo,
      metadata:
        this.metadata === undefined
          ? undefined
          : this.metadata && Buffer.from(this.metadata).toString("hex"),
    };
  }
}

export type TxResponseArgs = {
  transactionHash?: Uint8Array | string;
  txid?: TxIDArgs;
  signatureHashes?: (Uint8Array | string | undefined)[];
  simpleHash?: Uint8Array | string;
  code?: number;
  message?: string;
  delivered?: boolean;
  result?: any;
  lastBlockTime?: Date | string;
};
export class TxResponse {
  public transactionHash?: Uint8Array;
  public txid?: TxID;
  public signatureHashes?: (Uint8Array | undefined)[];
  public simpleHash?: Uint8Array;
  public code?: number;
  public message?: string;
  public delivered?: boolean;
  public result?: any;
  public lastBlockTime?: Date;

  constructor(args: TxResponseArgs) {
    this.transactionHash =
      args.transactionHash == undefined
        ? undefined
        : args.transactionHash instanceof Uint8Array
          ? args.transactionHash
          : Buffer.from(args.transactionHash, "hex");
    this.txid = args.txid == undefined ? undefined : TxID.parse(args.txid);
    this.signatureHashes =
      args.signatureHashes == undefined
        ? undefined
        : args.signatureHashes.map((v) =>
            v == undefined ? undefined : v instanceof Uint8Array ? v : Buffer.from(v, "hex"),
          );
    this.simpleHash =
      args.simpleHash == undefined
        ? undefined
        : args.simpleHash instanceof Uint8Array
          ? args.simpleHash
          : Buffer.from(args.simpleHash, "hex");
    this.code = args.code == undefined ? undefined : args.code;
    this.message = args.message == undefined ? undefined : args.message;
    this.delivered = args.delivered == undefined ? undefined : args.delivered;
    this.result = args.result == undefined ? undefined : args.result;
    this.lastBlockTime =
      args.lastBlockTime == undefined
        ? undefined
        : args.lastBlockTime instanceof Date
          ? args.lastBlockTime
          : new Date(args.lastBlockTime);
  }

  copy() {
    return new TxResponse(this.asObject());
  }

  asObject(): TxResponseArgs {
    return {
      transactionHash:
        this.transactionHash === undefined
          ? undefined
          : this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
      txid: this.txid === undefined ? undefined : this.txid.toString(),
      signatureHashes:
        this.signatureHashes === undefined
          ? undefined
          : this.signatureHashes?.map((v) =>
              v == undefined ? undefined : v && Buffer.from(v).toString("hex"),
            ),
      simpleHash:
        this.simpleHash === undefined
          ? undefined
          : this.simpleHash && Buffer.from(this.simpleHash).toString("hex"),
      code: this.code === undefined ? undefined : this.code,
      message: this.message === undefined ? undefined : this.message,
      delivered: this.delivered === undefined ? undefined : this.delivered,
      result: this.result === undefined ? undefined : this.result,
      lastBlockTime: this.lastBlockTime === undefined ? undefined : this.lastBlockTime,
    };
  }
}

export type TxnQueryArgs = {
  expand?: boolean;
  height?: number;
  scratch?: boolean;
  prove?: boolean;
  includeRemote?: boolean;
  txid?: Uint8Array | string;
  txIdUrl?: TxIDArgs;
  wait?: number;
  ignorePending?: boolean;
};
export class TxnQuery {
  public expand?: boolean;
  public height?: number;
  public scratch?: boolean;
  public prove?: boolean;
  public includeRemote?: boolean;
  public txid?: Uint8Array;
  public txIdUrl?: TxID;
  public wait?: number;
  public ignorePending?: boolean;

  constructor(args: TxnQueryArgs) {
    this.expand = args.expand == undefined ? undefined : args.expand;
    this.height = args.height == undefined ? undefined : args.height;
    this.scratch = args.scratch == undefined ? undefined : args.scratch;
    this.prove = args.prove == undefined ? undefined : args.prove;
    this.includeRemote = args.includeRemote == undefined ? undefined : args.includeRemote;
    this.txid =
      args.txid == undefined
        ? undefined
        : args.txid instanceof Uint8Array
          ? args.txid
          : Buffer.from(args.txid, "hex");
    this.txIdUrl = args.txIdUrl == undefined ? undefined : TxID.parse(args.txIdUrl);
    this.wait = args.wait == undefined ? undefined : args.wait;
    this.ignorePending = args.ignorePending == undefined ? undefined : args.ignorePending;
  }

  copy() {
    return new TxnQuery(this.asObject());
  }

  asObject(): TxnQueryArgs {
    return {
      expand: this.expand === undefined ? undefined : this.expand,
      height: this.height === undefined ? undefined : this.height,
      scratch: this.scratch === undefined ? undefined : this.scratch,
      prove: this.prove === undefined ? undefined : this.prove,
      includeRemote: this.includeRemote === undefined ? undefined : this.includeRemote,
      txid:
        this.txid === undefined ? undefined : this.txid && Buffer.from(this.txid).toString("hex"),
      txIdUrl: this.txIdUrl === undefined ? undefined : this.txIdUrl.toString(),
      wait: this.wait === undefined ? undefined : this.wait,
      ignorePending: this.ignorePending === undefined ? undefined : this.ignorePending,
    };
  }
}

export type UrlQueryArgs = {
  url?: URLArgs;
};
export class UrlQuery {
  public url?: URL;

  constructor(args: UrlQueryArgs) {
    this.url = args.url == undefined ? undefined : URL.parse(args.url);
  }

  copy() {
    return new UrlQuery(this.asObject());
  }

  asObject(): UrlQueryArgs {
    return {
      url: this.url === undefined ? undefined : this.url.toString(),
    };
  }
}

export type VersionResponseArgs = {
  version?: string;
  commit?: string;
  versionIsKnown?: boolean;
  isTestNet?: boolean;
};
export class VersionResponse {
  public version?: string;
  public commit?: string;
  public versionIsKnown?: boolean;
  public isTestNet?: boolean;

  constructor(args: VersionResponseArgs) {
    this.version = args.version == undefined ? undefined : args.version;
    this.commit = args.commit == undefined ? undefined : args.commit;
    this.versionIsKnown = args.versionIsKnown == undefined ? undefined : args.versionIsKnown;
    this.isTestNet = args.isTestNet == undefined ? undefined : args.isTestNet;
  }

  copy() {
    return new VersionResponse(this.asObject());
  }

  asObject(): VersionResponseArgs {
    return {
      version: this.version === undefined ? undefined : this.version,
      commit: this.commit === undefined ? undefined : this.commit,
      versionIsKnown: this.versionIsKnown === undefined ? undefined : this.versionIsKnown,
      isTestNet: this.isTestNet === undefined ? undefined : this.isTestNet,
    };
  }
}
