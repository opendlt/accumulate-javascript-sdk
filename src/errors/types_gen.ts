import { Status } from ".";
import { encodeAs } from "../encoding";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */

export namespace CallSite {
  export type Args = {
    funcName?: string;
    file?: string;
    line?: number;
  };
}
export class CallSite {
  @encodeAs.field(1).string
  public funcName?: string;
  @encodeAs.field(2).string
  public file?: string;
  @encodeAs.field(3).int
  public line?: number;

  constructor(args: CallSite.Args) {
    this.funcName = args.funcName == undefined ? undefined : args.funcName;
    this.file = args.file == undefined ? undefined : args.file;
    this.line = args.line == undefined ? undefined : args.line;
  }

  copy() {
    return new CallSite(this);
  }

  asObject(): CallSite.Args {
    return {
      funcName: this.funcName && this.funcName,
      file: this.file && this.file,
      line: this.line && this.line,
    };
  }
}

export namespace Error {
  export type Args = {
    message?: string;
    code?: Status.Args;
    cause?: Error | Error.Args;
    callStack?: (CallSite | CallSite.Args)[];
  };
}
export class Error {
  @encodeAs.field(1).string
  public message?: string;
  @encodeAs.field(2).enum
  public code?: Status;
  @encodeAs.field(3).reference
  public cause?: Error;
  @encodeAs.field(4).repeatable.reference
  public callStack?: CallSite[];

  constructor(args: Error.Args) {
    this.message = args.message == undefined ? undefined : args.message;
    this.code = args.code == undefined ? undefined : Status.fromObject(args.code);
    this.cause =
      args.cause == undefined
        ? undefined
        : args.cause instanceof Error
        ? args.cause
        : new Error(args.cause);
    this.callStack =
      args.callStack == undefined
        ? undefined
        : args.callStack.map((v) => (v instanceof CallSite ? v : new CallSite(v)));
  }

  copy() {
    return new Error(this);
  }

  asObject(): Error.Args {
    return {
      message: this.message && this.message,
      code: this.code && this.code.toString(),
      cause: this.cause && this.cause.asObject(),
      callStack: this.callStack && this.callStack?.map((v) => v.asObject()),
    };
  }
}
