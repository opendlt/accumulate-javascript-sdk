import { Message, MessageArgs, MessageType } from ".";
import { core as protocol, TxID, TxIDArgs, URL, URLArgs } from "..";
import { encodeAs } from "../encoding";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */

export type BlockAnchorArgs = {
  signature?: protocol.KeySignature | protocol.KeySignatureArgs;
  anchor?: Message | MessageArgs;
};
export type BlockAnchorArgsWithType = BlockAnchorArgs & {
  type: MessageType.BlockAnchor | "blockAnchor";
};
export class BlockAnchor {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = MessageType.BlockAnchor;
  @encodeAs.field(2).union
  public signature?: protocol.KeySignature;
  @encodeAs.field(3).union
  public anchor?: Message;

  constructor(args: BlockAnchorArgs) {
    this.signature =
      args.signature == undefined ? undefined : protocol.KeySignature.fromObject(args.signature);
    this.anchor = args.anchor == undefined ? undefined : Message.fromObject(args.anchor);
  }

  copy() {
    return new BlockAnchor(this.asObject());
  }

  asObject(): BlockAnchorArgsWithType {
    return {
      type: "blockAnchor",
      signature: this.signature && this.signature.asObject(),
      anchor: this.anchor && this.anchor.asObject(),
    };
  }
}

export type CreditPaymentArgs = {
  paid?: protocol.FeeArgs;
  payer?: URLArgs;
  initiator?: boolean;
  txID?: TxIDArgs;
  cause?: TxIDArgs;
};
export type CreditPaymentArgsWithType = CreditPaymentArgs & {
  type: MessageType.CreditPayment | "creditPayment";
};
export class CreditPayment {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = MessageType.CreditPayment;
  @encodeAs.field(2).enum
  public paid?: protocol.Fee;
  @encodeAs.field(3).url
  public payer?: URL;
  @encodeAs.field(4).bool
  public initiator?: boolean;
  @encodeAs.field(5).txid
  public txID?: TxID;
  @encodeAs.field(6).txid
  public cause?: TxID;

  constructor(args: CreditPaymentArgs) {
    this.paid = args.paid == undefined ? undefined : protocol.Fee.fromObject(args.paid);
    this.payer = args.payer == undefined ? undefined : URL.parse(args.payer);
    this.initiator = args.initiator == undefined ? undefined : args.initiator;
    this.txID = args.txID == undefined ? undefined : TxID.parse(args.txID);
    this.cause = args.cause == undefined ? undefined : TxID.parse(args.cause);
  }

  copy() {
    return new CreditPayment(this.asObject());
  }

  asObject(): CreditPaymentArgsWithType {
    return {
      type: "creditPayment",
      paid: this.paid && protocol.Fee.getName(this.paid),
      payer: this.payer && this.payer.toString(),
      initiator: this.initiator && this.initiator,
      txID: this.txID && this.txID.toString(),
      cause: this.cause && this.cause.toString(),
    };
  }
}

export type EnvelopeArgs = {
  signatures?: (protocol.Signature | protocol.SignatureArgs)[];
  txHash?: Uint8Array | string;
  transaction?: (protocol.Transaction | protocol.TransactionArgs)[];
  messages?: (Message | MessageArgs)[];
};
export class Envelope {
  @encodeAs.field(1).repeatable.union
  public signatures?: protocol.Signature[];
  @encodeAs.field(2).bytes
  public txHash?: Uint8Array;
  @encodeAs.field(3).repeatable.reference
  public transaction?: protocol.Transaction[];
  @encodeAs.field(4).repeatable.union
  public messages?: Message[];

  constructor(args: EnvelopeArgs) {
    this.signatures =
      args.signatures == undefined
        ? undefined
        : args.signatures.map((v) => protocol.Signature.fromObject(v));
    this.txHash =
      args.txHash == undefined
        ? undefined
        : args.txHash instanceof Uint8Array
        ? args.txHash
        : Buffer.from(args.txHash, "hex");
    this.transaction =
      args.transaction == undefined
        ? undefined
        : args.transaction.map((v) =>
            v instanceof protocol.Transaction ? v : new protocol.Transaction(v)
          );
    this.messages =
      args.messages == undefined ? undefined : args.messages.map((v) => Message.fromObject(v));
  }

  copy() {
    return new Envelope(this.asObject());
  }

  asObject(): EnvelopeArgs {
    return {
      signatures: this.signatures && this.signatures?.map((v) => v.asObject()),
      txHash: this.txHash && Buffer.from(this.txHash).toString("hex"),
      transaction: this.transaction && this.transaction?.map((v) => v.asObject()),
      messages: this.messages && this.messages?.map((v) => v.asObject()),
    };
  }
}

export type SequencedMessageArgs = {
  message?: Message | MessageArgs;
  source?: URLArgs;
  destination?: URLArgs;
  number?: number;
};
export type SequencedMessageArgsWithType = SequencedMessageArgs & {
  type: MessageType.Sequenced | "sequenced";
};
export class SequencedMessage {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = MessageType.Sequenced;
  @encodeAs.field(2).union
  public message?: Message;
  @encodeAs.field(3).url
  public source?: URL;
  @encodeAs.field(4).url
  public destination?: URL;
  @encodeAs.field(5).uint
  public number?: number;

  constructor(args: SequencedMessageArgs) {
    this.message = args.message == undefined ? undefined : Message.fromObject(args.message);
    this.source = args.source == undefined ? undefined : URL.parse(args.source);
    this.destination = args.destination == undefined ? undefined : URL.parse(args.destination);
    this.number = args.number == undefined ? undefined : args.number;
  }

  copy() {
    return new SequencedMessage(this.asObject());
  }

  asObject(): SequencedMessageArgsWithType {
    return {
      type: "sequenced",
      message: this.message && this.message.asObject(),
      source: this.source && this.source.toString(),
      destination: this.destination && this.destination.toString(),
      number: this.number && this.number,
    };
  }
}

export type SignatureMessageArgs = {
  signature?: protocol.Signature | protocol.SignatureArgs;
  txID?: TxIDArgs;
};
export type SignatureMessageArgsWithType = SignatureMessageArgs & {
  type: MessageType.Signature | "signature";
};
export class SignatureMessage {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = MessageType.Signature;
  @encodeAs.field(2).union
  public signature?: protocol.Signature;
  @encodeAs.field(3).txid
  public txID?: TxID;

  constructor(args: SignatureMessageArgs) {
    this.signature =
      args.signature == undefined ? undefined : protocol.Signature.fromObject(args.signature);
    this.txID = args.txID == undefined ? undefined : TxID.parse(args.txID);
  }

  copy() {
    return new SignatureMessage(this.asObject());
  }

  asObject(): SignatureMessageArgsWithType {
    return {
      type: "signature",
      signature: this.signature && this.signature.asObject(),
      txID: this.txID && this.txID.toString(),
    };
  }
}

export type SignatureRequestArgs = {
  authority?: URLArgs;
  txID?: TxIDArgs;
  cause?: TxIDArgs;
};
export type SignatureRequestArgsWithType = SignatureRequestArgs & {
  type: MessageType.SignatureRequest | "signatureRequest";
};
export class SignatureRequest {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = MessageType.SignatureRequest;
  @encodeAs.field(2).url
  public authority?: URL;
  @encodeAs.field(3).txid
  public txID?: TxID;
  @encodeAs.field(4).txid
  public cause?: TxID;

  constructor(args: SignatureRequestArgs) {
    this.authority = args.authority == undefined ? undefined : URL.parse(args.authority);
    this.txID = args.txID == undefined ? undefined : TxID.parse(args.txID);
    this.cause = args.cause == undefined ? undefined : TxID.parse(args.cause);
  }

  copy() {
    return new SignatureRequest(this.asObject());
  }

  asObject(): SignatureRequestArgsWithType {
    return {
      type: "signatureRequest",
      authority: this.authority && this.authority.toString(),
      txID: this.txID && this.txID.toString(),
      cause: this.cause && this.cause.toString(),
    };
  }
}

export type SyntheticMessageArgs = {
  message?: Message | MessageArgs;
  signature?: protocol.KeySignature | protocol.KeySignatureArgs;
  proof?: protocol.AnnotatedReceipt | protocol.AnnotatedReceiptArgs;
};
export type SyntheticMessageArgsWithType = SyntheticMessageArgs & {
  type: MessageType.Synthetic | "synthetic";
};
export class SyntheticMessage {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = MessageType.Synthetic;
  @encodeAs.field(2).union
  public message?: Message;
  @encodeAs.field(3).union
  public signature?: protocol.KeySignature;
  @encodeAs.field(4).reference
  public proof?: protocol.AnnotatedReceipt;

  constructor(args: SyntheticMessageArgs) {
    this.message = args.message == undefined ? undefined : Message.fromObject(args.message);
    this.signature =
      args.signature == undefined ? undefined : protocol.KeySignature.fromObject(args.signature);
    this.proof =
      args.proof == undefined
        ? undefined
        : args.proof instanceof protocol.AnnotatedReceipt
        ? args.proof
        : new protocol.AnnotatedReceipt(args.proof);
  }

  copy() {
    return new SyntheticMessage(this.asObject());
  }

  asObject(): SyntheticMessageArgsWithType {
    return {
      type: "synthetic",
      message: this.message && this.message.asObject(),
      signature: this.signature && this.signature.asObject(),
      proof: this.proof && this.proof.asObject(),
    };
  }
}

export type TransactionMessageArgs = {
  transaction?: protocol.Transaction | protocol.TransactionArgs;
};
export type TransactionMessageArgsWithType = TransactionMessageArgs & {
  type: MessageType.Transaction | "transaction";
};
export class TransactionMessage {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = MessageType.Transaction;
  @encodeAs.field(2).reference
  public transaction?: protocol.Transaction;

  constructor(args: TransactionMessageArgs) {
    this.transaction =
      args.transaction == undefined
        ? undefined
        : args.transaction instanceof protocol.Transaction
        ? args.transaction
        : new protocol.Transaction(args.transaction);
  }

  copy() {
    return new TransactionMessage(this.asObject());
  }

  asObject(): TransactionMessageArgsWithType {
    return {
      type: "transaction",
      transaction: this.transaction && this.transaction.asObject(),
    };
  }
}
