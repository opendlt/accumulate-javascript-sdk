import { MessageType } from "./enums_gen.js";

// Forward declarations to avoid circular dependency
type Message = any;
type MessageArgs = any;

// Lazy loader to avoid circular dependency

let _MessageClass: any;
function getMessageClass() {
  if (!_MessageClass) {
    // Fallback for Jest compatibility
    _MessageClass = {
      fromObject: (obj: any) => obj
    };
  }
  return _MessageClass;
}
import { AccumulateTxID as TxID, TxIDArgs } from "../address/txid.js";
import { AccumulateURL as URL, URLArgs } from "../address/url.js";
import { Buffer } from "../common/buffer.js";
import * as protocol from "../core/index.js";
import { encodeAs } from "../encoding/index.js";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */

export type BadSyntheticMessageArgs = {
  message?: Message | MessageArgs;
  signature?: protocol.KeySignature | protocol.KeySignatureArgs;
  proof?: protocol.AnnotatedReceipt | protocol.AnnotatedReceiptArgs;
};
export type BadSyntheticMessageArgsWithType = BadSyntheticMessageArgs & {
  type: MessageType.BadSynthetic | "badSynthetic";
};
export class BadSyntheticMessage {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.BadSynthetic;
  @(encodeAs.field(2).union)
  public message?: Message;
  @(encodeAs.field(3).union)
  public signature?: protocol.KeySignature;
  @(encodeAs.field(4).reference)
  public proof?: protocol.AnnotatedReceipt;

  constructor(args: BadSyntheticMessageArgs) {
    this.message = args.message == undefined ? undefined : getMessageClass().fromObject(args.message);
    this.signature =
      args.signature == undefined ? undefined : protocol.KeySignature.fromObject(args.signature);
    this.proof =
      args.proof == undefined
        ? undefined
        : args.proof instanceof protocol.AnnotatedReceipt
          ? args.proof
          : new protocol.AnnotatedReceipt(args.proof);
  }

  copy() {
    return new BadSyntheticMessage(this.asObject());
  }

  asObject(): BadSyntheticMessageArgsWithType {
    return {
      type: "badSynthetic",
      message: this.message === undefined ? undefined : this.message.asObject(),
      signature: this.signature === undefined ? undefined : this.signature.asObject(),
      proof: this.proof === undefined ? undefined : this.proof.asObject(),
    };
  }
}

export type BlockAnchorArgs = {
  signature?: protocol.KeySignature | protocol.KeySignatureArgs;
  anchor?: Message | MessageArgs;
};
export type BlockAnchorArgsWithType = BlockAnchorArgs & {
  type: MessageType.BlockAnchor | "blockAnchor";
};
export class BlockAnchor {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.BlockAnchor;
  @(encodeAs.field(2).union)
  public signature?: protocol.KeySignature;
  @(encodeAs.field(3).union)
  public anchor?: Message;

  constructor(args: BlockAnchorArgs) {
    this.signature =
      args.signature == undefined ? undefined : protocol.KeySignature.fromObject(args.signature);
    this.anchor = args.anchor == undefined ? undefined : getMessageClass().fromObject(args.anchor);
  }

  copy() {
    return new BlockAnchor(this.asObject());
  }

  asObject(): BlockAnchorArgsWithType {
    return {
      type: "blockAnchor",
      signature: this.signature === undefined ? undefined : this.signature.asObject(),
      anchor: this.anchor === undefined ? undefined : this.anchor.asObject(),
    };
  }
}

export type CreditPaymentArgs = {
  paid?: protocol.FeeArgs;
  payer?: URLArgs;
  initiator?: boolean;
  txID?: TxIDArgs;
  cause?: TxIDArgs;
};
export type CreditPaymentArgsWithType = CreditPaymentArgs & {
  type: MessageType.CreditPayment | "creditPayment";
};
export class CreditPayment {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.CreditPayment;
  @(encodeAs.field(2).enum)
  public paid?: protocol.Fee;
  @(encodeAs.field(3).url)
  public payer?: URL;
  @(encodeAs.field(4).bool)
  public initiator?: boolean;
  @(encodeAs.field(5).txid)
  public txID?: TxID;
  @(encodeAs.field(6).txid)
  public cause?: TxID;

  constructor(args: CreditPaymentArgs) {
    this.paid = args.paid == undefined ? undefined : protocol.Fee.fromObject(args.paid);
    this.payer = args.payer == undefined ? undefined : URL.parse(args.payer);
    this.initiator = args.initiator == undefined ? undefined : args.initiator;
    this.txID = args.txID == undefined ? undefined : TxID.parse(args.txID);
    this.cause = args.cause == undefined ? undefined : TxID.parse(args.cause);
  }

  copy() {
    return new CreditPayment(this.asObject());
  }

  asObject(): CreditPaymentArgsWithType {
    return {
      type: "creditPayment",
      paid: this.paid === undefined ? undefined : protocol.Fee.getName(this.paid),
      payer: this.payer === undefined ? undefined : this.payer.toString(),
      initiator: this.initiator === undefined ? undefined : this.initiator,
      txID: this.txID === undefined ? undefined : this.txID.toString(),
      cause: this.cause === undefined ? undefined : this.cause.toString(),
    };
  }
}

export type DidUpdateExecutorVersionArgs = {
  partition?: string;
  version?: protocol.ExecutorVersionArgs;
};
export type DidUpdateExecutorVersionArgsWithType = DidUpdateExecutorVersionArgs & {
  type: MessageType.DidUpdateExecutorVersion | "didUpdateExecutorVersion";
};
export class DidUpdateExecutorVersion {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.DidUpdateExecutorVersion;
  @(encodeAs.field(2).string)
  public partition?: string;
  @(encodeAs.field(3).enum)
  public version?: protocol.ExecutorVersion;

  constructor(args: DidUpdateExecutorVersionArgs) {
    this.partition = args.partition == undefined ? undefined : args.partition;
    this.version =
      args.version == undefined ? undefined : protocol.ExecutorVersion.fromObject(args.version);
  }

  copy() {
    return new DidUpdateExecutorVersion(this.asObject());
  }

  asObject(): DidUpdateExecutorVersionArgsWithType {
    return {
      type: "didUpdateExecutorVersion",
      partition: this.partition === undefined ? undefined : this.partition,
      version:
        this.version === undefined ? undefined : protocol.ExecutorVersion.getName(this.version),
    };
  }
}

export type EnvelopeArgs = {
  signatures?: (protocol.Signature | protocol.SignatureArgs | undefined)[];
  txHash?: Uint8Array | string;
  transaction?: (protocol.Transaction | protocol.TransactionArgs | undefined)[];
  messages?: (Message | MessageArgs | undefined)[];
};
export class Envelope {
  @(encodeAs.field(1).repeatable.union)
  public signatures?: (protocol.Signature | undefined)[];
  @(encodeAs.field(2).bytes)
  public txHash?: Uint8Array;
  @(encodeAs.field(3).repeatable.reference)
  public transaction?: (protocol.Transaction | undefined)[];
  @(encodeAs.field(4).repeatable.union)
  public messages?: (Message | undefined)[];

  constructor(args: EnvelopeArgs) {
    this.signatures =
      args.signatures == undefined
        ? undefined
        : args.signatures.map((v) =>
            v == undefined ? undefined : protocol.Signature.fromObject(v),
          );
    this.txHash =
      args.txHash == undefined
        ? undefined
        : args.txHash instanceof Uint8Array
          ? args.txHash
          : Buffer.from(args.txHash, "hex");
    this.transaction =
      args.transaction == undefined
        ? undefined
        : args.transaction.map((v) =>
            v == undefined
              ? undefined
              : v instanceof protocol.Transaction
                ? v
                : new protocol.Transaction(v),
          );
    this.messages =
      args.messages == undefined
        ? undefined
        : args.messages.map((v) => (v == undefined ? undefined : getMessageClass().fromObject(v)));
  }

  copy() {
    return new Envelope(this.asObject());
  }

  asObject(): EnvelopeArgs {
    return {
      signatures:
        this.signatures === undefined
          ? undefined
          : this.signatures?.map((v) => (v == undefined ? undefined : v.asObject())),
      txHash:
        this.txHash === undefined
          ? undefined
          : this.txHash && Buffer.from(this.txHash).toString("hex"),
      transaction:
        this.transaction === undefined
          ? undefined
          : this.transaction?.map((v) => (v == undefined ? undefined : v.asObject())),
      messages:
        this.messages === undefined
          ? undefined
          : this.messages?.map((v) => (v == undefined ? undefined : v.asObject())),
    };
  }
}

export type MakeMajorBlockArgs = {
  majorBlockIndex?: number;
  minorBlockIndex?: number;
  majorBlockTime?: Date | string;
};
export type MakeMajorBlockArgsWithType = MakeMajorBlockArgs & {
  type: MessageType.MakeMajorBlock | "makeMajorBlock";
};
export class MakeMajorBlock {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.MakeMajorBlock;
  @(encodeAs.field(2).uint)
  public majorBlockIndex?: number;
  @(encodeAs.field(3).uint)
  public minorBlockIndex?: number;
  @(encodeAs.field(4).time)
  public majorBlockTime?: Date;

  constructor(args: MakeMajorBlockArgs) {
    this.majorBlockIndex = args.majorBlockIndex == undefined ? undefined : args.majorBlockIndex;
    this.minorBlockIndex = args.minorBlockIndex == undefined ? undefined : args.minorBlockIndex;
    this.majorBlockTime =
      args.majorBlockTime == undefined
        ? undefined
        : args.majorBlockTime instanceof Date
          ? args.majorBlockTime
          : new Date(args.majorBlockTime);
  }

  copy() {
    return new MakeMajorBlock(this.asObject());
  }

  asObject(): MakeMajorBlockArgsWithType {
    return {
      type: "makeMajorBlock",
      majorBlockIndex: this.majorBlockIndex === undefined ? undefined : this.majorBlockIndex,
      minorBlockIndex: this.minorBlockIndex === undefined ? undefined : this.minorBlockIndex,
      majorBlockTime: this.majorBlockTime === undefined ? undefined : this.majorBlockTime,
    };
  }
}

export type NetworkUpdateArgs = {
  accounts?: (protocol.NetworkAccountUpdate | protocol.NetworkAccountUpdateArgs | undefined)[];
};
export type NetworkUpdateArgsWithType = NetworkUpdateArgs & {
  type: MessageType.NetworkUpdate | "networkUpdate";
};
export class NetworkUpdate {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.NetworkUpdate;
  @(encodeAs.field(2).repeatable.reference)
  public accounts?: (protocol.NetworkAccountUpdate | undefined)[];

  constructor(args: NetworkUpdateArgs) {
    this.accounts =
      args.accounts == undefined
        ? undefined
        : args.accounts.map((v) =>
            v == undefined
              ? undefined
              : v instanceof protocol.NetworkAccountUpdate
                ? v
                : new protocol.NetworkAccountUpdate(v),
          );
  }

  copy() {
    return new NetworkUpdate(this.asObject());
  }

  asObject(): NetworkUpdateArgsWithType {
    return {
      type: "networkUpdate",
      accounts:
        this.accounts === undefined
          ? undefined
          : this.accounts?.map((v) => (v == undefined ? undefined : v.asObject())),
    };
  }
}

export type SequencedMessageArgs = {
  message?: Message | MessageArgs;
  source?: URLArgs;
  destination?: URLArgs;
  number?: number;
};
export type SequencedMessageArgsWithType = SequencedMessageArgs & {
  type: MessageType.Sequenced | "sequenced";
};
export class SequencedMessage {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.Sequenced;
  @(encodeAs.field(2).union)
  public message?: Message;
  @(encodeAs.field(3).url)
  public source?: URL;
  @(encodeAs.field(4).url)
  public destination?: URL;
  @(encodeAs.field(5).uint)
  public number?: number;

  constructor(args: SequencedMessageArgs) {
    this.message = args.message == undefined ? undefined : getMessageClass().fromObject(args.message);
    this.source = args.source == undefined ? undefined : URL.parse(args.source);
    this.destination = args.destination == undefined ? undefined : URL.parse(args.destination);
    this.number = args.number == undefined ? undefined : args.number;
  }

  copy() {
    return new SequencedMessage(this.asObject());
  }

  asObject(): SequencedMessageArgsWithType {
    return {
      type: "sequenced",
      message: this.message === undefined ? undefined : this.message.asObject(),
      source: this.source === undefined ? undefined : this.source.toString(),
      destination: this.destination === undefined ? undefined : this.destination.toString(),
      number: this.number === undefined ? undefined : this.number,
    };
  }
}

export type SignatureMessageArgs = {
  signature?: protocol.Signature | protocol.SignatureArgs;
  txID?: TxIDArgs;
};
export type SignatureMessageArgsWithType = SignatureMessageArgs & {
  type: MessageType.Signature | "signature";
};
export class SignatureMessage {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.Signature;
  @(encodeAs.field(2).union)
  public signature?: protocol.Signature;
  @(encodeAs.field(3).txid)
  public txID?: TxID;

  constructor(args: SignatureMessageArgs) {
    this.signature =
      args.signature == undefined ? undefined : protocol.Signature.fromObject(args.signature);
    this.txID = args.txID == undefined ? undefined : TxID.parse(args.txID);
  }

  copy() {
    return new SignatureMessage(this.asObject());
  }

  asObject(): SignatureMessageArgsWithType {
    return {
      type: "signature",
      signature: this.signature === undefined ? undefined : this.signature.asObject(),
      txID: this.txID === undefined ? undefined : this.txID.toString(),
    };
  }
}

export type SignatureRequestArgs = {
  authority?: URLArgs;
  txID?: TxIDArgs;
  cause?: TxIDArgs;
};
export type SignatureRequestArgsWithType = SignatureRequestArgs & {
  type: MessageType.SignatureRequest | "signatureRequest";
};
export class SignatureRequest {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.SignatureRequest;
  @(encodeAs.field(2).url)
  public authority?: URL;
  @(encodeAs.field(3).txid)
  public txID?: TxID;
  @(encodeAs.field(4).txid)
  public cause?: TxID;

  constructor(args: SignatureRequestArgs) {
    this.authority = args.authority == undefined ? undefined : URL.parse(args.authority);
    this.txID = args.txID == undefined ? undefined : TxID.parse(args.txID);
    this.cause = args.cause == undefined ? undefined : TxID.parse(args.cause);
  }

  copy() {
    return new SignatureRequest(this.asObject());
  }

  asObject(): SignatureRequestArgsWithType {
    return {
      type: "signatureRequest",
      authority: this.authority === undefined ? undefined : this.authority.toString(),
      txID: this.txID === undefined ? undefined : this.txID.toString(),
      cause: this.cause === undefined ? undefined : this.cause.toString(),
    };
  }
}

export type SynthFieldsArgs = {
  message?: Message | MessageArgs;
  signature?: protocol.KeySignature | protocol.KeySignatureArgs;
  proof?: protocol.AnnotatedReceipt | protocol.AnnotatedReceiptArgs;
};
export class SynthFields {
  public message?: Message;
  public signature?: protocol.KeySignature;
  public proof?: protocol.AnnotatedReceipt;

  constructor(args: SynthFieldsArgs) {
    this.message = args.message == undefined ? undefined : getMessageClass().fromObject(args.message);
    this.signature =
      args.signature == undefined ? undefined : protocol.KeySignature.fromObject(args.signature);
    this.proof =
      args.proof == undefined
        ? undefined
        : args.proof instanceof protocol.AnnotatedReceipt
          ? args.proof
          : new protocol.AnnotatedReceipt(args.proof);
  }

  copy() {
    return new SynthFields(this.asObject());
  }

  asObject(): SynthFieldsArgs {
    return {
      message: this.message === undefined ? undefined : this.message.asObject(),
      signature: this.signature === undefined ? undefined : this.signature.asObject(),
      proof: this.proof === undefined ? undefined : this.proof.asObject(),
    };
  }
}

export type SyntheticMessageArgs = {
  message?: Message | MessageArgs;
  signature?: protocol.KeySignature | protocol.KeySignatureArgs;
  proof?: protocol.AnnotatedReceipt | protocol.AnnotatedReceiptArgs;
};
export type SyntheticMessageArgsWithType = SyntheticMessageArgs & {
  type: MessageType.Synthetic | "synthetic";
};
export class SyntheticMessage {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.Synthetic;
  @(encodeAs.field(2).union)
  public message?: Message;
  @(encodeAs.field(3).union)
  public signature?: protocol.KeySignature;
  @(encodeAs.field(4).reference)
  public proof?: protocol.AnnotatedReceipt;

  constructor(args: SyntheticMessageArgs) {
    this.message = args.message == undefined ? undefined : getMessageClass().fromObject(args.message);
    this.signature =
      args.signature == undefined ? undefined : protocol.KeySignature.fromObject(args.signature);
    this.proof =
      args.proof == undefined
        ? undefined
        : args.proof instanceof protocol.AnnotatedReceipt
          ? args.proof
          : new protocol.AnnotatedReceipt(args.proof);
  }

  copy() {
    return new SyntheticMessage(this.asObject());
  }

  asObject(): SyntheticMessageArgsWithType {
    return {
      type: "synthetic",
      message: this.message === undefined ? undefined : this.message.asObject(),
      signature: this.signature === undefined ? undefined : this.signature.asObject(),
      proof: this.proof === undefined ? undefined : this.proof.asObject(),
    };
  }
}

export type TransactionMessageArgs = {
  transaction?: protocol.Transaction | protocol.TransactionArgs;
};
export type TransactionMessageArgsWithType = TransactionMessageArgs & {
  type: MessageType.Transaction | "transaction";
};
export class TransactionMessage {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.Transaction;
  @(encodeAs.field(2).reference)
  public transaction?: protocol.Transaction;

  constructor(args: TransactionMessageArgs) {
    this.transaction =
      args.transaction == undefined
        ? undefined
        : args.transaction instanceof protocol.Transaction
          ? args.transaction
          : new protocol.Transaction(args.transaction);
  }

  copy() {
    return new TransactionMessage(this.asObject());
  }

  asObject(): TransactionMessageArgsWithType {
    return {
      type: "transaction",
      transaction: this.transaction === undefined ? undefined : this.transaction.asObject(),
    };
  }
}
