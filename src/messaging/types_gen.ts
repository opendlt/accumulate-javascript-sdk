import { Message, MessageType } from ".";
import * as protocol from "../core";
import { encodeAs } from "../encoding";
import { TxID, URL } from "../url";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */

export namespace BlockAnchor {
  export type Args = {
    signature?: protocol.KeySignature | protocol.KeySignature.Args;
    anchor?: Message | Message.Args;
  };
  export type ArgsWithType = Args & { type: MessageType.BlockAnchor | "blockAnchor" };
}
export class BlockAnchor {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = MessageType.BlockAnchor;
  @encodeAs.field(2).union
  public signature?: protocol.KeySignature;
  @encodeAs.field(3).union
  public anchor?: Message;

  constructor(args: BlockAnchor.Args) {
    this.signature =
      args.signature == undefined ? undefined : protocol.KeySignature.fromObject(args.signature);
    this.anchor = args.anchor == undefined ? undefined : Message.fromObject(args.anchor);
  }

  copy() {
    return new BlockAnchor(this.asObject());
  }

  asObject(): BlockAnchor.ArgsWithType {
    return {
      type: "blockAnchor",
      signature: this.signature && this.signature.asObject(),
      anchor: this.anchor && this.anchor.asObject(),
    };
  }
}

export namespace CreditPayment {
  export type Args = {
    paid?: protocol.Fee.Args;
    payer?: URL | string;
    initiator?: boolean;
    txID?: TxID | string;
    cause?: TxID | string;
  };
  export type ArgsWithType = Args & { type: MessageType.CreditPayment | "creditPayment" };
}
export class CreditPayment {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = MessageType.CreditPayment;
  @encodeAs.field(2).enum
  public paid?: protocol.Fee;
  @encodeAs.field(3).url
  public payer?: URL;
  @encodeAs.field(4).bool
  public initiator?: boolean;
  @encodeAs.field(5).txid
  public txID?: TxID;
  @encodeAs.field(6).txid
  public cause?: TxID;

  constructor(args: CreditPayment.Args) {
    this.paid = args.paid == undefined ? undefined : protocol.Fee.fromObject(args.paid);
    this.payer =
      args.payer == undefined
        ? undefined
        : args.payer instanceof URL
        ? args.payer
        : new URL(args.payer);
    this.initiator = args.initiator == undefined ? undefined : args.initiator;
    this.txID =
      args.txID == undefined
        ? undefined
        : args.txID instanceof TxID
        ? args.txID
        : new TxID(args.txID);
    this.cause =
      args.cause == undefined
        ? undefined
        : args.cause instanceof TxID
        ? args.cause
        : new TxID(args.cause);
  }

  copy() {
    return new CreditPayment(this.asObject());
  }

  asObject(): CreditPayment.ArgsWithType {
    return {
      type: "creditPayment",
      paid: this.paid && protocol.Fee.getName(this.paid),
      payer: this.payer && this.payer.toString(),
      initiator: this.initiator && this.initiator,
      txID: this.txID && this.txID.toString(),
      cause: this.cause && this.cause.toString(),
    };
  }
}

export namespace Envelope {
  export type Args = {
    signatures?: (protocol.Signature | protocol.Signature.Args)[];
    txHash?: Uint8Array | string;
    transaction?: (protocol.Transaction | protocol.Transaction.Args)[];
    messages?: (Message | Message.Args)[];
  };
}
export class Envelope {
  @encodeAs.field(1).repeatable.union
  public signatures?: protocol.Signature[];
  @encodeAs.field(2).bytes
  public txHash?: Uint8Array;
  @encodeAs.field(3).repeatable.reference
  public transaction?: protocol.Transaction[];
  @encodeAs.field(4).repeatable.union
  public messages?: Message[];

  constructor(args: Envelope.Args) {
    this.signatures =
      args.signatures == undefined
        ? undefined
        : args.signatures.map((v) => protocol.Signature.fromObject(v));
    this.txHash =
      args.txHash == undefined
        ? undefined
        : args.txHash instanceof Uint8Array
        ? args.txHash
        : Buffer.from(args.txHash, "hex");
    this.transaction =
      args.transaction == undefined
        ? undefined
        : args.transaction.map((v) =>
            v instanceof protocol.Transaction ? v : new protocol.Transaction(v)
          );
    this.messages =
      args.messages == undefined ? undefined : args.messages.map((v) => Message.fromObject(v));
  }

  copy() {
    return new Envelope(this.asObject());
  }

  asObject(): Envelope.Args {
    return {
      signatures: this.signatures && this.signatures?.map((v) => v.asObject()),
      txHash: this.txHash && Buffer.from(this.txHash).toString("hex"),
      transaction: this.transaction && this.transaction?.map((v) => v.asObject()),
      messages: this.messages && this.messages?.map((v) => v.asObject()),
    };
  }
}

export namespace SequencedMessage {
  export type Args = {
    message?: Message | Message.Args;
    source?: URL | string;
    destination?: URL | string;
    number?: number;
  };
  export type ArgsWithType = Args & { type: MessageType.Sequenced | "sequenced" };
}
export class SequencedMessage {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = MessageType.Sequenced;
  @encodeAs.field(2).union
  public message?: Message;
  @encodeAs.field(3).url
  public source?: URL;
  @encodeAs.field(4).url
  public destination?: URL;
  @encodeAs.field(5).uint
  public number?: number;

  constructor(args: SequencedMessage.Args) {
    this.message = args.message == undefined ? undefined : Message.fromObject(args.message);
    this.source =
      args.source == undefined
        ? undefined
        : args.source instanceof URL
        ? args.source
        : new URL(args.source);
    this.destination =
      args.destination == undefined
        ? undefined
        : args.destination instanceof URL
        ? args.destination
        : new URL(args.destination);
    this.number = args.number == undefined ? undefined : args.number;
  }

  copy() {
    return new SequencedMessage(this.asObject());
  }

  asObject(): SequencedMessage.ArgsWithType {
    return {
      type: "sequenced",
      message: this.message && this.message.asObject(),
      source: this.source && this.source.toString(),
      destination: this.destination && this.destination.toString(),
      number: this.number && this.number,
    };
  }
}

export namespace SignatureMessage {
  export type Args = {
    signature?: protocol.Signature | protocol.Signature.Args;
    txID?: TxID | string;
  };
  export type ArgsWithType = Args & { type: MessageType.Signature | "signature" };
}
export class SignatureMessage {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = MessageType.Signature;
  @encodeAs.field(2).union
  public signature?: protocol.Signature;
  @encodeAs.field(3).txid
  public txID?: TxID;

  constructor(args: SignatureMessage.Args) {
    this.signature =
      args.signature == undefined ? undefined : protocol.Signature.fromObject(args.signature);
    this.txID =
      args.txID == undefined
        ? undefined
        : args.txID instanceof TxID
        ? args.txID
        : new TxID(args.txID);
  }

  copy() {
    return new SignatureMessage(this.asObject());
  }

  asObject(): SignatureMessage.ArgsWithType {
    return {
      type: "signature",
      signature: this.signature && this.signature.asObject(),
      txID: this.txID && this.txID.toString(),
    };
  }
}

export namespace SignatureRequest {
  export type Args = {
    authority?: URL | string;
    txID?: TxID | string;
    cause?: TxID | string;
  };
  export type ArgsWithType = Args & { type: MessageType.SignatureRequest | "signatureRequest" };
}
export class SignatureRequest {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = MessageType.SignatureRequest;
  @encodeAs.field(2).url
  public authority?: URL;
  @encodeAs.field(3).txid
  public txID?: TxID;
  @encodeAs.field(4).txid
  public cause?: TxID;

  constructor(args: SignatureRequest.Args) {
    this.authority =
      args.authority == undefined
        ? undefined
        : args.authority instanceof URL
        ? args.authority
        : new URL(args.authority);
    this.txID =
      args.txID == undefined
        ? undefined
        : args.txID instanceof TxID
        ? args.txID
        : new TxID(args.txID);
    this.cause =
      args.cause == undefined
        ? undefined
        : args.cause instanceof TxID
        ? args.cause
        : new TxID(args.cause);
  }

  copy() {
    return new SignatureRequest(this.asObject());
  }

  asObject(): SignatureRequest.ArgsWithType {
    return {
      type: "signatureRequest",
      authority: this.authority && this.authority.toString(),
      txID: this.txID && this.txID.toString(),
      cause: this.cause && this.cause.toString(),
    };
  }
}

export namespace SyntheticMessage {
  export type Args = {
    message?: Message | Message.Args;
    signature?: protocol.KeySignature | protocol.KeySignature.Args;
    proof?: protocol.AnnotatedReceipt | protocol.AnnotatedReceipt.Args;
  };
  export type ArgsWithType = Args & { type: MessageType.Synthetic | "synthetic" };
}
export class SyntheticMessage {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = MessageType.Synthetic;
  @encodeAs.field(2).union
  public message?: Message;
  @encodeAs.field(3).union
  public signature?: protocol.KeySignature;
  @encodeAs.field(4).reference
  public proof?: protocol.AnnotatedReceipt;

  constructor(args: SyntheticMessage.Args) {
    this.message = args.message == undefined ? undefined : Message.fromObject(args.message);
    this.signature =
      args.signature == undefined ? undefined : protocol.KeySignature.fromObject(args.signature);
    this.proof =
      args.proof == undefined
        ? undefined
        : args.proof instanceof protocol.AnnotatedReceipt
        ? args.proof
        : new protocol.AnnotatedReceipt(args.proof);
  }

  copy() {
    return new SyntheticMessage(this.asObject());
  }

  asObject(): SyntheticMessage.ArgsWithType {
    return {
      type: "synthetic",
      message: this.message && this.message.asObject(),
      signature: this.signature && this.signature.asObject(),
      proof: this.proof && this.proof.asObject(),
    };
  }
}

export namespace TransactionMessage {
  export type Args = {
    transaction?: protocol.Transaction | protocol.Transaction.Args;
  };
  export type ArgsWithType = Args & { type: MessageType.Transaction | "transaction" };
}
export class TransactionMessage {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = MessageType.Transaction;
  @encodeAs.field(2).reference
  public transaction?: protocol.Transaction;

  constructor(args: TransactionMessage.Args) {
    this.transaction =
      args.transaction == undefined
        ? undefined
        : args.transaction instanceof protocol.Transaction
        ? args.transaction
        : new protocol.Transaction(args.transaction);
  }

  copy() {
    return new TransactionMessage(this.asObject());
  }

  asObject(): TransactionMessage.ArgsWithType {
    return {
      type: "transaction",
      transaction: this.transaction && this.transaction.asObject(),
    };
  }
}
