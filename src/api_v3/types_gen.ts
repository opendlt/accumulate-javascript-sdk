import { Record, RecordArgs } from ".";
import { AccumulateTxID as TxID, TxIDArgs } from "../address/txid";
import { AccumulateURL as URL, URLArgs } from "../address/url";
import { Buffer } from "../common/buffer";
import * as protocol from "../core";
import { encodeAs } from "../encoding";
import * as errors2 from "../errors";
import * as merkle from "../merkle";
import * as messaging from "../messaging";
import * as core from "../network";
import {
  EventType,
  KnownPeerStatus,
  KnownPeerStatusArgs,
  QueryType,
  RecordType,
  ServiceType,
} from "./enums_gen";
import * as p2p from "./p2p";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */

export type AccountRecordArgs = {
  account?: protocol.Account | protocol.AccountArgs;
  directory?: RecordRange<UrlRecord> | RecordRangeArgs<UrlRecord>;
  pending?: RecordRange<TxIDRecord> | RecordRangeArgs<TxIDRecord>;
  receipt?: Receipt | ReceiptArgs;
  lastBlockTime?: Date | string;
};
export type AccountRecordArgsWithType = AccountRecordArgs & {
  recordType: RecordType.Account | "account";
};
export class AccountRecord {
  @encodeAs.field(1).keepEmpty.enum.of(RecordType)
  public readonly recordType = RecordType.Account;
  @encodeAs.field(2).union
  public account?: protocol.Account;
  @encodeAs.field(3).reference
  public directory?: RecordRange<UrlRecord>;
  @encodeAs.field(4).reference
  public pending?: RecordRange<TxIDRecord>;
  @encodeAs.field(5).reference
  public receipt?: Receipt;
  @encodeAs.field(6).time
  public lastBlockTime?: Date;

  constructor(args: AccountRecordArgs) {
    this.account =
      args.account == undefined ? undefined : protocol.Account.fromObject(args.account);
    this.directory =
      args.directory == undefined
        ? undefined
        : args.directory instanceof RecordRange<UrlRecord>
        ? args.directory
        : new RecordRange<UrlRecord>(args.directory);
    this.pending =
      args.pending == undefined
        ? undefined
        : args.pending instanceof RecordRange<TxIDRecord>
        ? args.pending
        : new RecordRange<TxIDRecord>(args.pending);
    this.receipt =
      args.receipt == undefined
        ? undefined
        : args.receipt instanceof Receipt
        ? args.receipt
        : new Receipt(args.receipt);
    this.lastBlockTime =
      args.lastBlockTime == undefined
        ? undefined
        : args.lastBlockTime instanceof Date
        ? args.lastBlockTime
        : new Date(args.lastBlockTime);
  }

  copy() {
    return new AccountRecord(this.asObject());
  }

  asObject(): AccountRecordArgsWithType {
    return {
      recordType: "account",
      account: this.account && this.account.asObject(),
      directory: this.directory && this.directory.asObject(),
      pending: this.pending && this.pending.asObject(),
      receipt: this.receipt && this.receipt.asObject(),
      lastBlockTime: this.lastBlockTime && this.lastBlockTime,
    };
  }
}

export type AnchorSearchQueryArgs = {
  anchor?: Uint8Array | string;
  includeReceipt?: ReceiptOptions | ReceiptOptionsArgs;
};
export type AnchorSearchQueryArgsWithType = AnchorSearchQueryArgs & {
  queryType: QueryType.AnchorSearch | "anchorSearch";
};
export class AnchorSearchQuery {
  @encodeAs.field(1).keepEmpty.enum.of(QueryType)
  public readonly queryType = QueryType.AnchorSearch;
  @encodeAs.field(2).bytes
  public anchor?: Uint8Array;
  @encodeAs.field(3).reference
  public includeReceipt?: ReceiptOptions;

  constructor(args: AnchorSearchQueryArgs) {
    this.anchor =
      args.anchor == undefined
        ? undefined
        : args.anchor instanceof Uint8Array
        ? args.anchor
        : Buffer.from(args.anchor, "hex");
    this.includeReceipt =
      args.includeReceipt == undefined
        ? undefined
        : args.includeReceipt instanceof ReceiptOptions
        ? args.includeReceipt
        : new ReceiptOptions(args.includeReceipt);
  }

  copy() {
    return new AnchorSearchQuery(this.asObject());
  }

  asObject(): AnchorSearchQueryArgsWithType {
    return {
      queryType: "anchorSearch",
      anchor: this.anchor && this.anchor && Buffer.from(this.anchor).toString("hex"),
      includeReceipt: this.includeReceipt && this.includeReceipt.asObject(),
    };
  }
}

export type BlockEventArgs = {
  partition?: string;
  index?: number;
  time?: Date | string;
  major?: number;
  entries?: (ChainEntryRecord<Record> | ChainEntryRecordArgs<Record>)[];
};
export type BlockEventArgsWithType = BlockEventArgs & { eventType: EventType.Block | "block" };
export class BlockEvent {
  @encodeAs.field(1).keepEmpty.enum.of(EventType)
  public readonly eventType = EventType.Block;
  @encodeAs.field(2).string
  public partition?: string;
  @encodeAs.field(3).uint
  public index?: number;
  @encodeAs.field(4).time
  public time?: Date;
  @encodeAs.field(5).uint
  public major?: number;
  @encodeAs.field(6).repeatable.reference
  public entries?: ChainEntryRecord<Record>[];

  constructor(args: BlockEventArgs) {
    this.partition = args.partition == undefined ? undefined : args.partition;
    this.index = args.index == undefined ? undefined : args.index;
    this.time =
      args.time == undefined
        ? undefined
        : args.time instanceof Date
        ? args.time
        : new Date(args.time);
    this.major = args.major == undefined ? undefined : args.major;
    this.entries =
      args.entries == undefined
        ? undefined
        : args.entries.map((v) =>
            v instanceof ChainEntryRecord<Record> ? v : new ChainEntryRecord<Record>(v)
          );
  }

  copy() {
    return new BlockEvent(this.asObject());
  }

  asObject(): BlockEventArgsWithType {
    return {
      eventType: "block",
      partition: this.partition && this.partition,
      index: this.index && this.index,
      time: this.time && this.time,
      major: this.major && this.major,
      entries: this.entries && this.entries?.map((v) => v.asObject()),
    };
  }
}

export type BlockQueryArgs = {
  minor?: number;
  major?: number;
  minorRange?: RangeOptions | RangeOptionsArgs;
  majorRange?: RangeOptions | RangeOptionsArgs;
  entryRange?: RangeOptions | RangeOptionsArgs;
  omitEmpty?: boolean;
};
export type BlockQueryArgsWithType = BlockQueryArgs & { queryType: QueryType.Block | "block" };
export class BlockQuery {
  @encodeAs.field(1).keepEmpty.enum.of(QueryType)
  public readonly queryType = QueryType.Block;
  @encodeAs.field(2).uint
  public minor?: number;
  @encodeAs.field(3).uint
  public major?: number;
  @encodeAs.field(4).reference
  public minorRange?: RangeOptions;
  @encodeAs.field(5).reference
  public majorRange?: RangeOptions;
  @encodeAs.field(6).reference
  public entryRange?: RangeOptions;
  @encodeAs.field(7).bool
  public omitEmpty?: boolean;

  constructor(args: BlockQueryArgs) {
    this.minor = args.minor == undefined ? undefined : args.minor;
    this.major = args.major == undefined ? undefined : args.major;
    this.minorRange =
      args.minorRange == undefined
        ? undefined
        : args.minorRange instanceof RangeOptions
        ? args.minorRange
        : new RangeOptions(args.minorRange);
    this.majorRange =
      args.majorRange == undefined
        ? undefined
        : args.majorRange instanceof RangeOptions
        ? args.majorRange
        : new RangeOptions(args.majorRange);
    this.entryRange =
      args.entryRange == undefined
        ? undefined
        : args.entryRange instanceof RangeOptions
        ? args.entryRange
        : new RangeOptions(args.entryRange);
    this.omitEmpty = args.omitEmpty == undefined ? undefined : args.omitEmpty;
  }

  copy() {
    return new BlockQuery(this.asObject());
  }

  asObject(): BlockQueryArgsWithType {
    return {
      queryType: "block",
      minor: this.minor && this.minor,
      major: this.major && this.major,
      minorRange: this.minorRange && this.minorRange.asObject(),
      majorRange: this.majorRange && this.majorRange.asObject(),
      entryRange: this.entryRange && this.entryRange.asObject(),
      omitEmpty: this.omitEmpty && this.omitEmpty,
    };
  }
}

export type ChainEntryRecordArgs<T extends Record = Record> = {
  account?: URLArgs;
  name?: string;
  type?: merkle.ChainTypeArgs;
  index?: number;
  entry?: Uint8Array | string;
  value?: T | RecordArgs /* TODO RecordArgs is too broad */;
  receipt?: Receipt | ReceiptArgs;
  state?: (Uint8Array | string)[];
  lastBlockTime?: Date | string;
};
export type ChainEntryRecordArgsWithType<T extends Record = Record> = ChainEntryRecordArgs<T> & {
  recordType: RecordType.ChainEntry | "chainEntry";
};
export class ChainEntryRecord<T extends Record = Record> {
  @encodeAs.field(1).keepEmpty.enum.of(RecordType)
  public readonly recordType = RecordType.ChainEntry;
  @encodeAs.field(2).url
  public account?: URL;
  @encodeAs.field(3).string
  public name?: string;
  @encodeAs.field(4).enum
  public type?: merkle.ChainType;
  @encodeAs.field(5).keepEmpty.uint
  public index?: number;
  @encodeAs.field(6).hash
  public entry?: Uint8Array;
  @encodeAs.field(7).union
  public value?: T;
  @encodeAs.field(8).reference
  public receipt?: Receipt;
  @encodeAs.field(9).repeatable.bytes
  public state?: Uint8Array[];
  @encodeAs.field(10).time
  public lastBlockTime?: Date;

  constructor(args: ChainEntryRecordArgs<T>) {
    this.account = args.account == undefined ? undefined : URL.parse(args.account);
    this.name = args.name == undefined ? undefined : args.name;
    this.type = args.type == undefined ? undefined : merkle.ChainType.fromObject(args.type);
    this.index = args.index == undefined ? undefined : args.index;
    this.entry =
      args.entry == undefined
        ? undefined
        : args.entry instanceof Uint8Array
        ? args.entry
        : Buffer.from(args.entry, "hex");
    this.value = args.value == undefined ? undefined : <T>Record.fromObject(args.value);
    this.receipt =
      args.receipt == undefined
        ? undefined
        : args.receipt instanceof Receipt
        ? args.receipt
        : new Receipt(args.receipt);
    this.state =
      args.state == undefined
        ? undefined
        : args.state.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
    this.lastBlockTime =
      args.lastBlockTime == undefined
        ? undefined
        : args.lastBlockTime instanceof Date
        ? args.lastBlockTime
        : new Date(args.lastBlockTime);
  }

  copy() {
    return new ChainEntryRecord<T>(this.asObject());
  }

  asObject(): ChainEntryRecordArgsWithType<T> {
    return {
      recordType: "chainEntry",
      account: this.account && this.account.toString(),
      name: this.name && this.name,
      type: this.type && merkle.ChainType.getName(this.type),
      index: this.index && this.index,
      entry: this.entry && this.entry && Buffer.from(this.entry).toString("hex"),
      value: this.value && this.value.asObject(),
      receipt: this.receipt && this.receipt.asObject(),
      state: this.state && this.state?.map((v) => v && Buffer.from(v).toString("hex")),
      lastBlockTime: this.lastBlockTime && this.lastBlockTime,
    };
  }
}

export type ChainQueryArgs = {
  name?: string;
  index?: number;
  entry?: Uint8Array | string;
  range?: RangeOptions | RangeOptionsArgs;
  includeReceipt?: ReceiptOptions | ReceiptOptionsArgs;
};
export type ChainQueryArgsWithType = ChainQueryArgs & { queryType: QueryType.Chain | "chain" };
export class ChainQuery {
  @encodeAs.field(1).keepEmpty.enum.of(QueryType)
  public readonly queryType = QueryType.Chain;
  @encodeAs.field(2).string
  public name?: string;
  @encodeAs.field(3).uint
  public index?: number;
  @encodeAs.field(4).bytes
  public entry?: Uint8Array;
  @encodeAs.field(5).reference
  public range?: RangeOptions;
  @encodeAs.field(6).reference
  public includeReceipt?: ReceiptOptions;

  constructor(args: ChainQueryArgs) {
    this.name = args.name == undefined ? undefined : args.name;
    this.index = args.index == undefined ? undefined : args.index;
    this.entry =
      args.entry == undefined
        ? undefined
        : args.entry instanceof Uint8Array
        ? args.entry
        : Buffer.from(args.entry, "hex");
    this.range =
      args.range == undefined
        ? undefined
        : args.range instanceof RangeOptions
        ? args.range
        : new RangeOptions(args.range);
    this.includeReceipt =
      args.includeReceipt == undefined
        ? undefined
        : args.includeReceipt instanceof ReceiptOptions
        ? args.includeReceipt
        : new ReceiptOptions(args.includeReceipt);
  }

  copy() {
    return new ChainQuery(this.asObject());
  }

  asObject(): ChainQueryArgsWithType {
    return {
      queryType: "chain",
      name: this.name && this.name,
      index: this.index && this.index,
      entry: this.entry && this.entry && Buffer.from(this.entry).toString("hex"),
      range: this.range && this.range.asObject(),
      includeReceipt: this.includeReceipt && this.includeReceipt.asObject(),
    };
  }
}

export type ChainRecordArgs = {
  name?: string;
  type?: merkle.ChainTypeArgs;
  count?: number;
  state?: (Uint8Array | string)[];
  lastBlockTime?: Date | string;
};
export type ChainRecordArgsWithType = ChainRecordArgs & { recordType: RecordType.Chain | "chain" };
export class ChainRecord {
  @encodeAs.field(1).keepEmpty.enum.of(RecordType)
  public readonly recordType = RecordType.Chain;
  @encodeAs.field(2).string
  public name?: string;
  @encodeAs.field(3).enum
  public type?: merkle.ChainType;
  @encodeAs.field(4).uint
  public count?: number;
  @encodeAs.field(5).repeatable.bytes
  public state?: Uint8Array[];
  @encodeAs.field(6).time
  public lastBlockTime?: Date;

  constructor(args: ChainRecordArgs) {
    this.name = args.name == undefined ? undefined : args.name;
    this.type = args.type == undefined ? undefined : merkle.ChainType.fromObject(args.type);
    this.count = args.count == undefined ? undefined : args.count;
    this.state =
      args.state == undefined
        ? undefined
        : args.state.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
    this.lastBlockTime =
      args.lastBlockTime == undefined
        ? undefined
        : args.lastBlockTime instanceof Date
        ? args.lastBlockTime
        : new Date(args.lastBlockTime);
  }

  copy() {
    return new ChainRecord(this.asObject());
  }

  asObject(): ChainRecordArgsWithType {
    return {
      recordType: "chain",
      name: this.name && this.name,
      type: this.type && merkle.ChainType.getName(this.type),
      count: this.count && this.count,
      state: this.state && this.state?.map((v) => v && Buffer.from(v).toString("hex")),
      lastBlockTime: this.lastBlockTime && this.lastBlockTime,
    };
  }
}

export type ConsensusPeerInfoArgs = {
  nodeID?: string;
  host?: string;
  port?: number;
};
export class ConsensusPeerInfo {
  @encodeAs.field(1).string
  public nodeID?: string;
  @encodeAs.field(2).string
  public host?: string;
  @encodeAs.field(3).uint
  public port?: number;

  constructor(args: ConsensusPeerInfoArgs) {
    this.nodeID = args.nodeID == undefined ? undefined : args.nodeID;
    this.host = args.host == undefined ? undefined : args.host;
    this.port = args.port == undefined ? undefined : args.port;
  }

  copy() {
    return new ConsensusPeerInfo(this.asObject());
  }

  asObject(): ConsensusPeerInfoArgs {
    return {
      nodeID: this.nodeID && this.nodeID,
      host: this.host && this.host,
      port: this.port && this.port,
    };
  }
}

export type ConsensusStatusArgs = {
  ok?: boolean;
  lastBlock?: LastBlock | LastBlockArgs;
  version?: string;
  commit?: string;
  nodeKeyHash?: Uint8Array | string;
  validatorKeyHash?: Uint8Array | string;
  partitionID?: string;
  partitionType?: protocol.PartitionTypeArgs;
  peers?: (ConsensusPeerInfo | ConsensusPeerInfoArgs)[];
};
export class ConsensusStatus {
  @encodeAs.field(1).bool
  public ok?: boolean;
  @encodeAs.field(2).reference
  public lastBlock?: LastBlock;
  @encodeAs.field(3).string
  public version?: string;
  @encodeAs.field(4).string
  public commit?: string;
  @encodeAs.field(5).hash
  public nodeKeyHash?: Uint8Array;
  @encodeAs.field(6).hash
  public validatorKeyHash?: Uint8Array;
  @encodeAs.field(7).string
  public partitionID?: string;
  @encodeAs.field(8).enum
  public partitionType?: protocol.PartitionType;
  @encodeAs.field(9).repeatable.reference
  public peers?: ConsensusPeerInfo[];

  constructor(args: ConsensusStatusArgs) {
    this.ok = args.ok == undefined ? undefined : args.ok;
    this.lastBlock =
      args.lastBlock == undefined
        ? undefined
        : args.lastBlock instanceof LastBlock
        ? args.lastBlock
        : new LastBlock(args.lastBlock);
    this.version = args.version == undefined ? undefined : args.version;
    this.commit = args.commit == undefined ? undefined : args.commit;
    this.nodeKeyHash =
      args.nodeKeyHash == undefined
        ? undefined
        : args.nodeKeyHash instanceof Uint8Array
        ? args.nodeKeyHash
        : Buffer.from(args.nodeKeyHash, "hex");
    this.validatorKeyHash =
      args.validatorKeyHash == undefined
        ? undefined
        : args.validatorKeyHash instanceof Uint8Array
        ? args.validatorKeyHash
        : Buffer.from(args.validatorKeyHash, "hex");
    this.partitionID = args.partitionID == undefined ? undefined : args.partitionID;
    this.partitionType =
      args.partitionType == undefined
        ? undefined
        : protocol.PartitionType.fromObject(args.partitionType);
    this.peers =
      args.peers == undefined
        ? undefined
        : args.peers.map((v) => (v instanceof ConsensusPeerInfo ? v : new ConsensusPeerInfo(v)));
  }

  copy() {
    return new ConsensusStatus(this.asObject());
  }

  asObject(): ConsensusStatusArgs {
    return {
      ok: this.ok && this.ok,
      lastBlock: this.lastBlock && this.lastBlock.asObject(),
      version: this.version && this.version,
      commit: this.commit && this.commit,
      nodeKeyHash:
        this.nodeKeyHash && this.nodeKeyHash && Buffer.from(this.nodeKeyHash).toString("hex"),
      validatorKeyHash:
        this.validatorKeyHash &&
        this.validatorKeyHash &&
        Buffer.from(this.validatorKeyHash).toString("hex"),
      partitionID: this.partitionID && this.partitionID,
      partitionType: this.partitionType && protocol.PartitionType.getName(this.partitionType),
      peers: this.peers && this.peers?.map((v) => v.asObject()),
    };
  }
}

export type ConsensusStatusOptionsArgs = {
  nodeID?: string;
  partition?: string;
  includePeers?: boolean;
  includeAccumulate?: boolean;
};
export class ConsensusStatusOptions {
  @encodeAs.field(1).string
  public nodeID?: string;
  @encodeAs.field(2).string
  public partition?: string;
  @encodeAs.field(3).bool
  public includePeers?: boolean;
  @encodeAs.field(4).bool
  public includeAccumulate?: boolean;

  constructor(args: ConsensusStatusOptionsArgs) {
    this.nodeID = args.nodeID == undefined ? undefined : args.nodeID;
    this.partition = args.partition == undefined ? undefined : args.partition;
    this.includePeers = args.includePeers == undefined ? undefined : args.includePeers;
    this.includeAccumulate =
      args.includeAccumulate == undefined ? undefined : args.includeAccumulate;
  }

  copy() {
    return new ConsensusStatusOptions(this.asObject());
  }

  asObject(): ConsensusStatusOptionsArgs {
    return {
      nodeID: this.nodeID && this.nodeID,
      partition: this.partition && this.partition,
      includePeers: this.includePeers && this.includePeers,
      includeAccumulate: this.includeAccumulate && this.includeAccumulate,
    };
  }
}

export type DataQueryArgs = {
  index?: number;
  entry?: Uint8Array | string;
  range?: RangeOptions | RangeOptionsArgs;
};
export type DataQueryArgsWithType = DataQueryArgs & { queryType: QueryType.Data | "data" };
export class DataQuery {
  @encodeAs.field(1).keepEmpty.enum.of(QueryType)
  public readonly queryType = QueryType.Data;
  @encodeAs.field(2).uint
  public index?: number;
  @encodeAs.field(3).bytes
  public entry?: Uint8Array;
  @encodeAs.field(4).reference
  public range?: RangeOptions;

  constructor(args: DataQueryArgs) {
    this.index = args.index == undefined ? undefined : args.index;
    this.entry =
      args.entry == undefined
        ? undefined
        : args.entry instanceof Uint8Array
        ? args.entry
        : Buffer.from(args.entry, "hex");
    this.range =
      args.range == undefined
        ? undefined
        : args.range instanceof RangeOptions
        ? args.range
        : new RangeOptions(args.range);
  }

  copy() {
    return new DataQuery(this.asObject());
  }

  asObject(): DataQueryArgsWithType {
    return {
      queryType: "data",
      index: this.index && this.index,
      entry: this.entry && this.entry && Buffer.from(this.entry).toString("hex"),
      range: this.range && this.range.asObject(),
    };
  }
}

export type DefaultQueryArgs = {
  includeReceipt?: ReceiptOptions | ReceiptOptionsArgs;
};
export type DefaultQueryArgsWithType = DefaultQueryArgs & {
  queryType: QueryType.Default | "default";
};
export class DefaultQuery {
  @encodeAs.field(1).keepEmpty.enum.of(QueryType)
  public readonly queryType = QueryType.Default;
  @encodeAs.field(2).reference
  public includeReceipt?: ReceiptOptions;

  constructor(args: DefaultQueryArgs) {
    this.includeReceipt =
      args.includeReceipt == undefined
        ? undefined
        : args.includeReceipt instanceof ReceiptOptions
        ? args.includeReceipt
        : new ReceiptOptions(args.includeReceipt);
  }

  copy() {
    return new DefaultQuery(this.asObject());
  }

  asObject(): DefaultQueryArgsWithType {
    return {
      queryType: "default",
      includeReceipt: this.includeReceipt && this.includeReceipt.asObject(),
    };
  }
}

export type DelegateSearchQueryArgs = {
  delegate?: URLArgs;
};
export type DelegateSearchQueryArgsWithType = DelegateSearchQueryArgs & {
  queryType: QueryType.DelegateSearch | "delegateSearch";
};
export class DelegateSearchQuery {
  @encodeAs.field(1).keepEmpty.enum.of(QueryType)
  public readonly queryType = QueryType.DelegateSearch;
  @encodeAs.field(2).url
  public delegate?: URL;

  constructor(args: DelegateSearchQueryArgs) {
    this.delegate = args.delegate == undefined ? undefined : URL.parse(args.delegate);
  }

  copy() {
    return new DelegateSearchQuery(this.asObject());
  }

  asObject(): DelegateSearchQueryArgsWithType {
    return {
      queryType: "delegateSearch",
      delegate: this.delegate && this.delegate.toString(),
    };
  }
}

export type DirectoryQueryArgs = {
  range?: RangeOptions | RangeOptionsArgs;
};
export type DirectoryQueryArgsWithType = DirectoryQueryArgs & {
  queryType: QueryType.Directory | "directory";
};
export class DirectoryQuery {
  @encodeAs.field(1).keepEmpty.enum.of(QueryType)
  public readonly queryType = QueryType.Directory;
  @encodeAs.field(2).reference
  public range?: RangeOptions;

  constructor(args: DirectoryQueryArgs) {
    this.range =
      args.range == undefined
        ? undefined
        : args.range instanceof RangeOptions
        ? args.range
        : new RangeOptions(args.range);
  }

  copy() {
    return new DirectoryQuery(this.asObject());
  }

  asObject(): DirectoryQueryArgsWithType {
    return {
      queryType: "directory",
      range: this.range && this.range.asObject(),
    };
  }
}

export type ErrorEventArgs = {
  err?: errors2.Error | errors2.ErrorArgs;
};
export type ErrorEventArgsWithType = ErrorEventArgs & { eventType: EventType.Error | "error" };
export class ErrorEvent {
  @encodeAs.field(1).keepEmpty.enum.of(EventType)
  public readonly eventType = EventType.Error;
  @encodeAs.field(2).reference
  public err?: errors2.Error;

  constructor(args: ErrorEventArgs) {
    this.err =
      args.err == undefined
        ? undefined
        : args.err instanceof errors2.Error
        ? args.err
        : new errors2.Error(args.err);
  }

  copy() {
    return new ErrorEvent(this.asObject());
  }

  asObject(): ErrorEventArgsWithType {
    return {
      eventType: "error",
      err: this.err && this.err.asObject(),
    };
  }
}

export type ErrorRecordArgs = {
  value?: errors2.Error | errors2.ErrorArgs;
};
export type ErrorRecordArgsWithType = ErrorRecordArgs & { recordType: RecordType.Error | "error" };
export class ErrorRecord {
  @encodeAs.field(1).keepEmpty.enum.of(RecordType)
  public readonly recordType = RecordType.Error;
  @encodeAs.field(2).reference
  public value?: errors2.Error;

  constructor(args: ErrorRecordArgs) {
    this.value =
      args.value == undefined
        ? undefined
        : args.value instanceof errors2.Error
        ? args.value
        : new errors2.Error(args.value);
  }

  copy() {
    return new ErrorRecord(this.asObject());
  }

  asObject(): ErrorRecordArgsWithType {
    return {
      recordType: "error",
      value: this.value && this.value.asObject(),
    };
  }
}

export type FaucetOptionsArgs = {
  token?: URLArgs;
};
export class FaucetOptions {
  @encodeAs.field(1).url
  public token?: URL;

  constructor(args: FaucetOptionsArgs) {
    this.token = args.token == undefined ? undefined : URL.parse(args.token);
  }

  copy() {
    return new FaucetOptions(this.asObject());
  }

  asObject(): FaucetOptionsArgs {
    return {
      token: this.token && this.token.toString(),
    };
  }
}

export type FindServiceOptionsArgs = {
  network?: string;
  service?: ServiceAddress | ServiceAddressArgs;
  known?: boolean;
  timeout?: number;
};
export class FindServiceOptions {
  @encodeAs.field(1).string
  public network?: string;
  @encodeAs.field(2).reference
  public service?: ServiceAddress;
  @encodeAs.field(3).bool
  public known?: boolean;
  @encodeAs.field(4).duration
  public timeout?: number;

  constructor(args: FindServiceOptionsArgs) {
    this.network = args.network == undefined ? undefined : args.network;
    this.service =
      args.service == undefined
        ? undefined
        : args.service instanceof ServiceAddress
        ? args.service
        : new ServiceAddress(args.service);
    this.known = args.known == undefined ? undefined : args.known;
    this.timeout = args.timeout == undefined ? undefined : args.timeout;
  }

  copy() {
    return new FindServiceOptions(this.asObject());
  }

  asObject(): FindServiceOptionsArgs {
    return {
      network: this.network && this.network,
      service: this.service && this.service.asObject(),
      known: this.known && this.known,
      timeout: this.timeout && this.timeout,
    };
  }
}

export type FindServiceResultArgs = {
  peerID?: p2p.PeerID | p2p.PeerIDArgs;
  status?: KnownPeerStatusArgs;
  addresses?: (p2p.Multiaddr | p2p.MultiaddrArgs)[];
};
export class FindServiceResult {
  @encodeAs.field(1).union
  public peerID?: p2p.PeerID;
  @encodeAs.field(2).enum
  public status?: KnownPeerStatus;
  @encodeAs.field(3).repeatable.union
  public addresses?: p2p.Multiaddr[];

  constructor(args: FindServiceResultArgs) {
    this.peerID = args.peerID == undefined ? undefined : p2p.PeerID.fromObject(args.peerID);
    this.status = args.status == undefined ? undefined : KnownPeerStatus.fromObject(args.status);
    this.addresses =
      args.addresses == undefined
        ? undefined
        : args.addresses.map((v) => p2p.Multiaddr.fromObject(v));
  }

  copy() {
    return new FindServiceResult(this.asObject());
  }

  asObject(): FindServiceResultArgs {
    return {
      peerID: this.peerID && this.peerID.asObject(),
      status: this.status && KnownPeerStatus.getName(this.status),
      addresses: this.addresses && this.addresses?.map((v) => v.asObject()),
    };
  }
}

export type GlobalsEventArgs = {
  old?: core.GlobalValues | core.GlobalValuesArgs;
  new?: core.GlobalValues | core.GlobalValuesArgs;
};
export type GlobalsEventArgsWithType = GlobalsEventArgs & {
  eventType: EventType.Globals | "globals";
};
export class GlobalsEvent {
  @encodeAs.field(1).keepEmpty.enum.of(EventType)
  public readonly eventType = EventType.Globals;
  @encodeAs.field(2).reference
  public old?: core.GlobalValues;
  @encodeAs.field(3).reference
  public new?: core.GlobalValues;

  constructor(args: GlobalsEventArgs) {
    this.old =
      args.old == undefined
        ? undefined
        : args.old instanceof core.GlobalValues
        ? args.old
        : new core.GlobalValues(args.old);
    this.new =
      args.new == undefined
        ? undefined
        : args.new instanceof core.GlobalValues
        ? args.new
        : new core.GlobalValues(args.new);
  }

  copy() {
    return new GlobalsEvent(this.asObject());
  }

  asObject(): GlobalsEventArgsWithType {
    return {
      eventType: "globals",
      old: this.old && this.old.asObject(),
      new: this.new && this.new.asObject(),
    };
  }
}

export type IndexEntryRecordArgs = {
  value?: protocol.IndexEntry | protocol.IndexEntryArgs;
};
export type IndexEntryRecordArgsWithType = IndexEntryRecordArgs & {
  recordType: RecordType.IndexEntry | "indexEntry";
};
export class IndexEntryRecord {
  @encodeAs.field(1).keepEmpty.enum.of(RecordType)
  public readonly recordType = RecordType.IndexEntry;
  @encodeAs.field(2).reference
  public value?: protocol.IndexEntry;

  constructor(args: IndexEntryRecordArgs) {
    this.value =
      args.value == undefined
        ? undefined
        : args.value instanceof protocol.IndexEntry
        ? args.value
        : new protocol.IndexEntry(args.value);
  }

  copy() {
    return new IndexEntryRecord(this.asObject());
  }

  asObject(): IndexEntryRecordArgsWithType {
    return {
      recordType: "indexEntry",
      value: this.value && this.value.asObject(),
    };
  }
}

export type KeyRecordArgs = {
  authority?: URLArgs;
  signer?: URLArgs;
  version?: number;
  index?: number;
  entry?: protocol.KeySpec | protocol.KeySpecArgs;
};
export type KeyRecordArgsWithType = KeyRecordArgs & { recordType: RecordType.Key | "key" };
export class KeyRecord {
  @encodeAs.field(1).keepEmpty.enum.of(RecordType)
  public readonly recordType = RecordType.Key;
  @encodeAs.field(2).url
  public authority?: URL;
  @encodeAs.field(3).url
  public signer?: URL;
  @encodeAs.field(4).uint
  public version?: number;
  @encodeAs.field(5).uint
  public index?: number;
  @encodeAs.field(6).reference
  public entry?: protocol.KeySpec;

  constructor(args: KeyRecordArgs) {
    this.authority = args.authority == undefined ? undefined : URL.parse(args.authority);
    this.signer = args.signer == undefined ? undefined : URL.parse(args.signer);
    this.version = args.version == undefined ? undefined : args.version;
    this.index = args.index == undefined ? undefined : args.index;
    this.entry =
      args.entry == undefined
        ? undefined
        : args.entry instanceof protocol.KeySpec
        ? args.entry
        : new protocol.KeySpec(args.entry);
  }

  copy() {
    return new KeyRecord(this.asObject());
  }

  asObject(): KeyRecordArgsWithType {
    return {
      recordType: "key",
      authority: this.authority && this.authority.toString(),
      signer: this.signer && this.signer.toString(),
      version: this.version && this.version,
      index: this.index && this.index,
      entry: this.entry && this.entry.asObject(),
    };
  }
}

export type LastBlockArgs = {
  height?: number;
  time?: Date | string;
  chainRoot?: Uint8Array | string;
  stateRoot?: Uint8Array | string;
  directoryAnchorHeight?: number;
};
export class LastBlock {
  @encodeAs.field(1).int
  public height?: number;
  @encodeAs.field(2).time
  public time?: Date;
  @encodeAs.field(3).hash
  public chainRoot?: Uint8Array;
  @encodeAs.field(4).hash
  public stateRoot?: Uint8Array;
  @encodeAs.field(5).uint
  public directoryAnchorHeight?: number;

  constructor(args: LastBlockArgs) {
    this.height = args.height == undefined ? undefined : args.height;
    this.time =
      args.time == undefined
        ? undefined
        : args.time instanceof Date
        ? args.time
        : new Date(args.time);
    this.chainRoot =
      args.chainRoot == undefined
        ? undefined
        : args.chainRoot instanceof Uint8Array
        ? args.chainRoot
        : Buffer.from(args.chainRoot, "hex");
    this.stateRoot =
      args.stateRoot == undefined
        ? undefined
        : args.stateRoot instanceof Uint8Array
        ? args.stateRoot
        : Buffer.from(args.stateRoot, "hex");
    this.directoryAnchorHeight =
      args.directoryAnchorHeight == undefined ? undefined : args.directoryAnchorHeight;
  }

  copy() {
    return new LastBlock(this.asObject());
  }

  asObject(): LastBlockArgs {
    return {
      height: this.height && this.height,
      time: this.time && this.time,
      chainRoot: this.chainRoot && this.chainRoot && Buffer.from(this.chainRoot).toString("hex"),
      stateRoot: this.stateRoot && this.stateRoot && Buffer.from(this.stateRoot).toString("hex"),
      directoryAnchorHeight: this.directoryAnchorHeight && this.directoryAnchorHeight,
    };
  }
}

export type MajorBlockRecordArgs = {
  index?: number;
  time?: Date | string;
  minorBlocks?: RecordRange<MinorBlockRecord> | RecordRangeArgs<MinorBlockRecord>;
  lastBlockTime?: Date | string;
};
export type MajorBlockRecordArgsWithType = MajorBlockRecordArgs & {
  recordType: RecordType.MajorBlock | "majorBlock";
};
export class MajorBlockRecord {
  @encodeAs.field(1).keepEmpty.enum.of(RecordType)
  public readonly recordType = RecordType.MajorBlock;
  @encodeAs.field(2).uint
  public index?: number;
  @encodeAs.field(3).time
  public time?: Date;
  @encodeAs.field(4).reference
  public minorBlocks?: RecordRange<MinorBlockRecord>;
  @encodeAs.field(5).time
  public lastBlockTime?: Date;

  constructor(args: MajorBlockRecordArgs) {
    this.index = args.index == undefined ? undefined : args.index;
    this.time =
      args.time == undefined
        ? undefined
        : args.time instanceof Date
        ? args.time
        : new Date(args.time);
    this.minorBlocks =
      args.minorBlocks == undefined
        ? undefined
        : args.minorBlocks instanceof RecordRange<MinorBlockRecord>
        ? args.minorBlocks
        : new RecordRange<MinorBlockRecord>(args.minorBlocks);
    this.lastBlockTime =
      args.lastBlockTime == undefined
        ? undefined
        : args.lastBlockTime instanceof Date
        ? args.lastBlockTime
        : new Date(args.lastBlockTime);
  }

  copy() {
    return new MajorBlockRecord(this.asObject());
  }

  asObject(): MajorBlockRecordArgsWithType {
    return {
      recordType: "majorBlock",
      index: this.index && this.index,
      time: this.time && this.time,
      minorBlocks: this.minorBlocks && this.minorBlocks.asObject(),
      lastBlockTime: this.lastBlockTime && this.lastBlockTime,
    };
  }
}

export type MessageHashSearchQueryArgs = {
  hash?: Uint8Array | string;
};
export type MessageHashSearchQueryArgsWithType = MessageHashSearchQueryArgs & {
  queryType: QueryType.MessageHashSearch | "messageHashSearch";
};
export class MessageHashSearchQuery {
  @encodeAs.field(1).keepEmpty.enum.of(QueryType)
  public readonly queryType = QueryType.MessageHashSearch;
  @encodeAs.field(2).hash
  public hash?: Uint8Array;

  constructor(args: MessageHashSearchQueryArgs) {
    this.hash =
      args.hash == undefined
        ? undefined
        : args.hash instanceof Uint8Array
        ? args.hash
        : Buffer.from(args.hash, "hex");
  }

  copy() {
    return new MessageHashSearchQuery(this.asObject());
  }

  asObject(): MessageHashSearchQueryArgsWithType {
    return {
      queryType: "messageHashSearch",
      hash: this.hash && this.hash && Buffer.from(this.hash).toString("hex"),
    };
  }
}

export type MessageRecordArgs<T extends messaging.Message = messaging.Message> = {
  id?: TxIDArgs;
  message?: T | messaging.MessageArgs /* TODO messaging.MessageArgs is too broad */;
  status?: errors2.StatusArgs;
  error?: errors2.Error | errors2.ErrorArgs;
  result?: protocol.TransactionResult | protocol.TransactionResultArgs;
  received?: number;
  produced?: RecordRange<TxIDRecord> | RecordRangeArgs<TxIDRecord>;
  cause?: RecordRange<TxIDRecord> | RecordRangeArgs<TxIDRecord>;
  signatures?: RecordRange<SignatureSetRecord> | RecordRangeArgs<SignatureSetRecord>;
  historical?: boolean;
  sequence?: messaging.SequencedMessage | messaging.SequencedMessageArgs;
  sourceReceipt?: merkle.Receipt | merkle.ReceiptArgs;
  lastBlockTime?: Date | string;
};
export type MessageRecordArgsWithType<T extends messaging.Message = messaging.Message> =
  MessageRecordArgs<T> & { recordType: RecordType.Message | "message" };
export class MessageRecord<T extends messaging.Message = messaging.Message> {
  @encodeAs.field(1).keepEmpty.enum.of(RecordType)
  public readonly recordType = RecordType.Message;
  @encodeAs.field(2).txid
  public id?: TxID;
  @encodeAs.field(3).union
  public message?: T;
  @encodeAs.field(4).enum
  public status?: errors2.Status;
  @encodeAs.field(5).reference
  public error?: errors2.Error;
  @encodeAs.field(6).union
  public result?: protocol.TransactionResult;
  @encodeAs.field(7).uint
  public received?: number;
  @encodeAs.field(8).reference
  public produced?: RecordRange<TxIDRecord>;
  @encodeAs.field(9).reference
  public cause?: RecordRange<TxIDRecord>;
  @encodeAs.field(10).reference
  public signatures?: RecordRange<SignatureSetRecord>;
  @encodeAs.field(11).bool
  public historical?: boolean;
  @encodeAs.field(12).reference
  public sequence?: messaging.SequencedMessage;
  @encodeAs.field(13).reference
  public sourceReceipt?: merkle.Receipt;
  @encodeAs.field(14).time
  public lastBlockTime?: Date;

  constructor(args: MessageRecordArgs<T>) {
    this.id = args.id == undefined ? undefined : TxID.parse(args.id);
    this.message =
      args.message == undefined ? undefined : <T>messaging.Message.fromObject(args.message);
    this.status = args.status == undefined ? undefined : errors2.Status.fromObject(args.status);
    this.error =
      args.error == undefined
        ? undefined
        : args.error instanceof errors2.Error
        ? args.error
        : new errors2.Error(args.error);
    this.result =
      args.result == undefined ? undefined : protocol.TransactionResult.fromObject(args.result);
    this.received = args.received == undefined ? undefined : args.received;
    this.produced =
      args.produced == undefined
        ? undefined
        : args.produced instanceof RecordRange<TxIDRecord>
        ? args.produced
        : new RecordRange<TxIDRecord>(args.produced);
    this.cause =
      args.cause == undefined
        ? undefined
        : args.cause instanceof RecordRange<TxIDRecord>
        ? args.cause
        : new RecordRange<TxIDRecord>(args.cause);
    this.signatures =
      args.signatures == undefined
        ? undefined
        : args.signatures instanceof RecordRange<SignatureSetRecord>
        ? args.signatures
        : new RecordRange<SignatureSetRecord>(args.signatures);
    this.historical = args.historical == undefined ? undefined : args.historical;
    this.sequence =
      args.sequence == undefined
        ? undefined
        : args.sequence instanceof messaging.SequencedMessage
        ? args.sequence
        : new messaging.SequencedMessage(args.sequence);
    this.sourceReceipt =
      args.sourceReceipt == undefined
        ? undefined
        : args.sourceReceipt instanceof merkle.Receipt
        ? args.sourceReceipt
        : new merkle.Receipt(args.sourceReceipt);
    this.lastBlockTime =
      args.lastBlockTime == undefined
        ? undefined
        : args.lastBlockTime instanceof Date
        ? args.lastBlockTime
        : new Date(args.lastBlockTime);
  }

  copy() {
    return new MessageRecord<T>(this.asObject());
  }

  asObject(): MessageRecordArgsWithType<T> {
    return {
      recordType: "message",
      id: this.id && this.id.toString(),
      message: this.message && this.message.asObject(),
      status: this.status && errors2.Status.getName(this.status),
      error: this.error && this.error.asObject(),
      result: this.result && this.result.asObject(),
      received: this.received && this.received,
      produced: this.produced && this.produced.asObject(),
      cause: this.cause && this.cause.asObject(),
      signatures: this.signatures && this.signatures.asObject(),
      historical: this.historical && this.historical,
      sequence: this.sequence && this.sequence.asObject(),
      sourceReceipt: this.sourceReceipt && this.sourceReceipt.asObject(),
      lastBlockTime: this.lastBlockTime && this.lastBlockTime,
    };
  }
}

export type MinorBlockRecordArgs = {
  index?: number;
  time?: Date | string;
  source?: URLArgs;
  entries?: RecordRange<ChainEntryRecord<Record>> | RecordRangeArgs<ChainEntryRecord<Record>>;
  anchored?: RecordRange<MinorBlockRecord> | RecordRangeArgs<MinorBlockRecord>;
  lastBlockTime?: Date | string;
};
export type MinorBlockRecordArgsWithType = MinorBlockRecordArgs & {
  recordType: RecordType.MinorBlock | "minorBlock";
};
export class MinorBlockRecord {
  @encodeAs.field(1).keepEmpty.enum.of(RecordType)
  public readonly recordType = RecordType.MinorBlock;
  @encodeAs.field(2).uint
  public index?: number;
  @encodeAs.field(3).time
  public time?: Date;
  @encodeAs.field(4).url
  public source?: URL;
  @encodeAs.field(5).reference
  public entries?: RecordRange<ChainEntryRecord<Record>>;
  @encodeAs.field(6).reference
  public anchored?: RecordRange<MinorBlockRecord>;
  @encodeAs.field(7).time
  public lastBlockTime?: Date;

  constructor(args: MinorBlockRecordArgs) {
    this.index = args.index == undefined ? undefined : args.index;
    this.time =
      args.time == undefined
        ? undefined
        : args.time instanceof Date
        ? args.time
        : new Date(args.time);
    this.source = args.source == undefined ? undefined : URL.parse(args.source);
    this.entries =
      args.entries == undefined
        ? undefined
        : args.entries instanceof RecordRange<ChainEntryRecord<Record>>
        ? args.entries
        : new RecordRange<ChainEntryRecord<Record>>(args.entries);
    this.anchored =
      args.anchored == undefined
        ? undefined
        : args.anchored instanceof RecordRange<MinorBlockRecord>
        ? args.anchored
        : new RecordRange<MinorBlockRecord>(args.anchored);
    this.lastBlockTime =
      args.lastBlockTime == undefined
        ? undefined
        : args.lastBlockTime instanceof Date
        ? args.lastBlockTime
        : new Date(args.lastBlockTime);
  }

  copy() {
    return new MinorBlockRecord(this.asObject());
  }

  asObject(): MinorBlockRecordArgsWithType {
    return {
      recordType: "minorBlock",
      index: this.index && this.index,
      time: this.time && this.time,
      source: this.source && this.source.toString(),
      entries: this.entries && this.entries.asObject(),
      anchored: this.anchored && this.anchored.asObject(),
      lastBlockTime: this.lastBlockTime && this.lastBlockTime,
    };
  }
}

export type NetworkStatusArgs = {
  oracle?: protocol.AcmeOracle | protocol.AcmeOracleArgs;
  globals?: protocol.NetworkGlobals | protocol.NetworkGlobalsArgs;
  network?: protocol.NetworkDefinition | protocol.NetworkDefinitionArgs;
  routing?: protocol.RoutingTable | protocol.RoutingTableArgs;
  executorVersion?: protocol.ExecutorVersionArgs;
  directoryHeight?: number;
  majorBlockHeight?: number;
  bvnExecutorVersions?: (
    | protocol.PartitionExecutorVersion
    | protocol.PartitionExecutorVersionArgs
  )[];
};
export class NetworkStatus {
  @encodeAs.field(1).reference
  public oracle?: protocol.AcmeOracle;
  @encodeAs.field(2).reference
  public globals?: protocol.NetworkGlobals;
  @encodeAs.field(3).reference
  public network?: protocol.NetworkDefinition;
  @encodeAs.field(4).reference
  public routing?: protocol.RoutingTable;
  @encodeAs.field(5).enum
  public executorVersion?: protocol.ExecutorVersion;
  @encodeAs.field(6).uint
  public directoryHeight?: number;
  @encodeAs.field(7).uint
  public majorBlockHeight?: number;
  @encodeAs.field(8).repeatable.reference
  public bvnExecutorVersions?: protocol.PartitionExecutorVersion[];

  constructor(args: NetworkStatusArgs) {
    this.oracle =
      args.oracle == undefined
        ? undefined
        : args.oracle instanceof protocol.AcmeOracle
        ? args.oracle
        : new protocol.AcmeOracle(args.oracle);
    this.globals =
      args.globals == undefined
        ? undefined
        : args.globals instanceof protocol.NetworkGlobals
        ? args.globals
        : new protocol.NetworkGlobals(args.globals);
    this.network =
      args.network == undefined
        ? undefined
        : args.network instanceof protocol.NetworkDefinition
        ? args.network
        : new protocol.NetworkDefinition(args.network);
    this.routing =
      args.routing == undefined
        ? undefined
        : args.routing instanceof protocol.RoutingTable
        ? args.routing
        : new protocol.RoutingTable(args.routing);
    this.executorVersion =
      args.executorVersion == undefined
        ? undefined
        : protocol.ExecutorVersion.fromObject(args.executorVersion);
    this.directoryHeight = args.directoryHeight == undefined ? undefined : args.directoryHeight;
    this.majorBlockHeight = args.majorBlockHeight == undefined ? undefined : args.majorBlockHeight;
    this.bvnExecutorVersions =
      args.bvnExecutorVersions == undefined
        ? undefined
        : args.bvnExecutorVersions.map((v) =>
            v instanceof protocol.PartitionExecutorVersion
              ? v
              : new protocol.PartitionExecutorVersion(v)
          );
  }

  copy() {
    return new NetworkStatus(this.asObject());
  }

  asObject(): NetworkStatusArgs {
    return {
      oracle: this.oracle && this.oracle.asObject(),
      globals: this.globals && this.globals.asObject(),
      network: this.network && this.network.asObject(),
      routing: this.routing && this.routing.asObject(),
      executorVersion:
        this.executorVersion && protocol.ExecutorVersion.getName(this.executorVersion),
      directoryHeight: this.directoryHeight && this.directoryHeight,
      majorBlockHeight: this.majorBlockHeight && this.majorBlockHeight,
      bvnExecutorVersions:
        this.bvnExecutorVersions && this.bvnExecutorVersions?.map((v) => v.asObject()),
    };
  }
}

export type NetworkStatusOptionsArgs = {
  partition?: string;
};
export class NetworkStatusOptions {
  @encodeAs.field(1).string
  public partition?: string;

  constructor(args: NetworkStatusOptionsArgs) {
    this.partition = args.partition == undefined ? undefined : args.partition;
  }

  copy() {
    return new NetworkStatusOptions(this.asObject());
  }

  asObject(): NetworkStatusOptionsArgs {
    return {
      partition: this.partition && this.partition,
    };
  }
}

export type NodeInfoArgs = {
  peerID?: p2p.PeerID | p2p.PeerIDArgs;
  network?: string;
  services?: (ServiceAddress | ServiceAddressArgs)[];
  version?: string;
  commit?: string;
};
export class NodeInfo {
  @encodeAs.field(1).union
  public peerID?: p2p.PeerID;
  @encodeAs.field(2).string
  public network?: string;
  @encodeAs.field(3).repeatable.reference
  public services?: ServiceAddress[];
  @encodeAs.field(4).string
  public version?: string;
  @encodeAs.field(5).string
  public commit?: string;

  constructor(args: NodeInfoArgs) {
    this.peerID = args.peerID == undefined ? undefined : p2p.PeerID.fromObject(args.peerID);
    this.network = args.network == undefined ? undefined : args.network;
    this.services =
      args.services == undefined
        ? undefined
        : args.services.map((v) => (v instanceof ServiceAddress ? v : new ServiceAddress(v)));
    this.version = args.version == undefined ? undefined : args.version;
    this.commit = args.commit == undefined ? undefined : args.commit;
  }

  copy() {
    return new NodeInfo(this.asObject());
  }

  asObject(): NodeInfoArgs {
    return {
      peerID: this.peerID && this.peerID.asObject(),
      network: this.network && this.network,
      services: this.services && this.services?.map((v) => v.asObject()),
      version: this.version && this.version,
      commit: this.commit && this.commit,
    };
  }
}

export type NodeInfoOptionsArgs = {
  peerID?: p2p.PeerID | p2p.PeerIDArgs;
};
export class NodeInfoOptions {
  @encodeAs.field(1).union
  public peerID?: p2p.PeerID;

  constructor(args: NodeInfoOptionsArgs) {
    this.peerID = args.peerID == undefined ? undefined : p2p.PeerID.fromObject(args.peerID);
  }

  copy() {
    return new NodeInfoOptions(this.asObject());
  }

  asObject(): NodeInfoOptionsArgs {
    return {
      peerID: this.peerID && this.peerID.asObject(),
    };
  }
}

export type PendingQueryArgs = {
  range?: RangeOptions | RangeOptionsArgs;
};
export type PendingQueryArgsWithType = PendingQueryArgs & {
  queryType: QueryType.Pending | "pending";
};
export class PendingQuery {
  @encodeAs.field(1).keepEmpty.enum.of(QueryType)
  public readonly queryType = QueryType.Pending;
  @encodeAs.field(2).reference
  public range?: RangeOptions;

  constructor(args: PendingQueryArgs) {
    this.range =
      args.range == undefined
        ? undefined
        : args.range instanceof RangeOptions
        ? args.range
        : new RangeOptions(args.range);
  }

  copy() {
    return new PendingQuery(this.asObject());
  }

  asObject(): PendingQueryArgsWithType {
    return {
      queryType: "pending",
      range: this.range && this.range.asObject(),
    };
  }
}

export type PublicKeyHashSearchQueryArgs = {
  publicKeyHash?: Uint8Array | string;
};
export type PublicKeyHashSearchQueryArgsWithType = PublicKeyHashSearchQueryArgs & {
  queryType: QueryType.PublicKeyHashSearch | "publicKeyHashSearch";
};
export class PublicKeyHashSearchQuery {
  @encodeAs.field(1).keepEmpty.enum.of(QueryType)
  public readonly queryType = QueryType.PublicKeyHashSearch;
  @encodeAs.field(2).bytes
  public publicKeyHash?: Uint8Array;

  constructor(args: PublicKeyHashSearchQueryArgs) {
    this.publicKeyHash =
      args.publicKeyHash == undefined
        ? undefined
        : args.publicKeyHash instanceof Uint8Array
        ? args.publicKeyHash
        : Buffer.from(args.publicKeyHash, "hex");
  }

  copy() {
    return new PublicKeyHashSearchQuery(this.asObject());
  }

  asObject(): PublicKeyHashSearchQueryArgsWithType {
    return {
      queryType: "publicKeyHashSearch",
      publicKeyHash:
        this.publicKeyHash && this.publicKeyHash && Buffer.from(this.publicKeyHash).toString("hex"),
    };
  }
}

export type PublicKeySearchQueryArgs = {
  publicKey?: Uint8Array | string;
  type?: protocol.SignatureTypeArgs;
};
export type PublicKeySearchQueryArgsWithType = PublicKeySearchQueryArgs & {
  queryType: QueryType.PublicKeySearch | "publicKeySearch";
};
export class PublicKeySearchQuery {
  @encodeAs.field(1).keepEmpty.enum.of(QueryType)
  public readonly queryType = QueryType.PublicKeySearch;
  @encodeAs.field(2).bytes
  public publicKey?: Uint8Array;
  @encodeAs.field(3).enum
  public type?: protocol.SignatureType;

  constructor(args: PublicKeySearchQueryArgs) {
    this.publicKey =
      args.publicKey == undefined
        ? undefined
        : args.publicKey instanceof Uint8Array
        ? args.publicKey
        : Buffer.from(args.publicKey, "hex");
    this.type = args.type == undefined ? undefined : protocol.SignatureType.fromObject(args.type);
  }

  copy() {
    return new PublicKeySearchQuery(this.asObject());
  }

  asObject(): PublicKeySearchQueryArgsWithType {
    return {
      queryType: "publicKeySearch",
      publicKey: this.publicKey && this.publicKey && Buffer.from(this.publicKey).toString("hex"),
      type: this.type && protocol.SignatureType.getName(this.type),
    };
  }
}

export type RangeOptionsArgs = {
  start?: number;
  count?: number;
  expand?: boolean;
  fromEnd?: boolean;
};
export class RangeOptions {
  @encodeAs.field(1).uint
  public start?: number;
  @encodeAs.field(2).uint
  public count?: number;
  @encodeAs.field(3).bool
  public expand?: boolean;
  @encodeAs.field(4).bool
  public fromEnd?: boolean;

  constructor(args: RangeOptionsArgs) {
    this.start = args.start == undefined ? undefined : args.start;
    this.count = args.count == undefined ? undefined : args.count;
    this.expand = args.expand == undefined ? undefined : args.expand;
    this.fromEnd = args.fromEnd == undefined ? undefined : args.fromEnd;
  }

  copy() {
    return new RangeOptions(this.asObject());
  }

  asObject(): RangeOptionsArgs {
    return {
      start: this.start && this.start,
      count: this.count && this.count,
      expand: this.expand && this.expand,
      fromEnd: this.fromEnd && this.fromEnd,
    };
  }
}

export type ReceiptArgs = {
  start?: Uint8Array | string;
  startIndex?: number;
  end?: Uint8Array | string;
  endIndex?: number;
  anchor?: Uint8Array | string;
  entries?: (merkle.ReceiptEntry | merkle.ReceiptEntryArgs)[];
  localBlock?: number;
  localBlockTime?: Date | string;
  majorBlock?: number;
};
export class Receipt {
  @encodeAs.field(1, 1).bytes
  public start?: Uint8Array;
  @encodeAs.field(1, 2).int
  public startIndex?: number;
  @encodeAs.field(1, 3).bytes
  public end?: Uint8Array;
  @encodeAs.field(1, 4).int
  public endIndex?: number;
  @encodeAs.field(1, 5).bytes
  public anchor?: Uint8Array;
  @encodeAs.field(1, 6).repeatable.reference
  public entries?: merkle.ReceiptEntry[];
  @encodeAs.field(2).uint
  public localBlock?: number;
  @encodeAs.field(3).time
  public localBlockTime?: Date;
  @encodeAs.field(4).uint
  public majorBlock?: number;

  constructor(args: ReceiptArgs) {
    this.start =
      args.start == undefined
        ? undefined
        : args.start instanceof Uint8Array
        ? args.start
        : Buffer.from(args.start, "hex");
    this.startIndex = args.startIndex == undefined ? undefined : args.startIndex;
    this.end =
      args.end == undefined
        ? undefined
        : args.end instanceof Uint8Array
        ? args.end
        : Buffer.from(args.end, "hex");
    this.endIndex = args.endIndex == undefined ? undefined : args.endIndex;
    this.anchor =
      args.anchor == undefined
        ? undefined
        : args.anchor instanceof Uint8Array
        ? args.anchor
        : Buffer.from(args.anchor, "hex");
    this.entries =
      args.entries == undefined
        ? undefined
        : args.entries.map((v) =>
            v instanceof merkle.ReceiptEntry ? v : new merkle.ReceiptEntry(v)
          );
    this.localBlock = args.localBlock == undefined ? undefined : args.localBlock;
    this.localBlockTime =
      args.localBlockTime == undefined
        ? undefined
        : args.localBlockTime instanceof Date
        ? args.localBlockTime
        : new Date(args.localBlockTime);
    this.majorBlock = args.majorBlock == undefined ? undefined : args.majorBlock;
  }

  copy() {
    return new Receipt(this.asObject());
  }

  asObject(): ReceiptArgs {
    return {
      start: this.start && this.start && Buffer.from(this.start).toString("hex"),
      startIndex: this.startIndex && this.startIndex,
      end: this.end && this.end && Buffer.from(this.end).toString("hex"),
      endIndex: this.endIndex && this.endIndex,
      anchor: this.anchor && this.anchor && Buffer.from(this.anchor).toString("hex"),
      entries: this.entries && this.entries?.map((v) => v.asObject()),
      localBlock: this.localBlock && this.localBlock,
      localBlockTime: this.localBlockTime && this.localBlockTime,
      majorBlock: this.majorBlock && this.majorBlock,
    };
  }
}

export type ReceiptOptionsArgs = {
  forAny?: boolean;
  forHeight?: number;
};
export class ReceiptOptions {
  @encodeAs.field(1).bool
  public forAny?: boolean;
  @encodeAs.field(2).uint
  public forHeight?: number;

  constructor(args: ReceiptOptionsArgs) {
    this.forAny = args.forAny == undefined ? undefined : args.forAny;
    this.forHeight = args.forHeight == undefined ? undefined : args.forHeight;
  }

  copy() {
    return new ReceiptOptions(this.asObject());
  }

  asObject(): ReceiptOptionsArgs {
    return {
      forAny: this.forAny && this.forAny,
      forHeight: this.forHeight && this.forHeight,
    };
  }
}

export type RecordRangeArgs<T extends Record = Record> = {
  records?: (T | RecordArgs) /* TODO RecordArgs is too broad */[];
  start?: number;
  total?: number;
  lastBlockTime?: Date | string;
};
export type RecordRangeArgsWithType<T extends Record = Record> = RecordRangeArgs<T> & {
  recordType: RecordType.Range | "range";
};
export class RecordRange<T extends Record = Record> {
  @encodeAs.field(1).keepEmpty.enum.of(RecordType)
  public readonly recordType = RecordType.Range;
  @encodeAs.field(2).repeatable.union
  public records?: T[];
  @encodeAs.field(3).keepEmpty.uint
  public start?: number;
  @encodeAs.field(4).keepEmpty.uint
  public total?: number;
  @encodeAs.field(5).time
  public lastBlockTime?: Date;

  constructor(args: RecordRangeArgs<T>) {
    this.records =
      args.records == undefined ? undefined : args.records.map((v) => <T>Record.fromObject(v));
    this.start = args.start == undefined ? undefined : args.start;
    this.total = args.total == undefined ? undefined : args.total;
    this.lastBlockTime =
      args.lastBlockTime == undefined
        ? undefined
        : args.lastBlockTime instanceof Date
        ? args.lastBlockTime
        : new Date(args.lastBlockTime);
  }

  copy() {
    return new RecordRange<T>(this.asObject());
  }

  asObject(): RecordRangeArgsWithType<T> {
    return {
      recordType: "range",
      records: this.records && this.records?.map((v) => v.asObject()),
      start: this.start && this.start,
      total: this.total && this.total,
      lastBlockTime: this.lastBlockTime && this.lastBlockTime,
    };
  }
}

export type ServiceAddressArgs = {
  type?: ServiceType;
  argument?: string;
};
export class ServiceAddress {
  @encodeAs.field(1).uint
  public type?: ServiceType;
  @encodeAs.field(2).string
  public argument?: string;

  constructor(args: ServiceAddressArgs) {
    this.type = args.type == undefined ? undefined : args.type;
    this.argument = args.argument == undefined ? undefined : args.argument;
  }

  copy() {
    return new ServiceAddress(this.asObject());
  }

  asObject(): ServiceAddressArgs {
    return {
      type: this.type && this.type,
      argument: this.argument && this.argument,
    };
  }
}

export type SignatureSetRecordArgs = {
  account?: protocol.Account | protocol.AccountArgs;
  signatures?:
    | RecordRange<MessageRecord<messaging.Message>>
    | RecordRangeArgs<MessageRecord<messaging.Message>>;
};
export type SignatureSetRecordArgsWithType = SignatureSetRecordArgs & {
  recordType: RecordType.SignatureSet | "signatureSet";
};
export class SignatureSetRecord {
  @encodeAs.field(1).keepEmpty.enum.of(RecordType)
  public readonly recordType = RecordType.SignatureSet;
  @encodeAs.field(2).union
  public account?: protocol.Account;
  @encodeAs.field(3).reference
  public signatures?: RecordRange<MessageRecord<messaging.Message>>;

  constructor(args: SignatureSetRecordArgs) {
    this.account =
      args.account == undefined ? undefined : protocol.Account.fromObject(args.account);
    this.signatures =
      args.signatures == undefined
        ? undefined
        : args.signatures instanceof RecordRange<MessageRecord<messaging.Message>>
        ? args.signatures
        : new RecordRange<MessageRecord<messaging.Message>>(args.signatures);
  }

  copy() {
    return new SignatureSetRecord(this.asObject());
  }

  asObject(): SignatureSetRecordArgsWithType {
    return {
      recordType: "signatureSet",
      account: this.account && this.account.asObject(),
      signatures: this.signatures && this.signatures.asObject(),
    };
  }
}

export type SubmissionArgs = {
  status?: protocol.TransactionStatus | protocol.TransactionStatusArgs;
  success?: boolean;
  message?: string;
};
export class Submission {
  @encodeAs.field(1).reference
  public status?: protocol.TransactionStatus;
  @encodeAs.field(2).bool
  public success?: boolean;
  @encodeAs.field(3).string
  public message?: string;

  constructor(args: SubmissionArgs) {
    this.status =
      args.status == undefined
        ? undefined
        : args.status instanceof protocol.TransactionStatus
        ? args.status
        : new protocol.TransactionStatus(args.status);
    this.success = args.success == undefined ? undefined : args.success;
    this.message = args.message == undefined ? undefined : args.message;
  }

  copy() {
    return new Submission(this.asObject());
  }

  asObject(): SubmissionArgs {
    return {
      status: this.status && this.status.asObject(),
      success: this.success && this.success,
      message: this.message && this.message,
    };
  }
}

export type SubmitOptionsArgs = {
  verify?: boolean;
  wait?: boolean;
};
export class SubmitOptions {
  @encodeAs.field(1).bool
  public verify?: boolean;
  @encodeAs.field(2).bool
  public wait?: boolean;

  constructor(args: SubmitOptionsArgs) {
    this.verify = args.verify == undefined ? undefined : args.verify;
    this.wait = args.wait == undefined ? undefined : args.wait;
  }

  copy() {
    return new SubmitOptions(this.asObject());
  }

  asObject(): SubmitOptionsArgs {
    return {
      verify: this.verify && this.verify,
      wait: this.wait && this.wait,
    };
  }
}

export type SubscribeOptionsArgs = {
  partition?: string;
  account?: URLArgs;
};
export class SubscribeOptions {
  @encodeAs.field(1).string
  public partition?: string;
  @encodeAs.field(2).url
  public account?: URL;

  constructor(args: SubscribeOptionsArgs) {
    this.partition = args.partition == undefined ? undefined : args.partition;
    this.account = args.account == undefined ? undefined : URL.parse(args.account);
  }

  copy() {
    return new SubscribeOptions(this.asObject());
  }

  asObject(): SubscribeOptionsArgs {
    return {
      partition: this.partition && this.partition,
      account: this.account && this.account.toString(),
    };
  }
}

export type TxIDRecordArgs = {
  value?: TxIDArgs;
};
export type TxIDRecordArgsWithType = TxIDRecordArgs & { recordType: RecordType.TxID | "txID" };
export class TxIDRecord {
  @encodeAs.field(1).keepEmpty.enum.of(RecordType)
  public readonly recordType = RecordType.TxID;
  @encodeAs.field(2).txid
  public value?: TxID;

  constructor(args: TxIDRecordArgs) {
    this.value = args.value == undefined ? undefined : TxID.parse(args.value);
  }

  copy() {
    return new TxIDRecord(this.asObject());
  }

  asObject(): TxIDRecordArgsWithType {
    return {
      recordType: "txID",
      value: this.value && this.value.toString(),
    };
  }
}

export type UrlRecordArgs = {
  value?: URLArgs;
};
export type UrlRecordArgsWithType = UrlRecordArgs & { recordType: RecordType.Url | "url" };
export class UrlRecord {
  @encodeAs.field(1).keepEmpty.enum.of(RecordType)
  public readonly recordType = RecordType.Url;
  @encodeAs.field(2).url
  public value?: URL;

  constructor(args: UrlRecordArgs) {
    this.value = args.value == undefined ? undefined : URL.parse(args.value);
  }

  copy() {
    return new UrlRecord(this.asObject());
  }

  asObject(): UrlRecordArgsWithType {
    return {
      recordType: "url",
      value: this.value && this.value.toString(),
    };
  }
}

export type ValidateOptionsArgs = {
  full?: boolean;
};
export class ValidateOptions {
  @encodeAs.field(1).bool
  public full?: boolean;

  constructor(args: ValidateOptionsArgs) {
    this.full = args.full == undefined ? undefined : args.full;
  }

  copy() {
    return new ValidateOptions(this.asObject());
  }

  asObject(): ValidateOptionsArgs {
    return {
      full: this.full && this.full,
    };
  }
}
