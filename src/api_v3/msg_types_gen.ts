import * as api from "./index.js";
import { AccumulateURL as URL, URLArgs } from "../address/url.js";
import { encodeAs } from "../encoding/index.js";
import * as errors2 from "../errors/index.js";
import * as messaging from "../messaging/index.js";
import { MessageType } from "./msg.js";
import * as p2p from "./p2p.js";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */

export type ConsensusStatusRequestArgs = {
  nodeID?: string;
  partition?: string;
  includePeers?: boolean;
  includeAccumulate?: boolean;
};
export type ConsensusStatusRequestArgsWithType = ConsensusStatusRequestArgs & {
  type: MessageType.ConsensusStatusRequest | "consensusStatusRequest";
};
export class ConsensusStatusRequest {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.ConsensusStatusRequest;
  @(encodeAs.field(2, 1).string)
  public nodeID?: string;
  @(encodeAs.field(2, 2).string)
  public partition?: string;
  @(encodeAs.field(2, 3).bool)
  public includePeers?: boolean;
  @(encodeAs.field(2, 4).bool)
  public includeAccumulate?: boolean;

  constructor(args: ConsensusStatusRequestArgs) {
    this.nodeID = args.nodeID == undefined ? undefined : args.nodeID;
    this.partition = args.partition == undefined ? undefined : args.partition;
    this.includePeers = args.includePeers == undefined ? undefined : args.includePeers;
    this.includeAccumulate =
      args.includeAccumulate == undefined ? undefined : args.includeAccumulate;
  }

  copy() {
    return new ConsensusStatusRequest(this.asObject());
  }

  asObject(): ConsensusStatusRequestArgsWithType {
    return {
      type: "consensusStatusRequest",
      nodeID: this.nodeID === undefined ? undefined : this.nodeID,
      partition: this.partition === undefined ? undefined : this.partition,
      includePeers: this.includePeers === undefined ? undefined : this.includePeers,
      includeAccumulate: this.includeAccumulate === undefined ? undefined : this.includeAccumulate,
    };
  }
}

export type ConsensusStatusResponseArgs = {
  value?: api.ConsensusStatus | api.ConsensusStatusArgs;
};
export type ConsensusStatusResponseArgsWithType = ConsensusStatusResponseArgs & {
  type: MessageType.ConsensusStatusResponse | "consensusStatusResponse";
};
export class ConsensusStatusResponse {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.ConsensusStatusResponse;
  @(encodeAs.field(2).reference)
  public value?: api.ConsensusStatus;

  constructor(args: ConsensusStatusResponseArgs) {
    this.value =
      args.value == undefined
        ? undefined
        : args.value instanceof api.ConsensusStatus
          ? args.value
          : new api.ConsensusStatus(args.value);
  }

  copy() {
    return new ConsensusStatusResponse(this.asObject());
  }

  asObject(): ConsensusStatusResponseArgsWithType {
    return {
      type: "consensusStatusResponse",
      value: this.value === undefined ? undefined : this.value.asObject(),
    };
  }
}

export type ErrorResponseArgs = {
  error?: errors2.Error | errors2.ErrorArgs;
};
export type ErrorResponseArgsWithType = ErrorResponseArgs & {
  type: MessageType.ErrorResponse | "errorResponse";
};
export class ErrorResponse {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.ErrorResponse;
  @(encodeAs.field(2).reference)
  public error?: errors2.Error;

  constructor(args: ErrorResponseArgs) {
    this.error =
      args.error == undefined
        ? undefined
        : args.error instanceof errors2.Error
          ? args.error
          : new errors2.Error(args.error);
  }

  copy() {
    return new ErrorResponse(this.asObject());
  }

  asObject(): ErrorResponseArgsWithType {
    return {
      type: "errorResponse",
      error: this.error === undefined ? undefined : this.error.asObject(),
    };
  }
}

export type EventMessageArgs = {
  value?: (api.Event | api.EventArgs | undefined)[];
};
export type EventMessageArgsWithType = EventMessageArgs & { type: MessageType.Event | "event" };
export class EventMessage {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.Event;
  @(encodeAs.field(2).repeatable.keepEmpty.union)
  public value?: (api.Event | undefined)[];

  constructor(args: EventMessageArgs) {
    this.value =
      args.value == undefined
        ? undefined
        : args.value.map((v) => (v == undefined ? undefined : api.Event.fromObject(v)));
  }

  copy() {
    return new EventMessage(this.asObject());
  }

  asObject(): EventMessageArgsWithType {
    return {
      type: "event",
      value:
        this.value === undefined
          ? undefined
          : this.value?.map((v) => (v == undefined ? undefined : v.asObject())),
    };
  }
}

export type FaucetRequestArgs = {
  account?: URLArgs;
  token?: URLArgs;
};
export type FaucetRequestArgsWithType = FaucetRequestArgs & {
  type: MessageType.FaucetRequest | "faucetRequest";
};
export class FaucetRequest {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.FaucetRequest;
  @(encodeAs.field(2).url)
  public account?: URL;
  @(encodeAs.field(3, 1).url)
  public token?: URL;

  constructor(args: FaucetRequestArgs) {
    this.account = args.account == undefined ? undefined : URL.parse(args.account);
    this.token = args.token == undefined ? undefined : URL.parse(args.token);
  }

  copy() {
    return new FaucetRequest(this.asObject());
  }

  asObject(): FaucetRequestArgsWithType {
    return {
      type: "faucetRequest",
      account: this.account === undefined ? undefined : this.account.toString(),
      token: this.token === undefined ? undefined : this.token.toString(),
    };
  }
}

export type FaucetResponseArgs = {
  value?: api.Submission | api.SubmissionArgs;
};
export type FaucetResponseArgsWithType = FaucetResponseArgs & {
  type: MessageType.FaucetResponse | "faucetResponse";
};
export class FaucetResponse {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.FaucetResponse;
  @(encodeAs.field(2).reference)
  public value?: api.Submission;

  constructor(args: FaucetResponseArgs) {
    this.value =
      args.value == undefined
        ? undefined
        : args.value instanceof api.Submission
          ? args.value
          : new api.Submission(args.value);
  }

  copy() {
    return new FaucetResponse(this.asObject());
  }

  asObject(): FaucetResponseArgsWithType {
    return {
      type: "faucetResponse",
      value: this.value === undefined ? undefined : this.value.asObject(),
    };
  }
}

export type FindServiceRequestArgs = {
  network?: string;
  service?: api.ServiceAddress | api.ServiceAddressArgs;
  known?: boolean;
  timeout?: number;
};
export type FindServiceRequestArgsWithType = FindServiceRequestArgs & {
  type: MessageType.FindServiceRequest | "findServiceRequest";
};
export class FindServiceRequest {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.FindServiceRequest;
  @(encodeAs.field(2, 1).string)
  public network?: string;
  @(encodeAs.field(2, 2).reference)
  public service?: api.ServiceAddress;
  @(encodeAs.field(2, 3).bool)
  public known?: boolean;
  @(encodeAs.field(2, 4).duration)
  public timeout?: number;

  constructor(args: FindServiceRequestArgs) {
    this.network = args.network == undefined ? undefined : args.network;
    this.service =
      args.service == undefined
        ? undefined
        : args.service instanceof api.ServiceAddress
          ? args.service
          : new api.ServiceAddress(args.service);
    this.known = args.known == undefined ? undefined : args.known;
    this.timeout = args.timeout == undefined ? undefined : args.timeout;
  }

  copy() {
    return new FindServiceRequest(this.asObject());
  }

  asObject(): FindServiceRequestArgsWithType {
    return {
      type: "findServiceRequest",
      network: this.network === undefined ? undefined : this.network,
      service: this.service === undefined ? undefined : this.service.asObject(),
      known: this.known === undefined ? undefined : this.known,
      timeout: this.timeout === undefined ? undefined : this.timeout,
    };
  }
}

export type FindServiceResponseArgs = {
  value?: (api.FindServiceResult | api.FindServiceResultArgs | undefined)[];
};
export type FindServiceResponseArgsWithType = FindServiceResponseArgs & {
  type: MessageType.FindServiceResponse | "findServiceResponse";
};
export class FindServiceResponse {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.FindServiceResponse;
  @(encodeAs.field(2).repeatable.keepEmpty.reference)
  public value?: (api.FindServiceResult | undefined)[];

  constructor(args: FindServiceResponseArgs) {
    this.value =
      args.value == undefined
        ? undefined
        : args.value.map((v) =>
            v == undefined
              ? undefined
              : v instanceof api.FindServiceResult
                ? v
                : new api.FindServiceResult(v),
          );
  }

  copy() {
    return new FindServiceResponse(this.asObject());
  }

  asObject(): FindServiceResponseArgsWithType {
    return {
      type: "findServiceResponse",
      value:
        this.value === undefined
          ? undefined
          : this.value?.map((v) => (v == undefined ? undefined : v.asObject())),
    };
  }
}

export type NetworkStatusRequestArgs = {
  partition?: string;
};
export type NetworkStatusRequestArgsWithType = NetworkStatusRequestArgs & {
  type: MessageType.NetworkStatusRequest | "networkStatusRequest";
};
export class NetworkStatusRequest {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.NetworkStatusRequest;
  @(encodeAs.field(2, 1).string)
  public partition?: string;

  constructor(args: NetworkStatusRequestArgs) {
    this.partition = args.partition == undefined ? undefined : args.partition;
  }

  copy() {
    return new NetworkStatusRequest(this.asObject());
  }

  asObject(): NetworkStatusRequestArgsWithType {
    return {
      type: "networkStatusRequest",
      partition: this.partition === undefined ? undefined : this.partition,
    };
  }
}

export type NetworkStatusResponseArgs = {
  value?: api.NetworkStatus | api.NetworkStatusArgs;
};
export type NetworkStatusResponseArgsWithType = NetworkStatusResponseArgs & {
  type: MessageType.NetworkStatusResponse | "networkStatusResponse";
};
export class NetworkStatusResponse {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.NetworkStatusResponse;
  @(encodeAs.field(2).reference)
  public value?: api.NetworkStatus;

  constructor(args: NetworkStatusResponseArgs) {
    this.value =
      args.value == undefined
        ? undefined
        : args.value instanceof api.NetworkStatus
          ? args.value
          : new api.NetworkStatus(args.value);
  }

  copy() {
    return new NetworkStatusResponse(this.asObject());
  }

  asObject(): NetworkStatusResponseArgsWithType {
    return {
      type: "networkStatusResponse",
      value: this.value === undefined ? undefined : this.value.asObject(),
    };
  }
}

export type NodeInfoRequestArgs = {
  peerID?: p2p.PeerID | p2p.PeerIDArgs;
};
export type NodeInfoRequestArgsWithType = NodeInfoRequestArgs & {
  type: MessageType.NodeInfoRequest | "nodeInfoRequest";
};
export class NodeInfoRequest {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.NodeInfoRequest;
  @(encodeAs.field(2, 1).union)
  public peerID?: p2p.PeerID;

  constructor(args: NodeInfoRequestArgs) {
    this.peerID = args.peerID == undefined ? undefined : p2p.PeerID.fromObject(args.peerID);
  }

  copy() {
    return new NodeInfoRequest(this.asObject());
  }

  asObject(): NodeInfoRequestArgsWithType {
    return {
      type: "nodeInfoRequest",
      peerID: this.peerID === undefined ? undefined : this.peerID.asObject(),
    };
  }
}

export type NodeInfoResponseArgs = {
  value?: api.NodeInfo | api.NodeInfoArgs;
};
export type NodeInfoResponseArgsWithType = NodeInfoResponseArgs & {
  type: MessageType.NodeInfoResponse | "nodeInfoResponse";
};
export class NodeInfoResponse {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.NodeInfoResponse;
  @(encodeAs.field(2).reference)
  public value?: api.NodeInfo;

  constructor(args: NodeInfoResponseArgs) {
    this.value =
      args.value == undefined
        ? undefined
        : args.value instanceof api.NodeInfo
          ? args.value
          : new api.NodeInfo(args.value);
  }

  copy() {
    return new NodeInfoResponse(this.asObject());
  }

  asObject(): NodeInfoResponseArgsWithType {
    return {
      type: "nodeInfoResponse",
      value: this.value === undefined ? undefined : this.value.asObject(),
    };
  }
}

export type PrivateSequenceRequestArgs = {
  source?: URLArgs;
  destination?: URLArgs;
  sequenceNumber?: number;
  nodeID?: p2p.PeerID | p2p.PeerIDArgs;
};
export type PrivateSequenceRequestArgsWithType = PrivateSequenceRequestArgs & {
  type: MessageType.PrivateSequenceRequest | "privateSequenceRequest";
};
export class PrivateSequenceRequest {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.PrivateSequenceRequest;
  @(encodeAs.field(2).url)
  public source?: URL;
  @(encodeAs.field(3).url)
  public destination?: URL;
  @(encodeAs.field(4).uint)
  public sequenceNumber?: number;
  @(encodeAs.field(5, 1).union)
  public nodeID?: p2p.PeerID;

  constructor(args: PrivateSequenceRequestArgs) {
    this.source = args.source == undefined ? undefined : URL.parse(args.source);
    this.destination = args.destination == undefined ? undefined : URL.parse(args.destination);
    this.sequenceNumber = args.sequenceNumber == undefined ? undefined : args.sequenceNumber;
    this.nodeID = args.nodeID == undefined ? undefined : p2p.PeerID.fromObject(args.nodeID);
  }

  copy() {
    return new PrivateSequenceRequest(this.asObject());
  }

  asObject(): PrivateSequenceRequestArgsWithType {
    return {
      type: "privateSequenceRequest",
      source: this.source === undefined ? undefined : this.source.toString(),
      destination: this.destination === undefined ? undefined : this.destination.toString(),
      sequenceNumber: this.sequenceNumber === undefined ? undefined : this.sequenceNumber,
      nodeID: this.nodeID === undefined ? undefined : this.nodeID.asObject(),
    };
  }
}

export type PrivateSequenceResponseArgs = {
  value?: api.MessageRecord<messaging.Message> | api.MessageRecordArgs<messaging.Message>;
};
export type PrivateSequenceResponseArgsWithType = PrivateSequenceResponseArgs & {
  type: MessageType.PrivateSequenceResponse | "privateSequenceResponse";
};
export class PrivateSequenceResponse {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.PrivateSequenceResponse;
  @(encodeAs.field(2).reference)
  public value?: api.MessageRecord<messaging.Message>;

  constructor(args: PrivateSequenceResponseArgs) {
    this.value =
      args.value == undefined
        ? undefined
        : args.value instanceof api.MessageRecord<messaging.Message>
          ? args.value
          : new api.MessageRecord<messaging.Message>(args.value);
  }

  copy() {
    return new PrivateSequenceResponse(this.asObject());
  }

  asObject(): PrivateSequenceResponseArgsWithType {
    return {
      type: "privateSequenceResponse",
      value: this.value === undefined ? undefined : this.value.asObject(),
    };
  }
}

export type QueryRequestArgs = {
  scope?: URLArgs;
  query?: api.Query | api.QueryArgs;
};
export type QueryRequestArgsWithType = QueryRequestArgs & {
  type: MessageType.QueryRequest | "queryRequest";
};
export class QueryRequest {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.QueryRequest;
  @(encodeAs.field(2).url)
  public scope?: URL;
  @(encodeAs.field(3).union)
  public query?: api.Query;

  constructor(args: QueryRequestArgs) {
    this.scope = args.scope == undefined ? undefined : URL.parse(args.scope);
    this.query = args.query == undefined ? undefined : api.Query.fromObject(args.query);
  }

  copy() {
    return new QueryRequest(this.asObject());
  }

  asObject(): QueryRequestArgsWithType {
    return {
      type: "queryRequest",
      scope: this.scope === undefined ? undefined : this.scope.toString(),
      query: this.query === undefined ? undefined : this.query.asObject(),
    };
  }
}

export type RecordResponseArgs = {
  value?: api.Record | api.RecordArgs;
};
export type RecordResponseArgsWithType = RecordResponseArgs & {
  type: MessageType.RecordResponse | "recordResponse";
};
export class RecordResponse {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.RecordResponse;
  @(encodeAs.field(2).union)
  public value?: api.Record;

  constructor(args: RecordResponseArgs) {
    this.value = args.value == undefined ? undefined : api.Record.fromObject(args.value);
  }

  copy() {
    return new RecordResponse(this.asObject());
  }

  asObject(): RecordResponseArgsWithType {
    return {
      type: "recordResponse",
      value: this.value === undefined ? undefined : this.value.asObject(),
    };
  }
}

export type SubmitRequestArgs = {
  envelope?: messaging.Envelope | messaging.EnvelopeArgs;
  verify?: boolean;
  wait?: boolean;
};
export type SubmitRequestArgsWithType = SubmitRequestArgs & {
  type: MessageType.SubmitRequest | "submitRequest";
};
export class SubmitRequest {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.SubmitRequest;
  @(encodeAs.field(2).reference)
  public envelope?: messaging.Envelope;
  @(encodeAs.field(3, 1).bool)
  public verify?: boolean;
  @(encodeAs.field(3, 2).bool)
  public wait?: boolean;

  constructor(args: SubmitRequestArgs) {
    this.envelope =
      args.envelope == undefined
        ? undefined
        : args.envelope instanceof messaging.Envelope
          ? args.envelope
          : new messaging.Envelope(args.envelope);
    this.verify = args.verify == undefined ? undefined : args.verify;
    this.wait = args.wait == undefined ? undefined : args.wait;
  }

  copy() {
    return new SubmitRequest(this.asObject());
  }

  asObject(): SubmitRequestArgsWithType {
    return {
      type: "submitRequest",
      envelope: this.envelope === undefined ? undefined : this.envelope.asObject(),
      verify: this.verify === undefined ? undefined : this.verify,
      wait: this.wait === undefined ? undefined : this.wait,
    };
  }
}

export type SubmitResponseArgs = {
  value?: (api.Submission | api.SubmissionArgs | undefined)[];
};
export type SubmitResponseArgsWithType = SubmitResponseArgs & {
  type: MessageType.SubmitResponse | "submitResponse";
};
export class SubmitResponse {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.SubmitResponse;
  @(encodeAs.field(2).repeatable.keepEmpty.reference)
  public value?: (api.Submission | undefined)[];

  constructor(args: SubmitResponseArgs) {
    this.value =
      args.value == undefined
        ? undefined
        : args.value.map((v) =>
            v == undefined ? undefined : v instanceof api.Submission ? v : new api.Submission(v),
          );
  }

  copy() {
    return new SubmitResponse(this.asObject());
  }

  asObject(): SubmitResponseArgsWithType {
    return {
      type: "submitResponse",
      value:
        this.value === undefined
          ? undefined
          : this.value?.map((v) => (v == undefined ? undefined : v.asObject())),
    };
  }
}

export type SubscribeRequestArgs = {
  partition?: string;
  account?: URLArgs;
};
export type SubscribeRequestArgsWithType = SubscribeRequestArgs & {
  type: MessageType.SubscribeRequest | "subscribeRequest";
};
export class SubscribeRequest {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.SubscribeRequest;
  @(encodeAs.field(2, 1).string)
  public partition?: string;
  @(encodeAs.field(2, 2).url)
  public account?: URL;

  constructor(args: SubscribeRequestArgs) {
    this.partition = args.partition == undefined ? undefined : args.partition;
    this.account = args.account == undefined ? undefined : URL.parse(args.account);
  }

  copy() {
    return new SubscribeRequest(this.asObject());
  }

  asObject(): SubscribeRequestArgsWithType {
    return {
      type: "subscribeRequest",
      partition: this.partition === undefined ? undefined : this.partition,
      account: this.account === undefined ? undefined : this.account.toString(),
    };
  }
}

export type SubscribeResponseArgs = {};
export type SubscribeResponseArgsWithType = {
  type: MessageType.SubscribeResponse | "subscribeResponse";
};
export class SubscribeResponse {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.SubscribeResponse;

  constructor(_: SubscribeResponseArgs) {}

  copy() {
    return new SubscribeResponse(this.asObject());
  }

  asObject(): SubscribeResponseArgsWithType {
    return {
      type: "subscribeResponse",
    };
  }
}

export type ValidateRequestArgs = {
  envelope?: messaging.Envelope | messaging.EnvelopeArgs;
  full?: boolean;
};
export type ValidateRequestArgsWithType = ValidateRequestArgs & {
  type: MessageType.ValidateRequest | "validateRequest";
};
export class ValidateRequest {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.ValidateRequest;
  @(encodeAs.field(2).reference)
  public envelope?: messaging.Envelope;
  @(encodeAs.field(3, 1).bool)
  public full?: boolean;

  constructor(args: ValidateRequestArgs) {
    this.envelope =
      args.envelope == undefined
        ? undefined
        : args.envelope instanceof messaging.Envelope
          ? args.envelope
          : new messaging.Envelope(args.envelope);
    this.full = args.full == undefined ? undefined : args.full;
  }

  copy() {
    return new ValidateRequest(this.asObject());
  }

  asObject(): ValidateRequestArgsWithType {
    return {
      type: "validateRequest",
      envelope: this.envelope === undefined ? undefined : this.envelope.asObject(),
      full: this.full === undefined ? undefined : this.full,
    };
  }
}

export type ValidateResponseArgs = {
  value?: (api.Submission | api.SubmissionArgs | undefined)[];
};
export type ValidateResponseArgsWithType = ValidateResponseArgs & {
  type: MessageType.ValidateResponse | "validateResponse";
};
export class ValidateResponse {
  @(encodeAs.field(1).keepEmpty.enum.of(MessageType))
  public readonly type = MessageType.ValidateResponse;
  @(encodeAs.field(2).repeatable.keepEmpty.reference)
  public value?: (api.Submission | undefined)[];

  constructor(args: ValidateResponseArgs) {
    this.value =
      args.value == undefined
        ? undefined
        : args.value.map((v) =>
            v == undefined ? undefined : v instanceof api.Submission ? v : new api.Submission(v),
          );
  }

  copy() {
    return new ValidateResponse(this.asObject());
  }

  asObject(): ValidateResponseArgsWithType {
    return {
      type: "validateResponse",
      value:
        this.value === undefined
          ? undefined
          : this.value?.map((v) => (v == undefined ? undefined : v.asObject())),
    };
  }
}
