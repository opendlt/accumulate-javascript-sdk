import * as types from ".";
import * as messaging from "../messaging";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */

export type Record =
  | types.AccountRecord
  | types.ChainEntryRecord<Record>
  | types.ChainRecord
  | types.IndexEntryRecord
  | types.KeyRecord
  | types.MajorBlockRecord
  | types.MessageRecord<messaging.Message>
  | types.MinorBlockRecord
  | types.RecordRange<Record>
  | types.SignatureSetRecord
  | types.TxIDRecord
  | types.UrlRecord;

export type RecordArgs =
  | types.AccountRecord
  | types.AccountRecordArgsWithType
  | types.ChainEntryRecord<Record>
  | types.ChainEntryRecordArgsWithType<Record>
  | types.ChainRecord
  | types.ChainRecordArgsWithType
  | types.IndexEntryRecord
  | types.IndexEntryRecordArgsWithType
  | types.KeyRecord
  | types.KeyRecordArgsWithType
  | types.MajorBlockRecord
  | types.MajorBlockRecordArgsWithType
  | types.MessageRecord<messaging.Message>
  | types.MessageRecordArgsWithType<messaging.Message>
  | types.MinorBlockRecord
  | types.MinorBlockRecordArgsWithType
  | types.RecordRange<Record>
  | types.RecordRangeArgsWithType<Record>
  | types.SignatureSetRecord
  | types.SignatureSetRecordArgsWithType
  | types.TxIDRecord
  | types.TxIDRecordArgsWithType
  | types.UrlRecord
  | types.UrlRecordArgsWithType;

/** @ignore */
export namespace Record {
  export function fromObject(obj: RecordArgs): Record {
    if (obj instanceof types.AccountRecord) return obj;
    if (obj instanceof types.ChainEntryRecord<Record>) return obj;
    if (obj instanceof types.ChainRecord) return obj;
    if (obj instanceof types.IndexEntryRecord) return obj;
    if (obj instanceof types.KeyRecord) return obj;
    if (obj instanceof types.MajorBlockRecord) return obj;
    if (obj instanceof types.MessageRecord<messaging.Message>) return obj;
    if (obj instanceof types.MinorBlockRecord) return obj;
    if (obj instanceof types.RecordRange<Record>) return obj;
    if (obj instanceof types.SignatureSetRecord) return obj;
    if (obj instanceof types.TxIDRecord) return obj;
    if (obj instanceof types.UrlRecord) return obj;

    switch (obj.recordType) {
      case types.RecordType.Account:
      case "account":
        return new types.AccountRecord(obj);
      case types.RecordType.ChainEntry:
      case "chainEntry":
        return new types.ChainEntryRecord<Record>(obj);
      case types.RecordType.Chain:
      case "chain":
        return new types.ChainRecord(obj);
      case types.RecordType.IndexEntry:
      case "indexEntry":
        return new types.IndexEntryRecord(obj);
      case types.RecordType.Key:
      case "key":
        return new types.KeyRecord(obj);
      case types.RecordType.MajorBlock:
      case "majorBlock":
        return new types.MajorBlockRecord(obj);
      case types.RecordType.Message:
      case "message":
        return new types.MessageRecord<messaging.Message>(obj);
      case types.RecordType.MinorBlock:
      case "minorBlock":
        return new types.MinorBlockRecord(obj);
      case types.RecordType.Range:
      case "range":
        return new types.RecordRange<Record>(obj);
      case types.RecordType.SignatureSet:
      case "signatureSet":
        return new types.SignatureSetRecord(obj);
      case types.RecordType.TxID:
      case "txID":
        return new types.TxIDRecord(obj);
      case types.RecordType.Url:
      case "url":
        return new types.UrlRecord(obj);
      default:
        throw new Error(`Unknown record '${(obj as any).recordType}'`);
    }
  }
}

export type Query =
  | types.AnchorSearchQuery
  | types.BlockQuery
  | types.ChainQuery
  | types.DataQuery
  | types.DefaultQuery
  | types.DelegateSearchQuery
  | types.DirectoryQuery
  | types.MessageHashSearchQuery
  | types.PendingQuery
  | types.PublicKeyHashSearchQuery
  | types.PublicKeySearchQuery;

export type QueryArgs =
  | types.AnchorSearchQuery
  | types.AnchorSearchQueryArgsWithType
  | types.BlockQuery
  | types.BlockQueryArgsWithType
  | types.ChainQuery
  | types.ChainQueryArgsWithType
  | types.DataQuery
  | types.DataQueryArgsWithType
  | types.DefaultQuery
  | types.DefaultQueryArgsWithType
  | types.DelegateSearchQuery
  | types.DelegateSearchQueryArgsWithType
  | types.DirectoryQuery
  | types.DirectoryQueryArgsWithType
  | types.MessageHashSearchQuery
  | types.MessageHashSearchQueryArgsWithType
  | types.PendingQuery
  | types.PendingQueryArgsWithType
  | types.PublicKeyHashSearchQuery
  | types.PublicKeyHashSearchQueryArgsWithType
  | types.PublicKeySearchQuery
  | types.PublicKeySearchQueryArgsWithType;

/** @ignore */
export namespace Query {
  export function fromObject(obj: QueryArgs): Query {
    if (obj instanceof types.AnchorSearchQuery) return obj;
    if (obj instanceof types.BlockQuery) return obj;
    if (obj instanceof types.ChainQuery) return obj;
    if (obj instanceof types.DataQuery) return obj;
    if (obj instanceof types.DefaultQuery) return obj;
    if (obj instanceof types.DelegateSearchQuery) return obj;
    if (obj instanceof types.DirectoryQuery) return obj;
    if (obj instanceof types.MessageHashSearchQuery) return obj;
    if (obj instanceof types.PendingQuery) return obj;
    if (obj instanceof types.PublicKeyHashSearchQuery) return obj;
    if (obj instanceof types.PublicKeySearchQuery) return obj;

    switch (obj.queryType) {
      case types.QueryType.AnchorSearch:
      case "anchorSearch":
        return new types.AnchorSearchQuery(obj);
      case types.QueryType.Block:
      case "block":
        return new types.BlockQuery(obj);
      case types.QueryType.Chain:
      case "chain":
        return new types.ChainQuery(obj);
      case types.QueryType.Data:
      case "data":
        return new types.DataQuery(obj);
      case types.QueryType.Default:
      case "default":
        return new types.DefaultQuery(obj);
      case types.QueryType.DelegateSearch:
      case "delegateSearch":
        return new types.DelegateSearchQuery(obj);
      case types.QueryType.Directory:
      case "directory":
        return new types.DirectoryQuery(obj);
      case types.QueryType.MessageHashSearch:
      case "messageHashSearch":
        return new types.MessageHashSearchQuery(obj);
      case types.QueryType.Pending:
      case "pending":
        return new types.PendingQuery(obj);
      case types.QueryType.PublicKeyHashSearch:
      case "publicKeyHashSearch":
        return new types.PublicKeyHashSearchQuery(obj);
      case types.QueryType.PublicKeySearch:
      case "publicKeySearch":
        return new types.PublicKeySearchQuery(obj);
      default:
        throw new Error(`Unknown query '${(obj as any).queryType}'`);
    }
  }
}

export type Event = types.BlockEvent | types.ErrorEvent | types.GlobalsEvent;

export type EventArgs =
  | types.BlockEvent
  | types.BlockEventArgsWithType
  | types.ErrorEvent
  | types.ErrorEventArgsWithType
  | types.GlobalsEvent
  | types.GlobalsEventArgsWithType;

/** @ignore */
export namespace Event {
  export function fromObject(obj: EventArgs): Event {
    if (obj instanceof types.BlockEvent) return obj;
    if (obj instanceof types.ErrorEvent) return obj;
    if (obj instanceof types.GlobalsEvent) return obj;

    switch (obj.eventType) {
      case types.EventType.Block:
      case "block":
        return new types.BlockEvent(obj);
      case types.EventType.Error:
      case "error":
        return new types.ErrorEvent(obj);
      case types.EventType.Globals:
      case "globals":
        return new types.GlobalsEvent(obj);
      default:
        throw new Error(`Unknown event '${(obj as any).eventType}'`);
    }
  }
}
