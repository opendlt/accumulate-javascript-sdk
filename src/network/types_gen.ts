import * as protocol from "../core";
import { encodeAs } from "../encoding";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */

export namespace GlobalValues {
  export type Args = {
    oracle?: protocol.AcmeOracle | protocol.AcmeOracle.Args;
    globals?: protocol.NetworkGlobals | protocol.NetworkGlobals.Args;
    network?: protocol.NetworkDefinition | protocol.NetworkDefinition.Args;
    routing?: protocol.RoutingTable | protocol.RoutingTable.Args;
    executorVersion?: protocol.ExecutorVersion.Args;
  };
}
export class GlobalValues {
  @encodeAs.field(1).reference
  public oracle?: protocol.AcmeOracle;
  @encodeAs.field(2).reference
  public globals?: protocol.NetworkGlobals;
  @encodeAs.field(3).reference
  public network?: protocol.NetworkDefinition;
  @encodeAs.field(4).reference
  public routing?: protocol.RoutingTable;
  @encodeAs.field(5).enum
  public executorVersion?: protocol.ExecutorVersion;

  constructor(args: GlobalValues.Args) {
    this.oracle =
      args.oracle == undefined
        ? undefined
        : args.oracle instanceof protocol.AcmeOracle
        ? args.oracle
        : new protocol.AcmeOracle(args.oracle);
    this.globals =
      args.globals == undefined
        ? undefined
        : args.globals instanceof protocol.NetworkGlobals
        ? args.globals
        : new protocol.NetworkGlobals(args.globals);
    this.network =
      args.network == undefined
        ? undefined
        : args.network instanceof protocol.NetworkDefinition
        ? args.network
        : new protocol.NetworkDefinition(args.network);
    this.routing =
      args.routing == undefined
        ? undefined
        : args.routing instanceof protocol.RoutingTable
        ? args.routing
        : new protocol.RoutingTable(args.routing);
    this.executorVersion =
      args.executorVersion == undefined
        ? undefined
        : protocol.ExecutorVersion.fromObject(args.executorVersion);
  }

  copy() {
    return new GlobalValues(this);
  }

  asObject(): GlobalValues.Args {
    return {
      oracle: this.oracle && this.oracle.asObject(),
      globals: this.globals && this.globals.asObject(),
      network: this.network && this.network.asObject(),
      routing: this.routing && this.routing.asObject(),
      executorVersion: this.executorVersion && this.executorVersion.toString(),
    };
  }
}
