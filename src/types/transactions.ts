// DO NOT EDIT. Generated by generate-sdk.sh.
import BN from "bn.js";
import { AccURL } from "../acc-url";
import {
  bigNumberMarshalBinary,
  booleanMarshalBinary,
  bytesMarshalBinary,
  hashMarshalBinary,
  marshalField,
  stringMarshalBinary,
  uvarintMarshalBinary,
} from "../encoding";
import { BasePayload } from "../payload/base-payload";
import { KeyPageOperation, SignatureType, TransactionType } from "./enums";

/* eslint-disable @typescript-eslint/no-namespace,no-constant-condition */

export type TransactionBody =
  | AddCredits
  | BurnTokens
  | CreateDataAccount
  | CreateIdentity
  | CreateKeyBook
  | CreateKeyPage
  | CreateToken
  | CreateTokenAccount
  | IssueTokens
  | SendTokens
  | SignPending
  | UpdateKeyPage
  | WriteData
  | WriteDataTo;

export type Signature = ED25519Signature | LegacyED25519Signature | RCD1Signature;

export namespace TransactionBody {
  export function from(arg: unknown): TransactionBody {
    const { type } = <{ type: string }>arg;
    switch (TransactionType.byName(type)) {
      case TransactionType.AddCredits:
        return new AddCredits(<AddCreditsArg>arg);
      case TransactionType.BurnTokens:
        return new BurnTokens(<BurnTokensArg>arg);
      case TransactionType.CreateDataAccount:
        return new CreateDataAccount(<CreateDataAccountArg>arg);
      case TransactionType.CreateIdentity:
        return new CreateIdentity(<CreateIdentityArg>arg);
      case TransactionType.CreateKeyBook:
        return new CreateKeyBook(<CreateKeyBookArg>arg);
      case TransactionType.CreateKeyPage:
        return new CreateKeyPage(<CreateKeyPageArg>arg);
      case TransactionType.CreateToken:
        return new CreateToken(<CreateTokenArg>arg);
      case TransactionType.CreateTokenAccount:
        return new CreateTokenAccount(<CreateTokenAccountArg>arg);
      case TransactionType.IssueTokens:
        return new IssueTokens(<IssueTokensArg>arg);
      case TransactionType.SendTokens:
        return new SendTokens(<SendTokensArg>arg);
      case TransactionType.SignPending:
        return new SignPending(<SignPendingArg>arg);
      case TransactionType.UpdateKeyPage:
        return new UpdateKeyPage(<UpdateKeyPageArg>arg);
      case TransactionType.WriteData:
        return new WriteData(<WriteDataArg>arg);
      case TransactionType.WriteDataTo:
        return new WriteDataTo(<WriteDataToArg>arg);
      default:
        throw new Error(`Unknown TransactionType '${type}'`);
    }
  }
}

export type AddCreditsArg = {
  recipient: string | AccURL;
  amount: number | BN;
};

export class AddCredits extends BasePayload {
  public readonly recipient: AccURL;
  public readonly amount: number | BN;

  constructor(arg: AddCreditsArg) {
    super();
    this.recipient = AccURL.toAccURL(arg.recipient);
    this.amount = arg.amount;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.AddCredits)));
    if (true) {
      parts.push(marshalField(2, stringMarshalBinary(this.recipient.toString())));
    }
    if (true && (this.amount instanceof BN ? !this.amount.isZero() : this.amount !== 0)) {
      parts.push(marshalField(3, uvarintMarshalBinary(this.amount)));
    }
    return Buffer.concat(parts);
  }
}

export type BurnTokensArg = {
  amount: number | BN | string;
};

export class BurnTokens extends BasePayload {
  public readonly amount: BN;

  constructor(arg: BurnTokensArg) {
    super();
    this.amount = arg.amount instanceof BN ? arg.amount : new BN(arg.amount);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.BurnTokens)));
    if (true && !this.amount.isZero()) {
      parts.push(marshalField(2, bigNumberMarshalBinary(this.amount)));
    }
    return Buffer.concat(parts);
  }
}

export type CreateDataAccountArg = {
  url: string | AccURL;
  keyBookUrl?: string | AccURL;
  managerKeyBookUrl?: string | AccURL;
  scratch?: boolean;
};

export class CreateDataAccount extends BasePayload {
  public readonly url: AccURL;
  public readonly keyBookUrl?: AccURL;
  public readonly managerKeyBookUrl?: AccURL;
  public readonly scratch?: boolean;

  constructor(arg: CreateDataAccountArg) {
    super();
    this.url = AccURL.toAccURL(arg.url);
    if (arg.keyBookUrl) this.keyBookUrl = AccURL.toAccURL(arg.keyBookUrl);
    if (arg.managerKeyBookUrl) this.managerKeyBookUrl = AccURL.toAccURL(arg.managerKeyBookUrl);
    if (arg.scratch) this.scratch = arg.scratch;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.CreateDataAccount)));
    if (true) {
      parts.push(marshalField(2, stringMarshalBinary(this.url.toString())));
    }
    if (this.keyBookUrl !== undefined && this.keyBookUrl !== null) {
      parts.push(marshalField(3, stringMarshalBinary(this.keyBookUrl.toString())));
    }
    if (this.managerKeyBookUrl !== undefined && this.managerKeyBookUrl !== null) {
      parts.push(marshalField(4, stringMarshalBinary(this.managerKeyBookUrl.toString())));
    }
    if (this.scratch !== undefined && this.scratch !== null && this.scratch === true) {
      parts.push(marshalField(5, booleanMarshalBinary(this.scratch)));
    }
    return Buffer.concat(parts);
  }
}

export type CreateIdentityArg = {
  url: string | AccURL;
  publicKey?: Uint8Array | string;
  keyBookUrl?: string | AccURL;
  manager?: string | AccURL;
};

export class CreateIdentity extends BasePayload {
  public readonly url: AccURL;
  public readonly publicKey?: Uint8Array;
  public readonly keyBookUrl?: AccURL;
  public readonly manager?: AccURL;

  constructor(arg: CreateIdentityArg) {
    super();
    this.url = AccURL.toAccURL(arg.url);
    if (arg.publicKey)
      this.publicKey =
        typeof arg.publicKey === "string" ? Buffer.from(arg.publicKey, "hex") : arg.publicKey;
    if (arg.keyBookUrl) this.keyBookUrl = AccURL.toAccURL(arg.keyBookUrl);
    if (arg.manager) this.manager = AccURL.toAccURL(arg.manager);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.CreateIdentity)));
    if (true) {
      parts.push(marshalField(2, stringMarshalBinary(this.url.toString())));
    }
    if (this.publicKey !== undefined && this.publicKey !== null && this.publicKey?.length > 0) {
      parts.push(marshalField(3, bytesMarshalBinary(this.publicKey)));
    }
    if (this.keyBookUrl !== undefined && this.keyBookUrl !== null) {
      parts.push(marshalField(4, stringMarshalBinary(this.keyBookUrl.toString())));
    }
    if (this.manager !== undefined && this.manager !== null) {
      parts.push(marshalField(5, stringMarshalBinary(this.manager.toString())));
    }
    return Buffer.concat(parts);
  }
}

export type CreateKeyBookArg = {
  url: string | AccURL;
  publicKeyHash: Uint8Array | string;
  manager?: string | AccURL;
};

export class CreateKeyBook extends BasePayload {
  public readonly url: AccURL;
  public readonly publicKeyHash: Uint8Array;
  public readonly manager?: AccURL;

  constructor(arg: CreateKeyBookArg) {
    super();
    this.url = AccURL.toAccURL(arg.url);
    this.publicKeyHash =
      typeof arg.publicKeyHash === "string"
        ? Buffer.from(arg.publicKeyHash, "hex")
        : arg.publicKeyHash;
    if (arg.manager) this.manager = AccURL.toAccURL(arg.manager);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.CreateKeyBook)));
    if (true) {
      parts.push(marshalField(2, stringMarshalBinary(this.url.toString())));
    }
    if (true && this.publicKeyHash?.length > 0) {
      parts.push(marshalField(3, bytesMarshalBinary(this.publicKeyHash)));
    }
    if (this.manager !== undefined && this.manager !== null) {
      parts.push(marshalField(4, stringMarshalBinary(this.manager.toString())));
    }
    return Buffer.concat(parts);
  }
}

export type CreateKeyPageArg = {
  keys: (KeySpecParams | KeySpecParamsArg)[];
  manager?: string | AccURL;
};

export class CreateKeyPage extends BasePayload {
  public readonly keys: KeySpecParams[];
  public readonly manager?: AccURL;

  constructor(arg: CreateKeyPageArg) {
    super();
    this.keys = arg.keys.map((v) => (v instanceof KeySpecParams ? v : new KeySpecParams(v)));
    if (arg.manager) this.manager = AccURL.toAccURL(arg.manager);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.CreateKeyPage)));
    if (true && this.keys?.length > 0) {
      parts.push(
        Buffer.concat(
          this.keys.map((val) => marshalField(2, bytesMarshalBinary(val.marshalBinary())))
        )
      );
    }
    if (this.manager !== undefined && this.manager !== null) {
      parts.push(marshalField(3, stringMarshalBinary(this.manager.toString())));
    }
    return Buffer.concat(parts);
  }
}

export type CreateTokenArg = {
  url: string | AccURL;
  keyBookUrl?: string | AccURL;
  symbol: string;
  precision: number | BN;
  properties?: string | AccURL;
  initialSupply?: number | BN | string;
  hasSupplyLimit?: boolean;
  manager?: string | AccURL;
};

export class CreateToken extends BasePayload {
  public readonly url: AccURL;
  public readonly keyBookUrl?: AccURL;
  public readonly symbol: string;
  public readonly precision: number | BN;
  public readonly properties?: AccURL;
  public readonly initialSupply?: BN;
  public readonly hasSupplyLimit?: boolean;
  public readonly manager?: AccURL;

  constructor(arg: CreateTokenArg) {
    super();
    this.url = AccURL.toAccURL(arg.url);
    if (arg.keyBookUrl) this.keyBookUrl = AccURL.toAccURL(arg.keyBookUrl);
    this.symbol = arg.symbol;
    this.precision = arg.precision;
    if (arg.properties) this.properties = AccURL.toAccURL(arg.properties);
    if (arg.initialSupply)
      this.initialSupply =
        arg.initialSupply instanceof BN ? arg.initialSupply : new BN(arg.initialSupply);
    if (arg.hasSupplyLimit) this.hasSupplyLimit = arg.hasSupplyLimit;
    if (arg.manager) this.manager = AccURL.toAccURL(arg.manager);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.CreateToken)));
    if (true) {
      parts.push(marshalField(2, stringMarshalBinary(this.url.toString())));
    }
    if (this.keyBookUrl !== undefined && this.keyBookUrl !== null) {
      parts.push(marshalField(3, stringMarshalBinary(this.keyBookUrl.toString())));
    }
    if (true && this.symbol?.length > 0) {
      parts.push(marshalField(4, stringMarshalBinary(this.symbol)));
    }
    if (true && (this.precision instanceof BN ? !this.precision.isZero() : this.precision !== 0)) {
      parts.push(marshalField(5, uvarintMarshalBinary(this.precision)));
    }
    if (this.properties !== undefined && this.properties !== null) {
      parts.push(marshalField(6, stringMarshalBinary(this.properties.toString())));
    }
    if (
      this.initialSupply !== undefined &&
      this.initialSupply !== null &&
      !this.initialSupply.isZero()
    ) {
      parts.push(marshalField(7, bigNumberMarshalBinary(this.initialSupply)));
    }
    if (
      this.hasSupplyLimit !== undefined &&
      this.hasSupplyLimit !== null &&
      this.hasSupplyLimit === true
    ) {
      parts.push(marshalField(8, booleanMarshalBinary(this.hasSupplyLimit)));
    }
    if (this.manager !== undefined && this.manager !== null) {
      parts.push(marshalField(9, stringMarshalBinary(this.manager.toString())));
    }
    return Buffer.concat(parts);
  }
}

export type CreateTokenAccountArg = {
  url: string | AccURL;
  tokenUrl: string | AccURL;
  keyBookUrl?: string | AccURL;
  scratch?: boolean;
  manager?: string | AccURL;
};

export class CreateTokenAccount extends BasePayload {
  public readonly url: AccURL;
  public readonly tokenUrl: AccURL;
  public readonly keyBookUrl?: AccURL;
  public readonly scratch?: boolean;
  public readonly manager?: AccURL;

  constructor(arg: CreateTokenAccountArg) {
    super();
    this.url = AccURL.toAccURL(arg.url);
    this.tokenUrl = AccURL.toAccURL(arg.tokenUrl);
    if (arg.keyBookUrl) this.keyBookUrl = AccURL.toAccURL(arg.keyBookUrl);
    if (arg.scratch) this.scratch = arg.scratch;
    if (arg.manager) this.manager = AccURL.toAccURL(arg.manager);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.CreateTokenAccount)));
    if (true) {
      parts.push(marshalField(2, stringMarshalBinary(this.url.toString())));
    }
    if (true) {
      parts.push(marshalField(3, stringMarshalBinary(this.tokenUrl.toString())));
    }
    if (this.keyBookUrl !== undefined && this.keyBookUrl !== null) {
      parts.push(marshalField(4, stringMarshalBinary(this.keyBookUrl.toString())));
    }
    if (this.scratch !== undefined && this.scratch !== null && this.scratch === true) {
      parts.push(marshalField(5, booleanMarshalBinary(this.scratch)));
    }
    if (this.manager !== undefined && this.manager !== null) {
      parts.push(marshalField(6, stringMarshalBinary(this.manager.toString())));
    }
    return Buffer.concat(parts);
  }
}

export type DataEntryArg = {
  extIds?: (Uint8Array | string)[];
  data?: Uint8Array | string;
};

export class DataEntry extends BasePayload {
  public readonly extIds?: Uint8Array[];
  public readonly data?: Uint8Array;

  constructor(arg: DataEntryArg) {
    super();
    if (arg.extIds)
      this.extIds = arg.extIds.map((v) => (typeof v === "string" ? Buffer.from(v, "hex") : v));
    if (arg.data)
      this.data = typeof arg.data === "string" ? Buffer.from(arg.data, "hex") : arg.data;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    if (this.extIds !== undefined && this.extIds !== null && this.extIds?.length > 0) {
      parts.push(Buffer.concat(this.extIds.map((val) => marshalField(1, bytesMarshalBinary(val)))));
    }
    if (this.data !== undefined && this.data !== null && this.data?.length > 0) {
      parts.push(marshalField(2, bytesMarshalBinary(this.data)));
    }
    return Buffer.concat(parts);
  }
}

export type ED25519SignatureArg = {
  publicKey: Uint8Array | string;
  signature: Uint8Array | string;
  signer: string | AccURL;
  signerHeight: number | BN;
  timestamp?: number | BN;
};

export class ED25519Signature extends BasePayload {
  public readonly publicKey: Uint8Array;
  public readonly signature: Uint8Array;
  public readonly signer: AccURL;
  public readonly signerHeight: number | BN;
  public readonly timestamp?: number | BN;

  constructor(arg: ED25519SignatureArg) {
    super();
    this.publicKey =
      typeof arg.publicKey === "string" ? Buffer.from(arg.publicKey, "hex") : arg.publicKey;
    this.signature =
      typeof arg.signature === "string" ? Buffer.from(arg.signature, "hex") : arg.signature;
    this.signer = AccURL.toAccURL(arg.signer);
    this.signerHeight = arg.signerHeight;
    if (arg.timestamp) this.timestamp = arg.timestamp;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(SignatureType.ED25519)));
    if (true && this.publicKey?.length > 0) {
      parts.push(marshalField(2, bytesMarshalBinary(this.publicKey)));
    }
    if (true && this.signature?.length > 0) {
      parts.push(marshalField(3, bytesMarshalBinary(this.signature)));
    }
    if (true) {
      parts.push(marshalField(4, stringMarshalBinary(this.signer.toString())));
    }
    if (
      true &&
      (this.signerHeight instanceof BN ? !this.signerHeight.isZero() : this.signerHeight !== 0)
    ) {
      parts.push(marshalField(5, uvarintMarshalBinary(this.signerHeight)));
    }
    if (
      this.timestamp !== undefined &&
      this.timestamp !== null &&
      (this.timestamp instanceof BN ? !this.timestamp.isZero() : this.timestamp !== 0)
    ) {
      parts.push(marshalField(6, uvarintMarshalBinary(this.timestamp)));
    }
    return Buffer.concat(parts);
  }
}

export type EnvelopeArg = {
  signatures: Signature[];
  txHash?: Uint8Array | string;
  transaction?: Transaction | TransactionArg;
};

export class Envelope extends BasePayload {
  public readonly signatures: Signature[];
  public readonly txHash?: Uint8Array;
  public readonly transaction?: Transaction;

  constructor(arg: EnvelopeArg) {
    super();
    this.signatures = arg.signatures.map((v) => v);
    if (arg.txHash)
      this.txHash = typeof arg.txHash === "string" ? Buffer.from(arg.txHash, "hex") : arg.txHash;
    if (arg.transaction)
      this.transaction =
        arg.transaction instanceof Transaction ? arg.transaction : new Transaction(arg.transaction);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    if (true && this.signatures?.length > 0) {
      parts.push(
        Buffer.concat(
          this.signatures.map((val) => marshalField(1, bytesMarshalBinary(val.marshalBinary())))
        )
      );
    }
    if (this.txHash !== undefined && this.txHash !== null && this.txHash?.length > 0) {
      parts.push(marshalField(2, bytesMarshalBinary(this.txHash)));
    }
    if (this.transaction !== undefined && this.transaction !== null) {
      parts.push(marshalField(3, bytesMarshalBinary(this.transaction.marshalBinary())));
    }
    return Buffer.concat(parts);
  }
}

export type IssueTokensArg = {
  recipient: string | AccURL;
  amount: number | BN | string;
};

export class IssueTokens extends BasePayload {
  public readonly recipient: AccURL;
  public readonly amount: BN;

  constructor(arg: IssueTokensArg) {
    super();
    this.recipient = AccURL.toAccURL(arg.recipient);
    this.amount = arg.amount instanceof BN ? arg.amount : new BN(arg.amount);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.IssueTokens)));
    if (true) {
      parts.push(marshalField(2, stringMarshalBinary(this.recipient.toString())));
    }
    if (true && !this.amount.isZero()) {
      parts.push(marshalField(3, bigNumberMarshalBinary(this.amount)));
    }
    return Buffer.concat(parts);
  }
}

export type KeySpecParamsArg = {
  publicKey: Uint8Array | string;
};

export class KeySpecParams extends BasePayload {
  public readonly publicKey: Uint8Array;

  constructor(arg: KeySpecParamsArg) {
    super();
    this.publicKey =
      typeof arg.publicKey === "string" ? Buffer.from(arg.publicKey, "hex") : arg.publicKey;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    if (true && this.publicKey?.length > 0) {
      parts.push(marshalField(1, bytesMarshalBinary(this.publicKey)));
    }
    return Buffer.concat(parts);
  }
}

export type LegacyED25519SignatureArg = {
  timestamp: number | BN;
  publicKey: Uint8Array | string;
  signature: Uint8Array | string;
  signer: string | AccURL;
  signerHeight: number | BN;
};

export class LegacyED25519Signature extends BasePayload {
  public readonly timestamp: number | BN;
  public readonly publicKey: Uint8Array;
  public readonly signature: Uint8Array;
  public readonly signer: AccURL;
  public readonly signerHeight: number | BN;

  constructor(arg: LegacyED25519SignatureArg) {
    super();
    this.timestamp = arg.timestamp;
    this.publicKey =
      typeof arg.publicKey === "string" ? Buffer.from(arg.publicKey, "hex") : arg.publicKey;
    this.signature =
      typeof arg.signature === "string" ? Buffer.from(arg.signature, "hex") : arg.signature;
    this.signer = AccURL.toAccURL(arg.signer);
    this.signerHeight = arg.signerHeight;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(SignatureType.LegacyED25519)));
    if (true && (this.timestamp instanceof BN ? !this.timestamp.isZero() : this.timestamp !== 0)) {
      parts.push(marshalField(2, uvarintMarshalBinary(this.timestamp)));
    }
    if (true && this.publicKey?.length > 0) {
      parts.push(marshalField(3, bytesMarshalBinary(this.publicKey)));
    }
    if (true && this.signature?.length > 0) {
      parts.push(marshalField(4, bytesMarshalBinary(this.signature)));
    }
    if (true) {
      parts.push(marshalField(5, stringMarshalBinary(this.signer.toString())));
    }
    if (
      true &&
      (this.signerHeight instanceof BN ? !this.signerHeight.isZero() : this.signerHeight !== 0)
    ) {
      parts.push(marshalField(6, uvarintMarshalBinary(this.signerHeight)));
    }
    return Buffer.concat(parts);
  }
}

export type RCD1SignatureArg = {
  publicKey: Uint8Array | string;
  signature: Uint8Array | string;
  signer: string | AccURL;
  signerHeight: number | BN;
  timestamp?: number | BN;
};

export class RCD1Signature extends BasePayload {
  public readonly publicKey: Uint8Array;
  public readonly signature: Uint8Array;
  public readonly signer: AccURL;
  public readonly signerHeight: number | BN;
  public readonly timestamp?: number | BN;

  constructor(arg: RCD1SignatureArg) {
    super();
    this.publicKey =
      typeof arg.publicKey === "string" ? Buffer.from(arg.publicKey, "hex") : arg.publicKey;
    this.signature =
      typeof arg.signature === "string" ? Buffer.from(arg.signature, "hex") : arg.signature;
    this.signer = AccURL.toAccURL(arg.signer);
    this.signerHeight = arg.signerHeight;
    if (arg.timestamp) this.timestamp = arg.timestamp;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(SignatureType.RCD1)));
    if (true && this.publicKey?.length > 0) {
      parts.push(marshalField(2, bytesMarshalBinary(this.publicKey)));
    }
    if (true && this.signature?.length > 0) {
      parts.push(marshalField(3, bytesMarshalBinary(this.signature)));
    }
    if (true) {
      parts.push(marshalField(4, stringMarshalBinary(this.signer.toString())));
    }
    if (
      true &&
      (this.signerHeight instanceof BN ? !this.signerHeight.isZero() : this.signerHeight !== 0)
    ) {
      parts.push(marshalField(5, uvarintMarshalBinary(this.signerHeight)));
    }
    if (
      this.timestamp !== undefined &&
      this.timestamp !== null &&
      (this.timestamp instanceof BN ? !this.timestamp.isZero() : this.timestamp !== 0)
    ) {
      parts.push(marshalField(6, uvarintMarshalBinary(this.timestamp)));
    }
    return Buffer.concat(parts);
  }
}

export type SendTokensArg = {
  hash?: Uint8Array | string;
  meta?: unknown;
  to: (TokenRecipient | TokenRecipientArg)[];
};

export class SendTokens extends BasePayload {
  public readonly hash?: Uint8Array;
  public readonly meta?: unknown;
  public readonly to: TokenRecipient[];

  constructor(arg: SendTokensArg) {
    super();
    if (arg.hash)
      this.hash = typeof arg.hash === "string" ? Buffer.from(arg.hash, "hex") : arg.hash;
    if (arg.meta) this.meta = arg.meta;
    this.to = arg.to.map((v) => (v instanceof TokenRecipient ? v : new TokenRecipient(v)));
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.SendTokens)));
    if (
      this.hash !== undefined &&
      this.hash !== null &&
      this.hash?.length > 0 &&
      this.hash.some((v) => v !== 0)
    ) {
      parts.push(marshalField(2, hashMarshalBinary(this.hash)));
    }
    if (this.meta !== undefined && this.meta !== null) {
      parts.push(marshalField(3, stringMarshalBinary(JSON.stringify(this.meta))));
    }
    if (true && this.to?.length > 0) {
      parts.push(
        Buffer.concat(
          this.to.map((val) => marshalField(4, bytesMarshalBinary(val.marshalBinary())))
        )
      );
    }
    return Buffer.concat(parts);
  }
}

export type SignPendingArg = unknown;

export class SignPending extends BasePayload {
  constructor(_: SignPendingArg) {
    super();
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.SignPending)));
    return Buffer.concat(parts);
  }
}

export type TokenRecipientArg = {
  url: string | AccURL;
  amount: number | BN | string;
};

export class TokenRecipient extends BasePayload {
  public readonly url: AccURL;
  public readonly amount: BN;

  constructor(arg: TokenRecipientArg) {
    super();
    this.url = AccURL.toAccURL(arg.url);
    this.amount = arg.amount instanceof BN ? arg.amount : new BN(arg.amount);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    if (true) {
      parts.push(marshalField(1, stringMarshalBinary(this.url.toString())));
    }
    if (true && !this.amount.isZero()) {
      parts.push(marshalField(2, bigNumberMarshalBinary(this.amount)));
    }
    return Buffer.concat(parts);
  }
}

export type TransactionArg = {
  header: TransactionHeader | TransactionHeaderArg;
  body: TransactionBody;
};

export class Transaction extends BasePayload {
  public readonly header: TransactionHeader;
  public readonly body: TransactionBody;

  constructor(arg: TransactionArg) {
    super();
    this.header =
      arg.header instanceof TransactionHeader ? arg.header : new TransactionHeader(arg.header);
    this.body = arg.body;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    if (true) {
      parts.push(marshalField(1, bytesMarshalBinary(this.header.marshalBinary())));
    }
    if (true) {
      parts.push(marshalField(2, bytesMarshalBinary(this.body.marshalBinary())));
    }
    return Buffer.concat(parts);
  }
}

export type TransactionHeaderArg = {
  principal: string | AccURL;
  initiator: Uint8Array | string;
  memo?: string;
  metadata?: Uint8Array | string;
};

export class TransactionHeader extends BasePayload {
  public readonly principal: AccURL;
  public readonly initiator: Uint8Array;
  public readonly memo?: string;
  public readonly metadata?: Uint8Array;

  constructor(arg: TransactionHeaderArg) {
    super();
    this.principal = AccURL.toAccURL(arg.principal);
    this.initiator =
      typeof arg.initiator === "string" ? Buffer.from(arg.initiator, "hex") : arg.initiator;
    if (arg.memo) this.memo = arg.memo;
    if (arg.metadata)
      this.metadata =
        typeof arg.metadata === "string" ? Buffer.from(arg.metadata, "hex") : arg.metadata;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    if (true) {
      parts.push(marshalField(1, stringMarshalBinary(this.principal.toString())));
    }
    if (true && this.initiator?.length > 0 && this.initiator.some((v) => v !== 0)) {
      parts.push(marshalField(2, hashMarshalBinary(this.initiator)));
    }
    if (this.memo !== undefined && this.memo !== null && this.memo?.length > 0) {
      parts.push(marshalField(3, stringMarshalBinary(this.memo)));
    }
    if (this.metadata !== undefined && this.metadata !== null && this.metadata?.length > 0) {
      parts.push(marshalField(4, bytesMarshalBinary(this.metadata)));
    }
    return Buffer.concat(parts);
  }
}

export type UpdateKeyPageArg = {
  operation: KeyPageOperation | string;
  key?: Uint8Array | string;
  newKey?: Uint8Array | string;
  owner?: string | AccURL;
  threshold?: number | BN;
};

export class UpdateKeyPage extends BasePayload {
  public readonly operation: KeyPageOperation;
  public readonly key?: Uint8Array;
  public readonly newKey?: Uint8Array;
  public readonly owner?: AccURL;
  public readonly threshold?: number | BN;

  constructor(arg: UpdateKeyPageArg) {
    super();
    this.operation =
      typeof arg.operation === "string" ? KeyPageOperation.byName(arg.operation) : arg.operation;
    if (arg.key) this.key = typeof arg.key === "string" ? Buffer.from(arg.key, "hex") : arg.key;
    if (arg.newKey)
      this.newKey = typeof arg.newKey === "string" ? Buffer.from(arg.newKey, "hex") : arg.newKey;
    if (arg.owner) this.owner = AccURL.toAccURL(arg.owner);
    if (arg.threshold) this.threshold = arg.threshold;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.UpdateKeyPage)));
    if (true) {
      parts.push(marshalField(2, uvarintMarshalBinary(this.operation)));
    }
    if (this.key !== undefined && this.key !== null && this.key?.length > 0) {
      parts.push(marshalField(3, bytesMarshalBinary(this.key)));
    }
    if (this.newKey !== undefined && this.newKey !== null && this.newKey?.length > 0) {
      parts.push(marshalField(4, bytesMarshalBinary(this.newKey)));
    }
    if (this.owner !== undefined && this.owner !== null) {
      parts.push(marshalField(5, stringMarshalBinary(this.owner.toString())));
    }
    if (
      this.threshold !== undefined &&
      this.threshold !== null &&
      (this.threshold instanceof BN ? !this.threshold.isZero() : this.threshold !== 0)
    ) {
      parts.push(marshalField(6, uvarintMarshalBinary(this.threshold)));
    }
    return Buffer.concat(parts);
  }
}

export type WriteDataArg = {
  entry: DataEntry | DataEntryArg;
};

export class WriteData extends BasePayload {
  public readonly entry: DataEntry;

  constructor(arg: WriteDataArg) {
    super();
    this.entry = arg.entry instanceof DataEntry ? arg.entry : new DataEntry(arg.entry);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.WriteData)));
    if (true) {
      parts.push(marshalField(2, bytesMarshalBinary(this.entry.marshalBinary())));
    }
    return Buffer.concat(parts);
  }
}

export type WriteDataToArg = {
  recipient: string | AccURL;
  entry: DataEntry | DataEntryArg;
};

export class WriteDataTo extends BasePayload {
  public readonly recipient: AccURL;
  public readonly entry: DataEntry;

  constructor(arg: WriteDataToArg) {
    super();
    this.recipient = AccURL.toAccURL(arg.recipient);
    this.entry = arg.entry instanceof DataEntry ? arg.entry : new DataEntry(arg.entry);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.WriteDataTo)));
    if (true) {
      parts.push(marshalField(2, stringMarshalBinary(this.recipient.toString())));
    }
    if (true) {
      parts.push(marshalField(3, bytesMarshalBinary(this.entry.marshalBinary())));
    }
    return Buffer.concat(parts);
  }
}
