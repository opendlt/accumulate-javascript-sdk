// DO NOT EDIT. Generated by generate-sdk.sh.
import BN from "bn.js";
import {
  arrayMarshalBinary,
  bigNumberMarshalBinary,
  booleanMarshalBinary,
  bytesMarshalBinary,
  hashMarshalBinary,
  stringMarshalBinary,
  uvarintMarshalBinary,
} from "../encoding";
import { BasePayload } from "../payload/base-payload";
import { KeyPageOperation, TransactionType } from "./enums";

export type AddCreditsArg = {
  recipient: string;
  amount: number;
};

export class AddCredits extends BasePayload {
  public readonly recipient: string;
  public readonly amount: number;

  constructor(arg: AddCreditsArg) {
    super();
    this.recipient = arg.recipient;
    this.amount = arg.amount;
  }
  protected _marshalBinary(): Buffer {
    return Buffer.concat([
      uvarintMarshalBinary(TransactionType.AddCredits),
      stringMarshalBinary(this.recipient),
      uvarintMarshalBinary(this.amount),
    ]);
  }
}

export type BurnTokensArg = {
  amount: number | BN | string;
};

export class BurnTokens extends BasePayload {
  public readonly amount: BN;

  constructor(arg: BurnTokensArg) {
    super();
    this.amount = arg.amount instanceof BN ? arg.amount : new BN(arg.amount);
  }
  protected _marshalBinary(): Buffer {
    return Buffer.concat([
      uvarintMarshalBinary(TransactionType.BurnTokens),
      bigNumberMarshalBinary(this.amount),
    ]);
  }
}

export type CreateDataAccountArg = {
  url: string;
  keyBookUrl: string;
  managerKeyBookUrl: string;
  scratch: boolean;
};

export class CreateDataAccount extends BasePayload {
  public readonly url: string;
  public readonly keyBookUrl: string;
  public readonly managerKeyBookUrl: string;
  public readonly scratch: boolean;

  constructor(arg: CreateDataAccountArg) {
    super();
    this.url = arg.url;
    this.keyBookUrl = arg.keyBookUrl;
    this.managerKeyBookUrl = arg.managerKeyBookUrl;
    this.scratch = arg.scratch;
  }
  protected _marshalBinary(): Buffer {
    return Buffer.concat([
      uvarintMarshalBinary(TransactionType.CreateDataAccount),
      stringMarshalBinary(this.url),
      stringMarshalBinary(this.keyBookUrl),
      stringMarshalBinary(this.managerKeyBookUrl),
      booleanMarshalBinary(this.scratch),
    ]);
  }
}

export type CreateIdentityArg = {
  url: string;
  publicKey: Uint8Array;
  keyBookName: string;
  keyPageName: string;
};

export class CreateIdentity extends BasePayload {
  public readonly url: string;
  public readonly publicKey: Uint8Array;
  public readonly keyBookName: string;
  public readonly keyPageName: string;

  constructor(arg: CreateIdentityArg) {
    super();
    this.url = arg.url;
    this.publicKey = arg.publicKey;
    this.keyBookName = arg.keyBookName;
    this.keyPageName = arg.keyPageName;
  }
  protected _marshalBinary(): Buffer {
    return Buffer.concat([
      uvarintMarshalBinary(TransactionType.CreateIdentity),
      stringMarshalBinary(this.url),
      bytesMarshalBinary(this.publicKey),
      stringMarshalBinary(this.keyBookName),
      stringMarshalBinary(this.keyPageName),
    ]);
  }
}

export type CreateKeyBookArg = {
  url: string;
  pages: string[];
};

export class CreateKeyBook extends BasePayload {
  public readonly url: string;
  public readonly pages: string[];

  constructor(arg: CreateKeyBookArg) {
    super();
    this.url = arg.url;
    this.pages = arg.pages;
  }
  protected _marshalBinary(): Buffer {
    return Buffer.concat([
      uvarintMarshalBinary(TransactionType.CreateKeyBook),
      stringMarshalBinary(this.url),
      arrayMarshalBinary(this.pages, (val) => stringMarshalBinary(val)),
    ]);
  }
}

export type CreateKeyPageArg = {
  url: string;
  keys: KeySpecParams[];
};

export class CreateKeyPage extends BasePayload {
  public readonly url: string;
  public readonly keys: KeySpecParams[];

  constructor(arg: CreateKeyPageArg) {
    super();
    this.url = arg.url;
    this.keys = arg.keys;
  }
  protected _marshalBinary(): Buffer {
    return Buffer.concat([
      uvarintMarshalBinary(TransactionType.CreateKeyPage),
      stringMarshalBinary(this.url),
      arrayMarshalBinary(this.keys, (val) => val.marshalBinary()),
    ]);
  }
}

export type CreateTokenArg = {
  url: string;
  keyBookUrl: string;
  symbol: string;
  precision: number;
  properties: string;
  initialSupply: number | BN | string;
  hasSupplyLimit: boolean;
};

export class CreateToken extends BasePayload {
  public readonly url: string;
  public readonly keyBookUrl: string;
  public readonly symbol: string;
  public readonly precision: number;
  public readonly properties: string;
  public readonly initialSupply: BN;
  public readonly hasSupplyLimit: boolean;

  constructor(arg: CreateTokenArg) {
    super();
    this.url = arg.url;
    this.keyBookUrl = arg.keyBookUrl;
    this.symbol = arg.symbol;
    this.precision = arg.precision;
    this.properties = arg.properties;
    this.initialSupply =
      arg.initialSupply instanceof BN ? arg.initialSupply : new BN(arg.initialSupply);
    this.hasSupplyLimit = arg.hasSupplyLimit;
  }
  protected _marshalBinary(): Buffer {
    return Buffer.concat([
      uvarintMarshalBinary(TransactionType.CreateToken),
      stringMarshalBinary(this.url),
      stringMarshalBinary(this.keyBookUrl),
      stringMarshalBinary(this.symbol),
      uvarintMarshalBinary(this.precision),
      stringMarshalBinary(this.properties),
      bigNumberMarshalBinary(this.initialSupply),
      booleanMarshalBinary(this.hasSupplyLimit),
    ]);
  }
}

export type CreateTokenAccountArg = {
  url: string;
  tokenUrl: string;
  keyBookUrl: string;
  scratch: boolean;
};

export class CreateTokenAccount extends BasePayload {
  public readonly url: string;
  public readonly tokenUrl: string;
  public readonly keyBookUrl: string;
  public readonly scratch: boolean;

  constructor(arg: CreateTokenAccountArg) {
    super();
    this.url = arg.url;
    this.tokenUrl = arg.tokenUrl;
    this.keyBookUrl = arg.keyBookUrl;
    this.scratch = arg.scratch;
  }
  protected _marshalBinary(): Buffer {
    return Buffer.concat([
      uvarintMarshalBinary(TransactionType.CreateTokenAccount),
      stringMarshalBinary(this.url),
      stringMarshalBinary(this.tokenUrl),
      stringMarshalBinary(this.keyBookUrl),
      booleanMarshalBinary(this.scratch),
    ]);
  }
}

export type DataEntryArg = {
  extIds: Uint8Array[];
  data: Uint8Array;
};

export class DataEntry extends BasePayload {
  public readonly extIds: Uint8Array[];
  public readonly data: Uint8Array;

  constructor(arg: DataEntryArg) {
    super();
    this.extIds = arg.extIds;
    this.data = arg.data;
  }
  protected _marshalBinary(): Buffer {
    return Buffer.concat([
      arrayMarshalBinary(this.extIds, (val) => bytesMarshalBinary(val)),
      bytesMarshalBinary(this.data),
    ]);
  }
}

export type IssueTokensArg = {
  recipient: string;
  amount: number | BN | string;
};

export class IssueTokens extends BasePayload {
  public readonly recipient: string;
  public readonly amount: BN;

  constructor(arg: IssueTokensArg) {
    super();
    this.recipient = arg.recipient;
    this.amount = arg.amount instanceof BN ? arg.amount : new BN(arg.amount);
  }
  protected _marshalBinary(): Buffer {
    return Buffer.concat([
      uvarintMarshalBinary(TransactionType.IssueTokens),
      stringMarshalBinary(this.recipient),
      bigNumberMarshalBinary(this.amount),
    ]);
  }
}

export type KeySpecParamsArg = {
  publicKey: Uint8Array;
};

export class KeySpecParams extends BasePayload {
  public readonly publicKey: Uint8Array;

  constructor(arg: KeySpecParamsArg) {
    super();
    this.publicKey = arg.publicKey;
  }
  protected _marshalBinary(): Buffer {
    return Buffer.concat([bytesMarshalBinary(this.publicKey)]);
  }
}

export type SendTokensArg = {
  hash: Uint8Array;
  meta: unknown;
  to: TokenRecipient[];
};

export class SendTokens extends BasePayload {
  public readonly hash: Uint8Array;
  public readonly meta: unknown;
  public readonly to: TokenRecipient[];

  constructor(arg: SendTokensArg) {
    super();
    this.hash = arg.hash;
    this.meta = arg.meta;
    this.to = arg.to;
  }
  protected _marshalBinary(): Buffer {
    return Buffer.concat([
      uvarintMarshalBinary(TransactionType.SendTokens),
      hashMarshalBinary(this.hash),
      stringMarshalBinary(JSON.stringify(this.meta)),
      arrayMarshalBinary(this.to, (val) => val.marshalBinary()),
    ]);
  }
}

export type SignPendingArg = unknown;

export class SignPending extends BasePayload {
  constructor(_: SignPendingArg) {
    super();
  }
  protected _marshalBinary(): Buffer {
    return Buffer.concat([uvarintMarshalBinary(TransactionType.SignPending)]);
  }
}

export type TokenRecipientArg = {
  url: string;
  amount: number | BN | string;
};

export class TokenRecipient extends BasePayload {
  public readonly url: string;
  public readonly amount: BN;

  constructor(arg: TokenRecipientArg) {
    super();
    this.url = arg.url;
    this.amount = arg.amount instanceof BN ? arg.amount : new BN(arg.amount);
  }
  protected _marshalBinary(): Buffer {
    return Buffer.concat([stringMarshalBinary(this.url), bigNumberMarshalBinary(this.amount)]);
  }
}

export type UpdateKeyPageArg = {
  operation: KeyPageOperation;
  key: Uint8Array;
  newKey: Uint8Array;
  owner: string;
  threshold: number;
};

export class UpdateKeyPage extends BasePayload {
  public readonly operation: KeyPageOperation;
  public readonly key: Uint8Array;
  public readonly newKey: Uint8Array;
  public readonly owner: string;
  public readonly threshold: number;

  constructor(arg: UpdateKeyPageArg) {
    super();
    this.operation = arg.operation;
    this.key = arg.key;
    this.newKey = arg.newKey;
    this.owner = arg.owner;
    this.threshold = arg.threshold;
  }
  protected _marshalBinary(): Buffer {
    return Buffer.concat([
      uvarintMarshalBinary(TransactionType.UpdateKeyPage),
      uvarintMarshalBinary(this.operation),
      bytesMarshalBinary(this.key),
      bytesMarshalBinary(this.newKey),
      stringMarshalBinary(this.owner),
      uvarintMarshalBinary(this.threshold),
    ]);
  }
}

export type WriteDataArg = {
  entry: DataEntry;
};

export class WriteData extends BasePayload {
  public readonly entry: DataEntry;

  constructor(arg: WriteDataArg) {
    super();
    this.entry = arg.entry;
  }
  protected _marshalBinary(): Buffer {
    return Buffer.concat([
      uvarintMarshalBinary(TransactionType.WriteData),
      this.entry.marshalBinary(),
    ]);
  }
}

export type WriteDataToArg = {
  recipient: string;
  entry: DataEntry;
};

export class WriteDataTo extends BasePayload {
  public readonly recipient: string;
  public readonly entry: DataEntry;

  constructor(arg: WriteDataToArg) {
    super();
    this.recipient = arg.recipient;
    this.entry = arg.entry;
  }
  protected _marshalBinary(): Buffer {
    return Buffer.concat([
      uvarintMarshalBinary(TransactionType.WriteDataTo),
      stringMarshalBinary(this.recipient),
      this.entry.marshalBinary(),
    ]);
  }
}
