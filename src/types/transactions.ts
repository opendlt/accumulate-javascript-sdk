// DO NOT EDIT. Generated by generate-sdk.sh.
import BN from "bn.js";
import { AccURL } from "../acc-url";
import {
  bigNumberMarshalBinary,
  booleanMarshalBinary,
  bytesMarshalBinary,
  hashMarshalBinary,
  marshalField,
  stringMarshalBinary,
  uvarintMarshalBinary,
} from "../encoding";
import { BasePayload } from "../payload/base-payload";
import { KeyPageOperation, TransactionType } from "./enums";

/* eslint-disable @typescript-eslint/no-namespace,no-constant-condition */

export type TransactionBody =
  | AddCredits
  | BurnTokens
  | CreateDataAccount
  | CreateIdentity
  | CreateKeyBook
  | CreateKeyPage
  | CreateToken
  | CreateTokenAccount
  | IssueTokens
  | SendTokens
  | SignPending
  | UpdateKeyPage
  | WriteData
  | WriteDataTo;

type TransactionPayload = TransactionBody;

export namespace TransactionBody {
  export function from(arg: unknown): TransactionBody {
    const { type } = <{ type: string }>arg;
    switch (TransactionType.byName(type)) {
      case TransactionType.AddCredits:
        return new AddCredits(<AddCreditsArg>arg);
      case TransactionType.BurnTokens:
        return new BurnTokens(<BurnTokensArg>arg);
      case TransactionType.CreateDataAccount:
        return new CreateDataAccount(<CreateDataAccountArg>arg);
      case TransactionType.CreateIdentity:
        return new CreateIdentity(<CreateIdentityArg>arg);
      case TransactionType.CreateKeyBook:
        return new CreateKeyBook(<CreateKeyBookArg>arg);
      case TransactionType.CreateKeyPage:
        return new CreateKeyPage(<CreateKeyPageArg>arg);
      case TransactionType.CreateToken:
        return new CreateToken(<CreateTokenArg>arg);
      case TransactionType.CreateTokenAccount:
        return new CreateTokenAccount(<CreateTokenAccountArg>arg);
      case TransactionType.IssueTokens:
        return new IssueTokens(<IssueTokensArg>arg);
      case TransactionType.SendTokens:
        return new SendTokens(<SendTokensArg>arg);
      case TransactionType.SignPending:
        return new SignPending(<SignPendingArg>arg);
      case TransactionType.UpdateKeyPage:
        return new UpdateKeyPage(<UpdateKeyPageArg>arg);
      case TransactionType.WriteData:
        return new WriteData(<WriteDataArg>arg);
      case TransactionType.WriteDataTo:
        return new WriteDataTo(<WriteDataToArg>arg);
      default:
        throw new Error(`Unknown TransactionType '${type}'`);
    }
  }
}

export type AddCreditsArg = {
  recipient: string | AccURL;
  amount: number | BN;
};

export class AddCredits extends BasePayload {
  public readonly recipient: AccURL;
  public readonly amount: number | BN;

  constructor(arg: AddCreditsArg) {
    super();
    this.recipient = AccURL.toAccURL(arg.recipient);
    this.amount = arg.amount;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.AddCredits)));
    if (true) {
      parts.push(marshalField(2, stringMarshalBinary(this.recipient.toString())));
    }
    if (true && (this.amount instanceof BN ? !this.amount.isZero() : this.amount !== 0)) {
      parts.push(marshalField(3, uvarintMarshalBinary(this.amount)));
    }
    return Buffer.concat(parts);
  }
}

export type BurnTokensArg = {
  amount: number | BN | string;
};

export class BurnTokens extends BasePayload {
  public readonly amount: BN;

  constructor(arg: BurnTokensArg) {
    super();
    this.amount = arg.amount instanceof BN ? arg.amount : new BN(arg.amount);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.BurnTokens)));
    if (true && !this.amount.isZero()) {
      parts.push(marshalField(2, bigNumberMarshalBinary(this.amount)));
    }
    return Buffer.concat(parts);
  }
}

export type CreateDataAccountArg = {
  url: string | AccURL;
  keyBookUrl?: string | AccURL;
  managerKeyBookUrl?: string | AccURL;
  scratch?: boolean;
};

export class CreateDataAccount extends BasePayload {
  public readonly url: AccURL;
  public readonly keyBookUrl?: AccURL;
  public readonly managerKeyBookUrl?: AccURL;
  public readonly scratch?: boolean;

  constructor(arg: CreateDataAccountArg) {
    super();
    this.url = AccURL.toAccURL(arg.url);
    if (arg.keyBookUrl) this.keyBookUrl = AccURL.toAccURL(arg.keyBookUrl);
    if (arg.managerKeyBookUrl) this.managerKeyBookUrl = AccURL.toAccURL(arg.managerKeyBookUrl);
    if (arg.scratch) this.scratch = arg.scratch;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.CreateDataAccount)));
    if (true) {
      parts.push(marshalField(2, stringMarshalBinary(this.url.toString())));
    }
    if (this.keyBookUrl !== undefined && this.keyBookUrl !== null) {
      parts.push(marshalField(3, stringMarshalBinary(this.keyBookUrl.toString())));
    }
    if (this.managerKeyBookUrl !== undefined && this.managerKeyBookUrl !== null) {
      parts.push(marshalField(4, stringMarshalBinary(this.managerKeyBookUrl.toString())));
    }
    if (this.scratch !== undefined && this.scratch !== null && this.scratch === true) {
      parts.push(marshalField(5, booleanMarshalBinary(this.scratch)));
    }
    return Buffer.concat(parts);
  }
}

export type CreateIdentityArg = {
  url: string | AccURL;
  publicKey: Uint8Array | string;
  keyBookName?: string;
  keyPageName?: string;
  manager?: string | AccURL;
};

export class CreateIdentity extends BasePayload {
  public readonly url: AccURL;
  public readonly publicKey: Uint8Array;
  public readonly keyBookName?: string;
  public readonly keyPageName?: string;
  public readonly manager?: AccURL;

  constructor(arg: CreateIdentityArg) {
    super();
    this.url = AccURL.toAccURL(arg.url);
    this.publicKey =
      typeof arg.publicKey === "string" ? Buffer.from(arg.publicKey, "hex") : arg.publicKey;
    if (arg.keyBookName) this.keyBookName = arg.keyBookName;
    if (arg.keyPageName) this.keyPageName = arg.keyPageName;
    if (arg.manager) this.manager = AccURL.toAccURL(arg.manager);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.CreateIdentity)));
    if (true) {
      parts.push(marshalField(2, stringMarshalBinary(this.url.toString())));
    }
    if (true && this.publicKey.length > 0) {
      parts.push(marshalField(3, bytesMarshalBinary(this.publicKey)));
    }
    if (
      this.keyBookName !== undefined &&
      this.keyBookName !== null &&
      this.keyBookName.length > 0
    ) {
      parts.push(marshalField(4, stringMarshalBinary(this.keyBookName)));
    }
    if (
      this.keyPageName !== undefined &&
      this.keyPageName !== null &&
      this.keyPageName.length > 0
    ) {
      parts.push(marshalField(5, stringMarshalBinary(this.keyPageName)));
    }
    if (this.manager !== undefined && this.manager !== null) {
      parts.push(marshalField(6, stringMarshalBinary(this.manager.toString())));
    }
    return Buffer.concat(parts);
  }
}

export type CreateKeyBookArg = {
  url: string | AccURL;
  pages: (string | AccURL)[];
  manager?: string | AccURL;
};

export class CreateKeyBook extends BasePayload {
  public readonly url: AccURL;
  public readonly pages: AccURL[];
  public readonly manager?: AccURL;

  constructor(arg: CreateKeyBookArg) {
    super();
    this.url = AccURL.toAccURL(arg.url);
    this.pages = arg.pages.map((v) => AccURL.toAccURL(v));
    if (arg.manager) this.manager = AccURL.toAccURL(arg.manager);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.CreateKeyBook)));
    if (true) {
      parts.push(marshalField(2, stringMarshalBinary(this.url.toString())));
    }
    if (true && this.pages.length > 0) {
      parts.push(
        Buffer.concat(this.pages.map((val) => marshalField(3, stringMarshalBinary(val.toString()))))
      );
    }
    if (this.manager !== undefined && this.manager !== null) {
      parts.push(marshalField(4, stringMarshalBinary(this.manager.toString())));
    }
    return Buffer.concat(parts);
  }
}

export type CreateKeyPageArg = {
  url: string | AccURL;
  keys: (KeySpecParams | KeySpecParamsArg)[];
  manager?: string | AccURL;
};

export class CreateKeyPage extends BasePayload {
  public readonly url: AccURL;
  public readonly keys: KeySpecParams[];
  public readonly manager?: AccURL;

  constructor(arg: CreateKeyPageArg) {
    super();
    this.url = AccURL.toAccURL(arg.url);
    this.keys = arg.keys.map((v) => (v instanceof KeySpecParams ? v : new KeySpecParams(v)));
    if (arg.manager) this.manager = AccURL.toAccURL(arg.manager);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.CreateKeyPage)));
    if (true) {
      parts.push(marshalField(2, stringMarshalBinary(this.url.toString())));
    }
    if (true && this.keys.length > 0) {
      parts.push(
        Buffer.concat(
          this.keys.map((val) => marshalField(3, bytesMarshalBinary(val.marshalBinary())))
        )
      );
    }
    if (this.manager !== undefined && this.manager !== null) {
      parts.push(marshalField(4, stringMarshalBinary(this.manager.toString())));
    }
    return Buffer.concat(parts);
  }
}

export type CreateTokenArg = {
  url: string | AccURL;
  keyBookUrl?: string | AccURL;
  symbol: string;
  precision: number | BN;
  properties?: string | AccURL;
  initialSupply?: number | BN | string;
  hasSupplyLimit?: boolean;
  manager?: string | AccURL;
};

export class CreateToken extends BasePayload {
  public readonly url: AccURL;
  public readonly keyBookUrl?: AccURL;
  public readonly symbol: string;
  public readonly precision: number | BN;
  public readonly properties?: AccURL;
  public readonly initialSupply?: BN;
  public readonly hasSupplyLimit?: boolean;
  public readonly manager?: AccURL;

  constructor(arg: CreateTokenArg) {
    super();
    this.url = AccURL.toAccURL(arg.url);
    if (arg.keyBookUrl) this.keyBookUrl = AccURL.toAccURL(arg.keyBookUrl);
    this.symbol = arg.symbol;
    this.precision = arg.precision;
    if (arg.properties) this.properties = AccURL.toAccURL(arg.properties);
    if (arg.initialSupply)
      this.initialSupply =
        arg.initialSupply instanceof BN ? arg.initialSupply : new BN(arg.initialSupply);
    if (arg.hasSupplyLimit) this.hasSupplyLimit = arg.hasSupplyLimit;
    if (arg.manager) this.manager = AccURL.toAccURL(arg.manager);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.CreateToken)));
    if (true) {
      parts.push(marshalField(2, stringMarshalBinary(this.url.toString())));
    }
    if (this.keyBookUrl !== undefined && this.keyBookUrl !== null) {
      parts.push(marshalField(3, stringMarshalBinary(this.keyBookUrl.toString())));
    }
    if (true && this.symbol.length > 0) {
      parts.push(marshalField(4, stringMarshalBinary(this.symbol)));
    }
    if (true && (this.precision instanceof BN ? !this.precision.isZero() : this.precision !== 0)) {
      parts.push(marshalField(5, uvarintMarshalBinary(this.precision)));
    }
    if (this.properties !== undefined && this.properties !== null) {
      parts.push(marshalField(6, stringMarshalBinary(this.properties.toString())));
    }
    if (
      this.initialSupply !== undefined &&
      this.initialSupply !== null &&
      !this.initialSupply.isZero()
    ) {
      parts.push(marshalField(7, bigNumberMarshalBinary(this.initialSupply)));
    }
    if (
      this.hasSupplyLimit !== undefined &&
      this.hasSupplyLimit !== null &&
      this.hasSupplyLimit === true
    ) {
      parts.push(marshalField(8, booleanMarshalBinary(this.hasSupplyLimit)));
    }
    if (this.manager !== undefined && this.manager !== null) {
      parts.push(marshalField(9, stringMarshalBinary(this.manager.toString())));
    }
    return Buffer.concat(parts);
  }
}

export type CreateTokenAccountArg = {
  url: string | AccURL;
  tokenUrl: string | AccURL;
  keyBookUrl?: string | AccURL;
  scratch?: boolean;
  manager?: string | AccURL;
};

export class CreateTokenAccount extends BasePayload {
  public readonly url: AccURL;
  public readonly tokenUrl: AccURL;
  public readonly keyBookUrl?: AccURL;
  public readonly scratch?: boolean;
  public readonly manager?: AccURL;

  constructor(arg: CreateTokenAccountArg) {
    super();
    this.url = AccURL.toAccURL(arg.url);
    this.tokenUrl = AccURL.toAccURL(arg.tokenUrl);
    if (arg.keyBookUrl) this.keyBookUrl = AccURL.toAccURL(arg.keyBookUrl);
    if (arg.scratch) this.scratch = arg.scratch;
    if (arg.manager) this.manager = AccURL.toAccURL(arg.manager);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.CreateTokenAccount)));
    if (true) {
      parts.push(marshalField(2, stringMarshalBinary(this.url.toString())));
    }
    if (true) {
      parts.push(marshalField(3, stringMarshalBinary(this.tokenUrl.toString())));
    }
    if (this.keyBookUrl !== undefined && this.keyBookUrl !== null) {
      parts.push(marshalField(4, stringMarshalBinary(this.keyBookUrl.toString())));
    }
    if (this.scratch !== undefined && this.scratch !== null && this.scratch === true) {
      parts.push(marshalField(5, booleanMarshalBinary(this.scratch)));
    }
    if (this.manager !== undefined && this.manager !== null) {
      parts.push(marshalField(6, stringMarshalBinary(this.manager.toString())));
    }
    return Buffer.concat(parts);
  }
}

export type DataEntryArg = {
  extIds?: (Uint8Array | string)[];
  data?: Uint8Array | string;
};

export class DataEntry extends BasePayload {
  public readonly extIds?: Uint8Array[];
  public readonly data?: Uint8Array;

  constructor(arg: DataEntryArg) {
    super();
    if (arg.extIds)
      this.extIds = arg.extIds.map((v) => (typeof v === "string" ? Buffer.from(v, "hex") : v));
    if (arg.data)
      this.data = typeof arg.data === "string" ? Buffer.from(arg.data, "hex") : arg.data;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    if (this.extIds !== undefined && this.extIds !== null && this.extIds.length > 0) {
      parts.push(Buffer.concat(this.extIds.map((val) => marshalField(1, bytesMarshalBinary(val)))));
    }
    if (this.data !== undefined && this.data !== null && this.data.length > 0) {
      parts.push(marshalField(2, bytesMarshalBinary(this.data)));
    }
    return Buffer.concat(parts);
  }
}

export type ED25519SigArg = {
  nonce: number | BN;
  publicKey: Uint8Array | string;
  signature: Uint8Array | string;
};

export class ED25519Sig extends BasePayload {
  public readonly nonce: number | BN;
  public readonly publicKey: Uint8Array;
  public readonly signature: Uint8Array;

  constructor(arg: ED25519SigArg) {
    super();
    this.nonce = arg.nonce;
    this.publicKey =
      typeof arg.publicKey === "string" ? Buffer.from(arg.publicKey, "hex") : arg.publicKey;
    this.signature =
      typeof arg.signature === "string" ? Buffer.from(arg.signature, "hex") : arg.signature;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    if (true && (this.nonce instanceof BN ? !this.nonce.isZero() : this.nonce !== 0)) {
      parts.push(marshalField(1, uvarintMarshalBinary(this.nonce)));
    }
    if (true && this.publicKey.length > 0) {
      parts.push(marshalField(2, bytesMarshalBinary(this.publicKey)));
    }
    if (true && this.signature.length > 0) {
      parts.push(marshalField(3, bytesMarshalBinary(this.signature)));
    }
    return Buffer.concat(parts);
  }
}

export type EnvelopeArg = {
  signatures: (ED25519Sig | ED25519SigArg)[];
  txHash?: Uint8Array | string;
  transaction?: Transaction | TransactionArg;
};

export class Envelope extends BasePayload {
  public readonly signatures: ED25519Sig[];
  public readonly txHash?: Uint8Array;
  public readonly transaction?: Transaction;

  constructor(arg: EnvelopeArg) {
    super();
    this.signatures = arg.signatures.map((v) => (v instanceof ED25519Sig ? v : new ED25519Sig(v)));
    if (arg.txHash)
      this.txHash = typeof arg.txHash === "string" ? Buffer.from(arg.txHash, "hex") : arg.txHash;
    if (arg.transaction)
      this.transaction =
        arg.transaction instanceof Transaction ? arg.transaction : new Transaction(arg.transaction);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    if (true && this.signatures.length > 0) {
      parts.push(
        Buffer.concat(
          this.signatures.map((val) => marshalField(1, bytesMarshalBinary(val.marshalBinary())))
        )
      );
    }
    if (this.txHash !== undefined && this.txHash !== null && this.txHash.length > 0) {
      parts.push(marshalField(2, bytesMarshalBinary(this.txHash)));
    }
    if (this.transaction !== undefined && this.transaction !== null) {
      parts.push(marshalField(3, bytesMarshalBinary(this.transaction.marshalBinary())));
    }
    return Buffer.concat(parts);
  }
}

export type IssueTokensArg = {
  recipient: string | AccURL;
  amount: number | BN | string;
};

export class IssueTokens extends BasePayload {
  public readonly recipient: AccURL;
  public readonly amount: BN;

  constructor(arg: IssueTokensArg) {
    super();
    this.recipient = AccURL.toAccURL(arg.recipient);
    this.amount = arg.amount instanceof BN ? arg.amount : new BN(arg.amount);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.IssueTokens)));
    if (true) {
      parts.push(marshalField(2, stringMarshalBinary(this.recipient.toString())));
    }
    if (true && !this.amount.isZero()) {
      parts.push(marshalField(3, bigNumberMarshalBinary(this.amount)));
    }
    return Buffer.concat(parts);
  }
}

export type KeySpecParamsArg = {
  publicKey: Uint8Array | string;
};

export class KeySpecParams extends BasePayload {
  public readonly publicKey: Uint8Array;

  constructor(arg: KeySpecParamsArg) {
    super();
    this.publicKey =
      typeof arg.publicKey === "string" ? Buffer.from(arg.publicKey, "hex") : arg.publicKey;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    if (true && this.publicKey.length > 0) {
      parts.push(marshalField(1, bytesMarshalBinary(this.publicKey)));
    }
    return Buffer.concat(parts);
  }
}

export type SendTokensArg = {
  hash?: Uint8Array | string;
  meta?: unknown;
  to: (TokenRecipient | TokenRecipientArg)[];
};

export class SendTokens extends BasePayload {
  public readonly hash?: Uint8Array;
  public readonly meta?: unknown;
  public readonly to: TokenRecipient[];

  constructor(arg: SendTokensArg) {
    super();
    if (arg.hash)
      this.hash = typeof arg.hash === "string" ? Buffer.from(arg.hash, "hex") : arg.hash;
    if (arg.meta) this.meta = arg.meta;
    this.to = arg.to.map((v) => (v instanceof TokenRecipient ? v : new TokenRecipient(v)));
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.SendTokens)));
    if (
      this.hash !== undefined &&
      this.hash !== null &&
      this.hash.length > 0 &&
      this.hash.some((v) => v !== 0)
    ) {
      parts.push(marshalField(2, hashMarshalBinary(this.hash)));
    }
    if (this.meta !== undefined && this.meta !== null) {
      parts.push(marshalField(3, stringMarshalBinary(JSON.stringify(this.meta))));
    }
    if (true && this.to.length > 0) {
      parts.push(
        Buffer.concat(
          this.to.map((val) => marshalField(4, bytesMarshalBinary(val.marshalBinary())))
        )
      );
    }
    return Buffer.concat(parts);
  }
}

export type SignPendingArg = unknown;

export class SignPending extends BasePayload {
  constructor(_: SignPendingArg) {
    super();
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.SignPending)));
    return Buffer.concat(parts);
  }
}

export type TokenRecipientArg = {
  url: string | AccURL;
  amount: number | BN | string;
};

export class TokenRecipient extends BasePayload {
  public readonly url: AccURL;
  public readonly amount: BN;

  constructor(arg: TokenRecipientArg) {
    super();
    this.url = AccURL.toAccURL(arg.url);
    this.amount = arg.amount instanceof BN ? arg.amount : new BN(arg.amount);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    if (true) {
      parts.push(marshalField(1, stringMarshalBinary(this.url.toString())));
    }
    if (true && !this.amount.isZero()) {
      parts.push(marshalField(2, bigNumberMarshalBinary(this.amount)));
    }
    return Buffer.concat(parts);
  }
}

export type TransactionArg = {
  origin: string | AccURL;
  keyPageHeight: number | BN;
  keyPageIndex: number | BN;
  nonce: number | BN;
  body: TransactionPayload;
};

export class Transaction extends BasePayload {
  public readonly origin: AccURL;
  public readonly keyPageHeight: number | BN;
  public readonly keyPageIndex: number | BN;
  public readonly nonce: number | BN;
  public readonly body: TransactionPayload;

  constructor(arg: TransactionArg) {
    super();
    this.origin = AccURL.toAccURL(arg.origin);
    this.keyPageHeight = arg.keyPageHeight;
    this.keyPageIndex = arg.keyPageIndex;
    this.nonce = arg.nonce;
    this.body = arg.body;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    {
      const subParts = [];
      if (true) {
        subParts.push(marshalField(1, stringMarshalBinary(this.origin.toString())));
      }
      if (
        true &&
        (this.keyPageHeight instanceof BN ? !this.keyPageHeight.isZero() : this.keyPageHeight !== 0)
      ) {
        subParts.push(marshalField(2, uvarintMarshalBinary(this.keyPageHeight)));
      }
      if (
        true &&
        (this.keyPageIndex instanceof BN ? !this.keyPageIndex.isZero() : this.keyPageIndex !== 0)
      ) {
        subParts.push(marshalField(3, uvarintMarshalBinary(this.keyPageIndex)));
      }
      if (true && (this.nonce instanceof BN ? !this.nonce.isZero() : this.nonce !== 0)) {
        subParts.push(marshalField(4, uvarintMarshalBinary(this.nonce)));
      }
      parts.push(marshalField(1, bytesMarshalBinary(Buffer.concat(subParts))));
    }
    if (true) {
      parts.push(marshalField(2, bytesMarshalBinary(this.body.marshalBinary())));
    }
    return Buffer.concat(parts);
  }
}

export type TransactionHeaderArg = {
  origin: string | AccURL;
  keyPageHeight: number | BN;
  keyPageIndex: number | BN;
  nonce: number | BN;
};

export class TransactionHeader extends BasePayload {
  public readonly origin: AccURL;
  public readonly keyPageHeight: number | BN;
  public readonly keyPageIndex: number | BN;
  public readonly nonce: number | BN;

  constructor(arg: TransactionHeaderArg) {
    super();
    this.origin = AccURL.toAccURL(arg.origin);
    this.keyPageHeight = arg.keyPageHeight;
    this.keyPageIndex = arg.keyPageIndex;
    this.nonce = arg.nonce;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    if (true) {
      parts.push(marshalField(1, stringMarshalBinary(this.origin.toString())));
    }
    if (
      true &&
      (this.keyPageHeight instanceof BN ? !this.keyPageHeight.isZero() : this.keyPageHeight !== 0)
    ) {
      parts.push(marshalField(2, uvarintMarshalBinary(this.keyPageHeight)));
    }
    if (
      true &&
      (this.keyPageIndex instanceof BN ? !this.keyPageIndex.isZero() : this.keyPageIndex !== 0)
    ) {
      parts.push(marshalField(3, uvarintMarshalBinary(this.keyPageIndex)));
    }
    if (true && (this.nonce instanceof BN ? !this.nonce.isZero() : this.nonce !== 0)) {
      parts.push(marshalField(4, uvarintMarshalBinary(this.nonce)));
    }
    return Buffer.concat(parts);
  }
}

export type UpdateKeyPageArg = {
  operation: KeyPageOperation | string;
  key?: Uint8Array | string;
  newKey?: Uint8Array | string;
  owner?: string | AccURL;
  threshold?: number | BN;
};

export class UpdateKeyPage extends BasePayload {
  public readonly operation: KeyPageOperation;
  public readonly key?: Uint8Array;
  public readonly newKey?: Uint8Array;
  public readonly owner?: AccURL;
  public readonly threshold?: number | BN;

  constructor(arg: UpdateKeyPageArg) {
    super();
    this.operation =
      typeof arg.operation === "string" ? KeyPageOperation.byName(arg.operation) : arg.operation;
    if (arg.key) this.key = typeof arg.key === "string" ? Buffer.from(arg.key, "hex") : arg.key;
    if (arg.newKey)
      this.newKey = typeof arg.newKey === "string" ? Buffer.from(arg.newKey, "hex") : arg.newKey;
    if (arg.owner) this.owner = AccURL.toAccURL(arg.owner);
    if (arg.threshold) this.threshold = arg.threshold;
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.UpdateKeyPage)));
    if (true) {
      parts.push(marshalField(2, uvarintMarshalBinary(this.operation)));
    }
    if (this.key !== undefined && this.key !== null && this.key.length > 0) {
      parts.push(marshalField(3, bytesMarshalBinary(this.key)));
    }
    if (this.newKey !== undefined && this.newKey !== null && this.newKey.length > 0) {
      parts.push(marshalField(4, bytesMarshalBinary(this.newKey)));
    }
    if (this.owner !== undefined && this.owner !== null) {
      parts.push(marshalField(5, stringMarshalBinary(this.owner.toString())));
    }
    if (
      this.threshold !== undefined &&
      this.threshold !== null &&
      (this.threshold instanceof BN ? !this.threshold.isZero() : this.threshold !== 0)
    ) {
      parts.push(marshalField(6, uvarintMarshalBinary(this.threshold)));
    }
    return Buffer.concat(parts);
  }
}

export type WriteDataArg = {
  entry: DataEntry | DataEntryArg;
};

export class WriteData extends BasePayload {
  public readonly entry: DataEntry;

  constructor(arg: WriteDataArg) {
    super();
    this.entry = arg.entry instanceof DataEntry ? arg.entry : new DataEntry(arg.entry);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.WriteData)));
    if (true) {
      parts.push(marshalField(2, bytesMarshalBinary(this.entry.marshalBinary())));
    }
    return Buffer.concat(parts);
  }
}

export type WriteDataToArg = {
  recipient: string | AccURL;
  entry: DataEntry | DataEntryArg;
};

export class WriteDataTo extends BasePayload {
  public readonly recipient: AccURL;
  public readonly entry: DataEntry;

  constructor(arg: WriteDataToArg) {
    super();
    this.recipient = AccURL.toAccURL(arg.recipient);
    this.entry = arg.entry instanceof DataEntry ? arg.entry : new DataEntry(arg.entry);
  }
  protected _marshalBinary(): Buffer {
    const parts = [];
    parts.push(marshalField(1, uvarintMarshalBinary(TransactionType.WriteDataTo)));
    if (true) {
      parts.push(marshalField(2, stringMarshalBinary(this.recipient.toString())));
    }
    if (true) {
      parts.push(marshalField(3, bytesMarshalBinary(this.entry.marshalBinary())));
    }
    return Buffer.concat(parts);
  }
}
