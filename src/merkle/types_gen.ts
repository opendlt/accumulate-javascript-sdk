import { encodeAs } from "../encoding";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */

export type ReceiptArgs = {
  start?: Uint8Array | string;
  startIndex?: number;
  end?: Uint8Array | string;
  endIndex?: number;
  anchor?: Uint8Array | string;
  entries?: (ReceiptEntry | ReceiptEntryArgs)[];
};
export class Receipt {
  @encodeAs.field(1).bytes
  public start?: Uint8Array;
  @encodeAs.field(2).int
  public startIndex?: number;
  @encodeAs.field(3).bytes
  public end?: Uint8Array;
  @encodeAs.field(4).int
  public endIndex?: number;
  @encodeAs.field(5).bytes
  public anchor?: Uint8Array;
  @encodeAs.field(6).repeatable.reference
  public entries?: ReceiptEntry[];

  constructor(args: ReceiptArgs) {
    this.start =
      args.start == undefined
        ? undefined
        : args.start instanceof Uint8Array
        ? args.start
        : Buffer.from(args.start, "hex");
    this.startIndex = args.startIndex == undefined ? undefined : args.startIndex;
    this.end =
      args.end == undefined
        ? undefined
        : args.end instanceof Uint8Array
        ? args.end
        : Buffer.from(args.end, "hex");
    this.endIndex = args.endIndex == undefined ? undefined : args.endIndex;
    this.anchor =
      args.anchor == undefined
        ? undefined
        : args.anchor instanceof Uint8Array
        ? args.anchor
        : Buffer.from(args.anchor, "hex");
    this.entries =
      args.entries == undefined
        ? undefined
        : args.entries.map((v) => (v instanceof ReceiptEntry ? v : new ReceiptEntry(v)));
  }

  copy() {
    return new Receipt(this.asObject());
  }

  asObject(): ReceiptArgs {
    return {
      start: this.start && Buffer.from(this.start).toString("hex"),
      startIndex: this.startIndex && this.startIndex,
      end: this.end && Buffer.from(this.end).toString("hex"),
      endIndex: this.endIndex && this.endIndex,
      anchor: this.anchor && Buffer.from(this.anchor).toString("hex"),
      entries: this.entries && this.entries?.map((v) => v.asObject()),
    };
  }
}

export type ReceiptEntryArgs = {
  right?: boolean;
  hash?: Uint8Array | string;
};
export class ReceiptEntry {
  @encodeAs.field(1).bool
  public right?: boolean;
  @encodeAs.field(2).bytes
  public hash?: Uint8Array;

  constructor(args: ReceiptEntryArgs) {
    this.right = args.right == undefined ? undefined : args.right;
    this.hash =
      args.hash == undefined
        ? undefined
        : args.hash instanceof Uint8Array
        ? args.hash
        : Buffer.from(args.hash, "hex");
  }

  copy() {
    return new ReceiptEntry(this.asObject());
  }

  asObject(): ReceiptEntryArgs {
    return {
      right: this.right && this.right,
      hash: this.hash && Buffer.from(this.hash).toString("hex"),
    };
  }
}

export type StateArgs = {
  count?: number;
  pending?: (Uint8Array | string)[];
  hashList?: (Uint8Array | string)[];
};
export class State {
  public count?: number;
  public pending?: Uint8Array[];
  public hashList?: Uint8Array[];

  constructor(args: StateArgs) {
    this.count = args.count == undefined ? undefined : args.count;
    this.pending =
      args.pending == undefined
        ? undefined
        : args.pending.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
    this.hashList =
      args.hashList == undefined
        ? undefined
        : args.hashList.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
  }

  copy() {
    return new State(this.asObject());
  }

  asObject(): StateArgs {
    return {
      count: this.count && this.count,
      pending: this.pending && this.pending?.map((v) => Buffer.from(v).toString("hex")),
      hashList: this.hashList && this.hashList?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}
