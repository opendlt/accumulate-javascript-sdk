import BN from "bn.js";
import {
  Account,
  AccountArgs,
  AccountAuthOperation,
  AccountAuthOperationArgs,
  AccountAuthOperationType,
  AccountType,
  AllowedTransactions,
  AllowedTransactionsArgs,
  AnchorBody,
  AnchorBodyArgs,
  BookType,
  BookTypeArgs,
  DataEntry,
  DataEntryArgs,
  DataEntryType,
  ExecutorVersion,
  ExecutorVersionArgs,
  Fee,
  FeeArgs,
  KeyPageOperation,
  KeyPageOperationArgs,
  KeyPageOperationType,
  PartitionType,
  PartitionTypeArgs,
  Signature,
  SignatureArgs,
  SignatureType,
  Signer,
  SignerArgs,
  TransactionBody,
  TransactionBodyArgs,
  TransactionResult,
  TransactionResultArgs,
  TransactionType,
  TransactionTypeArgs,
  VoteType,
  VoteTypeArgs,
} from ".";
import { encodeAs } from "../encoding";
import * as errors2 from "../errors";
import * as merkle from "../merkle";
import { ChainType, ChainTypeArgs } from "../merkle";
import { TxID, URL } from "../url";
import { TransactionBase } from "./base";

// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */

export type ADIArgs = {
  url?: URL | string;
  authorities?: (AuthorityEntry | AuthorityEntryArgs)[];
};
export type ADIArgsWithType = ADIArgs & { type: AccountType.Identity | "identity" };
export class ADI {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountType.Identity;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(3, 1).repeatable.reference
  public authorities?: AuthorityEntry[];

  constructor(args: ADIArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.authorities =
      args.authorities == undefined
        ? undefined
        : args.authorities.map((v) => (v instanceof AuthorityEntry ? v : new AuthorityEntry(v)));
  }

  copy() {
    return new ADI(this.asObject());
  }

  asObject(): ADIArgsWithType {
    return {
      type: "identity",
      url: this.url && this.url.toString(),
      authorities: this.authorities && this.authorities?.map((v) => v.asObject()),
    };
  }
}

export type AccountAuthArgs = {
  authorities?: (AuthorityEntry | AuthorityEntryArgs)[];
};
export class AccountAuth {
  @encodeAs.field(1).repeatable.reference
  public authorities?: AuthorityEntry[];

  constructor(args: AccountAuthArgs) {
    this.authorities =
      args.authorities == undefined
        ? undefined
        : args.authorities.map((v) => (v instanceof AuthorityEntry ? v : new AuthorityEntry(v)));
  }

  copy() {
    return new AccountAuth(this.asObject());
  }

  asObject(): AccountAuthArgs {
    return {
      authorities: this.authorities && this.authorities?.map((v) => v.asObject()),
    };
  }
}

export type AccumulateDataEntryArgs = {
  data?: (Uint8Array | string)[];
};
export type AccumulateDataEntryArgsWithType = AccumulateDataEntryArgs & {
  type: DataEntryType.Accumulate | "accumulate";
};
export class AccumulateDataEntry {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = DataEntryType.Accumulate;
  @encodeAs.field(2).repeatable.bytes
  public data?: Uint8Array[];

  constructor(args: AccumulateDataEntryArgs) {
    this.data =
      args.data == undefined
        ? undefined
        : args.data.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
  }

  copy() {
    return new AccumulateDataEntry(this.asObject());
  }

  asObject(): AccumulateDataEntryArgsWithType {
    return {
      type: "accumulate",
      data: this.data && this.data?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export type AcmeFaucetArgs = {
  url?: URL | string;
};
export type AcmeFaucetArgsWithType = AcmeFaucetArgs & {
  type: TransactionType.AcmeFaucet | "acmeFaucet";
};
export class AcmeFaucet {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.AcmeFaucet;
  @encodeAs.field(2).url
  public url?: URL;

  constructor(args: AcmeFaucetArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
  }

  copy() {
    return new AcmeFaucet(this.asObject());
  }

  asObject(): AcmeFaucetArgsWithType {
    return {
      type: "acmeFaucet",
      url: this.url && this.url.toString(),
    };
  }
}

export type AcmeOracleArgs = {
  price?: number;
};
export class AcmeOracle {
  @encodeAs.field(1).uint
  public price?: number;

  constructor(args: AcmeOracleArgs) {
    this.price = args.price == undefined ? undefined : args.price;
  }

  copy() {
    return new AcmeOracle(this.asObject());
  }

  asObject(): AcmeOracleArgs {
    return {
      price: this.price && this.price,
    };
  }
}

export type ActivateProtocolVersionArgs = {
  version?: ExecutorVersionArgs;
};
export type ActivateProtocolVersionArgsWithType = ActivateProtocolVersionArgs & {
  type: TransactionType.ActivateProtocolVersion | "activateProtocolVersion";
};
export class ActivateProtocolVersion {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.ActivateProtocolVersion;
  @encodeAs.field(2).enum
  public version?: ExecutorVersion;

  constructor(args: ActivateProtocolVersionArgs) {
    this.version = args.version == undefined ? undefined : ExecutorVersion.fromObject(args.version);
  }

  copy() {
    return new ActivateProtocolVersion(this.asObject());
  }

  asObject(): ActivateProtocolVersionArgsWithType {
    return {
      type: "activateProtocolVersion",
      version: this.version && ExecutorVersion.getName(this.version),
    };
  }
}

export type AddAccountAuthorityOperationArgs = {
  authority?: URL | string;
};
export type AddAccountAuthorityOperationArgsWithType = AddAccountAuthorityOperationArgs & {
  type: AccountAuthOperationType.AddAuthority | "addAuthority";
};
export class AddAccountAuthorityOperation {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountAuthOperationType.AddAuthority;
  @encodeAs.field(2).url
  public authority?: URL;

  constructor(args: AddAccountAuthorityOperationArgs) {
    this.authority =
      args.authority == undefined
        ? undefined
        : args.authority instanceof URL
        ? args.authority
        : new URL(args.authority);
  }

  copy() {
    return new AddAccountAuthorityOperation(this.asObject());
  }

  asObject(): AddAccountAuthorityOperationArgsWithType {
    return {
      type: "addAuthority",
      authority: this.authority && this.authority.toString(),
    };
  }
}

export type AddCreditsArgs = {
  recipient?: URL | string;
  amount?: BN | string | number;
  oracle?: number;
};
export type AddCreditsArgsWithType = AddCreditsArgs & {
  type: TransactionType.AddCredits | "addCredits";
};
export class AddCredits {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.AddCredits;
  @encodeAs.field(2).url
  public recipient?: URL;
  @encodeAs.field(3).bigInt
  public amount?: BN;
  @encodeAs.field(4).uint
  public oracle?: number;

  constructor(args: AddCreditsArgs) {
    this.recipient =
      args.recipient == undefined
        ? undefined
        : args.recipient instanceof URL
        ? args.recipient
        : new URL(args.recipient);
    this.amount =
      args.amount == undefined
        ? undefined
        : args.amount instanceof BN
        ? args.amount
        : new BN(args.amount);
    this.oracle = args.oracle == undefined ? undefined : args.oracle;
  }

  copy() {
    return new AddCredits(this.asObject());
  }

  asObject(): AddCreditsArgsWithType {
    return {
      type: "addCredits",
      recipient: this.recipient && this.recipient.toString(),
      amount: this.amount && this.amount.toString(),
      oracle: this.oracle && this.oracle,
    };
  }
}

export type AddCreditsResultArgs = {
  amount?: BN | string | number;
  credits?: number;
  oracle?: number;
};
export type AddCreditsResultArgsWithType = AddCreditsResultArgs & {
  type: TransactionType.AddCredits | "addCredits";
};
export class AddCreditsResult {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.AddCredits;
  @encodeAs.field(2).bigInt
  public amount?: BN;
  @encodeAs.field(3).uint
  public credits?: number;
  @encodeAs.field(4).uint
  public oracle?: number;

  constructor(args: AddCreditsResultArgs) {
    this.amount =
      args.amount == undefined
        ? undefined
        : args.amount instanceof BN
        ? args.amount
        : new BN(args.amount);
    this.credits = args.credits == undefined ? undefined : args.credits;
    this.oracle = args.oracle == undefined ? undefined : args.oracle;
  }

  copy() {
    return new AddCreditsResult(this.asObject());
  }

  asObject(): AddCreditsResultArgsWithType {
    return {
      type: "addCredits",
      amount: this.amount && this.amount.toString(),
      credits: this.credits && this.credits,
      oracle: this.oracle && this.oracle,
    };
  }
}

export type AddKeyOperationArgs = {
  entry?: KeySpecParams | KeySpecParamsArgs;
};
export type AddKeyOperationArgsWithType = AddKeyOperationArgs & {
  type: KeyPageOperationType.Add | "add";
};
export class AddKeyOperation {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = KeyPageOperationType.Add;
  @encodeAs.field(2).reference
  public entry?: KeySpecParams;

  constructor(args: AddKeyOperationArgs) {
    this.entry =
      args.entry == undefined
        ? undefined
        : args.entry instanceof KeySpecParams
        ? args.entry
        : new KeySpecParams(args.entry);
  }

  copy() {
    return new AddKeyOperation(this.asObject());
  }

  asObject(): AddKeyOperationArgsWithType {
    return {
      type: "add",
      entry: this.entry && this.entry.asObject(),
    };
  }
}

export type AnchorLedgerArgs = {
  url?: URL | string;
  minorBlockSequenceNumber?: number;
  majorBlockIndex?: number;
  majorBlockTime?: Date | string;
  pendingMajorBlockAnchors?: (URL | string)[];
  sequence?: (PartitionSyntheticLedger | PartitionSyntheticLedgerArgs)[];
};
export type AnchorLedgerArgsWithType = AnchorLedgerArgs & {
  type: AccountType.AnchorLedger | "anchorLedger";
};
export class AnchorLedger {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountType.AnchorLedger;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(3).uint
  public minorBlockSequenceNumber?: number;
  @encodeAs.field(4).uint
  public majorBlockIndex?: number;
  @encodeAs.field(5).time
  public majorBlockTime?: Date;
  @encodeAs.field(6).repeatable.url
  public pendingMajorBlockAnchors?: URL[];
  @encodeAs.field(7).repeatable.reference
  public sequence?: PartitionSyntheticLedger[];

  constructor(args: AnchorLedgerArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.minorBlockSequenceNumber =
      args.minorBlockSequenceNumber == undefined ? undefined : args.minorBlockSequenceNumber;
    this.majorBlockIndex = args.majorBlockIndex == undefined ? undefined : args.majorBlockIndex;
    this.majorBlockTime =
      args.majorBlockTime == undefined
        ? undefined
        : args.majorBlockTime instanceof Date
        ? args.majorBlockTime
        : new Date(args.majorBlockTime);
    this.pendingMajorBlockAnchors =
      args.pendingMajorBlockAnchors == undefined
        ? undefined
        : args.pendingMajorBlockAnchors.map((v) => (v instanceof URL ? v : new URL(v)));
    this.sequence =
      args.sequence == undefined
        ? undefined
        : args.sequence.map((v) =>
            v instanceof PartitionSyntheticLedger ? v : new PartitionSyntheticLedger(v)
          );
  }

  copy() {
    return new AnchorLedger(this.asObject());
  }

  asObject(): AnchorLedgerArgsWithType {
    return {
      type: "anchorLedger",
      url: this.url && this.url.toString(),
      minorBlockSequenceNumber: this.minorBlockSequenceNumber && this.minorBlockSequenceNumber,
      majorBlockIndex: this.majorBlockIndex && this.majorBlockIndex,
      majorBlockTime: this.majorBlockTime && this.majorBlockTime,
      pendingMajorBlockAnchors:
        this.pendingMajorBlockAnchors && this.pendingMajorBlockAnchors?.map((v) => v.toString()),
      sequence: this.sequence && this.sequence?.map((v) => v.asObject()),
    };
  }
}

export type AnchorMetadataArgs = {
  name?: string;
  type?: ChainTypeArgs;
  account?: URL | string;
  index?: number;
  sourceIndex?: number;
  sourceBlock?: number;
  entry?: Uint8Array | string;
};
export class AnchorMetadata {
  @encodeAs.field(1, 1).string
  public name?: string;
  @encodeAs.field(1, 2).enum
  public type?: ChainType;
  @encodeAs.field(2).url
  public account?: URL;
  @encodeAs.field(3).uint
  public index?: number;
  @encodeAs.field(4).uint
  public sourceIndex?: number;
  @encodeAs.field(5).uint
  public sourceBlock?: number;
  @encodeAs.field(6).bytes
  public entry?: Uint8Array;

  constructor(args: AnchorMetadataArgs) {
    this.name = args.name == undefined ? undefined : args.name;
    this.type = args.type == undefined ? undefined : ChainType.fromObject(args.type);
    this.account =
      args.account == undefined
        ? undefined
        : args.account instanceof URL
        ? args.account
        : new URL(args.account);
    this.index = args.index == undefined ? undefined : args.index;
    this.sourceIndex = args.sourceIndex == undefined ? undefined : args.sourceIndex;
    this.sourceBlock = args.sourceBlock == undefined ? undefined : args.sourceBlock;
    this.entry =
      args.entry == undefined
        ? undefined
        : args.entry instanceof Uint8Array
        ? args.entry
        : Buffer.from(args.entry, "hex");
  }

  copy() {
    return new AnchorMetadata(this.asObject());
  }

  asObject(): AnchorMetadataArgs {
    return {
      name: this.name && this.name,
      type: this.type && ChainType.getName(this.type),
      account: this.account && this.account.toString(),
      index: this.index && this.index,
      sourceIndex: this.sourceIndex && this.sourceIndex,
      sourceBlock: this.sourceBlock && this.sourceBlock,
      entry: this.entry && Buffer.from(this.entry).toString("hex"),
    };
  }
}

export type AnnotatedReceiptArgs = {
  receipt?: merkle.Receipt | merkle.ReceiptArgs;
  anchor?: AnchorMetadata | AnchorMetadataArgs;
};
export class AnnotatedReceipt {
  @encodeAs.field(1).reference
  public receipt?: merkle.Receipt;
  @encodeAs.field(2).reference
  public anchor?: AnchorMetadata;

  constructor(args: AnnotatedReceiptArgs) {
    this.receipt =
      args.receipt == undefined
        ? undefined
        : args.receipt instanceof merkle.Receipt
        ? args.receipt
        : new merkle.Receipt(args.receipt);
    this.anchor =
      args.anchor == undefined
        ? undefined
        : args.anchor instanceof AnchorMetadata
        ? args.anchor
        : new AnchorMetadata(args.anchor);
  }

  copy() {
    return new AnnotatedReceipt(this.asObject());
  }

  asObject(): AnnotatedReceiptArgs {
    return {
      receipt: this.receipt && this.receipt.asObject(),
      anchor: this.anchor && this.anchor.asObject(),
    };
  }
}

export type AuthorityEntryArgs = {
  url?: URL | string;
  disabled?: boolean;
};
export class AuthorityEntry {
  @encodeAs.field(1).url
  public url?: URL;
  @encodeAs.field(2).bool
  public disabled?: boolean;

  constructor(args: AuthorityEntryArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.disabled = args.disabled == undefined ? undefined : args.disabled;
  }

  copy() {
    return new AuthorityEntry(this.asObject());
  }

  asObject(): AuthorityEntryArgs {
    return {
      url: this.url && this.url.toString(),
      disabled: this.disabled && this.disabled,
    };
  }
}

export type AuthoritySignatureArgs = {
  origin?: URL | string;
  authority?: URL | string;
  vote?: VoteTypeArgs;
  txID?: TxID | string;
  cause?: TxID | string;
  delegator?: (URL | string)[];
};
export type AuthoritySignatureArgsWithType = AuthoritySignatureArgs & {
  type: SignatureType.Authority | "authority";
};
export class AuthoritySignature {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = SignatureType.Authority;
  @encodeAs.field(2).url
  public origin?: URL;
  @encodeAs.field(3).url
  public authority?: URL;
  @encodeAs.field(4).enum
  public vote?: VoteType;
  @encodeAs.field(5).txid
  public txID?: TxID;
  @encodeAs.field(6).txid
  public cause?: TxID;
  @encodeAs.field(7).repeatable.url
  public delegator?: URL[];

  constructor(args: AuthoritySignatureArgs) {
    this.origin =
      args.origin == undefined
        ? undefined
        : args.origin instanceof URL
        ? args.origin
        : new URL(args.origin);
    this.authority =
      args.authority == undefined
        ? undefined
        : args.authority instanceof URL
        ? args.authority
        : new URL(args.authority);
    this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
    this.txID =
      args.txID == undefined
        ? undefined
        : args.txID instanceof TxID
        ? args.txID
        : new TxID(args.txID);
    this.cause =
      args.cause == undefined
        ? undefined
        : args.cause instanceof TxID
        ? args.cause
        : new TxID(args.cause);
    this.delegator =
      args.delegator == undefined
        ? undefined
        : args.delegator.map((v) => (v instanceof URL ? v : new URL(v)));
  }

  copy() {
    return new AuthoritySignature(this.asObject());
  }

  asObject(): AuthoritySignatureArgsWithType {
    return {
      type: "authority",
      origin: this.origin && this.origin.toString(),
      authority: this.authority && this.authority.toString(),
      vote: this.vote && VoteType.getName(this.vote),
      txID: this.txID && this.txID.toString(),
      cause: this.cause && this.cause.toString(),
      delegator: this.delegator && this.delegator?.map((v) => v.toString()),
    };
  }
}

export type BTCLegacySignatureArgs = {
  publicKey?: Uint8Array | string;
  signature?: Uint8Array | string;
  signer?: URL | string;
  signerVersion?: number;
  timestamp?: number;
  vote?: VoteTypeArgs;
  transactionHash?: Uint8Array | string;
};
export type BTCLegacySignatureArgsWithType = BTCLegacySignatureArgs & {
  type: SignatureType.BTCLegacy | "btclegacy";
};
export class BTCLegacySignature {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = SignatureType.BTCLegacy;
  @encodeAs.field(2).bytes
  public publicKey?: Uint8Array;
  @encodeAs.field(3).bytes
  public signature?: Uint8Array;
  @encodeAs.field(4).url
  public signer?: URL;
  @encodeAs.field(5).uint
  public signerVersion?: number;
  @encodeAs.field(6).uint
  public timestamp?: number;
  @encodeAs.field(7).enum
  public vote?: VoteType;
  @encodeAs.field(8).hash
  public transactionHash?: Uint8Array;

  constructor(args: BTCLegacySignatureArgs) {
    this.publicKey =
      args.publicKey == undefined
        ? undefined
        : args.publicKey instanceof Uint8Array
        ? args.publicKey
        : Buffer.from(args.publicKey, "hex");
    this.signature =
      args.signature == undefined
        ? undefined
        : args.signature instanceof Uint8Array
        ? args.signature
        : Buffer.from(args.signature, "hex");
    this.signer =
      args.signer == undefined
        ? undefined
        : args.signer instanceof URL
        ? args.signer
        : new URL(args.signer);
    this.signerVersion = args.signerVersion == undefined ? undefined : args.signerVersion;
    this.timestamp = args.timestamp == undefined ? undefined : args.timestamp;
    this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
    this.transactionHash =
      args.transactionHash == undefined
        ? undefined
        : args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  copy() {
    return new BTCLegacySignature(this.asObject());
  }

  asObject(): BTCLegacySignatureArgsWithType {
    return {
      type: "btclegacy",
      publicKey: this.publicKey && Buffer.from(this.publicKey).toString("hex"),
      signature: this.signature && Buffer.from(this.signature).toString("hex"),
      signer: this.signer && this.signer.toString(),
      signerVersion: this.signerVersion && this.signerVersion,
      timestamp: this.timestamp && this.timestamp,
      vote: this.vote && VoteType.getName(this.vote),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export type BTCSignatureArgs = {
  publicKey?: Uint8Array | string;
  signature?: Uint8Array | string;
  signer?: URL | string;
  signerVersion?: number;
  timestamp?: number;
  vote?: VoteTypeArgs;
  transactionHash?: Uint8Array | string;
};
export type BTCSignatureArgsWithType = BTCSignatureArgs & { type: SignatureType.BTC | "btc" };
export class BTCSignature {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = SignatureType.BTC;
  @encodeAs.field(2).bytes
  public publicKey?: Uint8Array;
  @encodeAs.field(3).bytes
  public signature?: Uint8Array;
  @encodeAs.field(4).url
  public signer?: URL;
  @encodeAs.field(5).uint
  public signerVersion?: number;
  @encodeAs.field(6).uint
  public timestamp?: number;
  @encodeAs.field(7).enum
  public vote?: VoteType;
  @encodeAs.field(8).hash
  public transactionHash?: Uint8Array;

  constructor(args: BTCSignatureArgs) {
    this.publicKey =
      args.publicKey == undefined
        ? undefined
        : args.publicKey instanceof Uint8Array
        ? args.publicKey
        : Buffer.from(args.publicKey, "hex");
    this.signature =
      args.signature == undefined
        ? undefined
        : args.signature instanceof Uint8Array
        ? args.signature
        : Buffer.from(args.signature, "hex");
    this.signer =
      args.signer == undefined
        ? undefined
        : args.signer instanceof URL
        ? args.signer
        : new URL(args.signer);
    this.signerVersion = args.signerVersion == undefined ? undefined : args.signerVersion;
    this.timestamp = args.timestamp == undefined ? undefined : args.timestamp;
    this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
    this.transactionHash =
      args.transactionHash == undefined
        ? undefined
        : args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  copy() {
    return new BTCSignature(this.asObject());
  }

  asObject(): BTCSignatureArgsWithType {
    return {
      type: "btc",
      publicKey: this.publicKey && Buffer.from(this.publicKey).toString("hex"),
      signature: this.signature && Buffer.from(this.signature).toString("hex"),
      signer: this.signer && this.signer.toString(),
      signerVersion: this.signerVersion && this.signerVersion,
      timestamp: this.timestamp && this.timestamp,
      vote: this.vote && VoteType.getName(this.vote),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export type BlockEntryArgs = {
  account?: URL | string;
  chain?: string;
  index?: number;
};
export class BlockEntry {
  @encodeAs.field(1).url
  public account?: URL;
  @encodeAs.field(2).string
  public chain?: string;
  @encodeAs.field(3).keepEmpty.uint
  public index?: number;

  constructor(args: BlockEntryArgs) {
    this.account =
      args.account == undefined
        ? undefined
        : args.account instanceof URL
        ? args.account
        : new URL(args.account);
    this.chain = args.chain == undefined ? undefined : args.chain;
    this.index = args.index == undefined ? undefined : args.index;
  }

  copy() {
    return new BlockEntry(this.asObject());
  }

  asObject(): BlockEntryArgs {
    return {
      account: this.account && this.account.toString(),
      chain: this.chain && this.chain,
      index: this.index && this.index,
    };
  }
}

export type BlockLedgerArgs = {
  url?: URL | string;
  index?: number;
  time?: Date | string;
  entries?: (BlockEntry | BlockEntryArgs)[];
};
export type BlockLedgerArgsWithType = BlockLedgerArgs & {
  type: AccountType.BlockLedger | "blockLedger";
};
export class BlockLedger {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountType.BlockLedger;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(3).uint
  public index?: number;
  @encodeAs.field(4).time
  public time?: Date;
  @encodeAs.field(5).repeatable.reference
  public entries?: BlockEntry[];

  constructor(args: BlockLedgerArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.index = args.index == undefined ? undefined : args.index;
    this.time =
      args.time == undefined
        ? undefined
        : args.time instanceof Date
        ? args.time
        : new Date(args.time);
    this.entries =
      args.entries == undefined
        ? undefined
        : args.entries.map((v) => (v instanceof BlockEntry ? v : new BlockEntry(v)));
  }

  copy() {
    return new BlockLedger(this.asObject());
  }

  asObject(): BlockLedgerArgsWithType {
    return {
      type: "blockLedger",
      url: this.url && this.url.toString(),
      index: this.index && this.index,
      time: this.time && this.time,
      entries: this.entries && this.entries?.map((v) => v.asObject()),
    };
  }
}

export type BlockValidatorAnchorArgs = {
  source?: URL | string;
  majorBlockIndex?: number;
  minorBlockIndex?: number;
  rootChainIndex?: number;
  rootChainAnchor?: Uint8Array | string;
  stateTreeAnchor?: Uint8Array | string;
  acmeBurnt?: BN | string | number;
};
export type BlockValidatorAnchorArgsWithType = BlockValidatorAnchorArgs & {
  type: TransactionType.BlockValidatorAnchor | "blockValidatorAnchor";
};
export class BlockValidatorAnchor {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.BlockValidatorAnchor;
  @encodeAs.field(2, 1).url
  public source?: URL;
  @encodeAs.field(2, 2).uint
  public majorBlockIndex?: number;
  @encodeAs.field(2, 3).uint
  public minorBlockIndex?: number;
  @encodeAs.field(2, 4).uint
  public rootChainIndex?: number;
  @encodeAs.field(2, 5).hash
  public rootChainAnchor?: Uint8Array;
  @encodeAs.field(2, 6).hash
  public stateTreeAnchor?: Uint8Array;
  @encodeAs.field(3).bigInt
  public acmeBurnt?: BN;

  constructor(args: BlockValidatorAnchorArgs) {
    this.source =
      args.source == undefined
        ? undefined
        : args.source instanceof URL
        ? args.source
        : new URL(args.source);
    this.majorBlockIndex = args.majorBlockIndex == undefined ? undefined : args.majorBlockIndex;
    this.minorBlockIndex = args.minorBlockIndex == undefined ? undefined : args.minorBlockIndex;
    this.rootChainIndex = args.rootChainIndex == undefined ? undefined : args.rootChainIndex;
    this.rootChainAnchor =
      args.rootChainAnchor == undefined
        ? undefined
        : args.rootChainAnchor instanceof Uint8Array
        ? args.rootChainAnchor
        : Buffer.from(args.rootChainAnchor, "hex");
    this.stateTreeAnchor =
      args.stateTreeAnchor == undefined
        ? undefined
        : args.stateTreeAnchor instanceof Uint8Array
        ? args.stateTreeAnchor
        : Buffer.from(args.stateTreeAnchor, "hex");
    this.acmeBurnt =
      args.acmeBurnt == undefined
        ? undefined
        : args.acmeBurnt instanceof BN
        ? args.acmeBurnt
        : new BN(args.acmeBurnt);
  }

  copy() {
    return new BlockValidatorAnchor(this.asObject());
  }

  asObject(): BlockValidatorAnchorArgsWithType {
    return {
      type: "blockValidatorAnchor",
      source: this.source && this.source.toString(),
      majorBlockIndex: this.majorBlockIndex && this.majorBlockIndex,
      minorBlockIndex: this.minorBlockIndex && this.minorBlockIndex,
      rootChainIndex: this.rootChainIndex && this.rootChainIndex,
      rootChainAnchor: this.rootChainAnchor && Buffer.from(this.rootChainAnchor).toString("hex"),
      stateTreeAnchor: this.stateTreeAnchor && Buffer.from(this.stateTreeAnchor).toString("hex"),
      acmeBurnt: this.acmeBurnt && this.acmeBurnt.toString(),
    };
  }
}

export type BurnCreditsArgs = {
  amount?: number;
};
export type BurnCreditsArgsWithType = BurnCreditsArgs & {
  type: TransactionType.BurnCredits | "burnCredits";
};
export class BurnCredits {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.BurnCredits;
  @encodeAs.field(2).uint
  public amount?: number;

  constructor(args: BurnCreditsArgs) {
    this.amount = args.amount == undefined ? undefined : args.amount;
  }

  copy() {
    return new BurnCredits(this.asObject());
  }

  asObject(): BurnCreditsArgsWithType {
    return {
      type: "burnCredits",
      amount: this.amount && this.amount,
    };
  }
}

export type BurnTokensArgs = {
  amount?: BN | string | number;
};
export type BurnTokensArgsWithType = BurnTokensArgs & {
  type: TransactionType.BurnTokens | "burnTokens";
};
export class BurnTokens {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.BurnTokens;
  @encodeAs.field(2).bigInt
  public amount?: BN;

  constructor(args: BurnTokensArgs) {
    this.amount =
      args.amount == undefined
        ? undefined
        : args.amount instanceof BN
        ? args.amount
        : new BN(args.amount);
  }

  copy() {
    return new BurnTokens(this.asObject());
  }

  asObject(): BurnTokensArgsWithType {
    return {
      type: "burnTokens",
      amount: this.amount && this.amount.toString(),
    };
  }
}

export type ChainMetadataArgs = {
  name?: string;
  type?: ChainTypeArgs;
};
export class ChainMetadata {
  @encodeAs.field(1).string
  public name?: string;
  @encodeAs.field(2).enum
  public type?: ChainType;

  constructor(args: ChainMetadataArgs) {
    this.name = args.name == undefined ? undefined : args.name;
    this.type = args.type == undefined ? undefined : ChainType.fromObject(args.type);
  }

  copy() {
    return new ChainMetadata(this.asObject());
  }

  asObject(): ChainMetadataArgs {
    return {
      name: this.name && this.name,
      type: this.type && ChainType.getName(this.type),
    };
  }
}

export type ChainParamsArgs = {
  data?: Uint8Array | string;
  isUpdate?: boolean;
};
export class ChainParams {
  @encodeAs.field(1).bytes
  public data?: Uint8Array;
  @encodeAs.field(2).bool
  public isUpdate?: boolean;

  constructor(args: ChainParamsArgs) {
    this.data =
      args.data == undefined
        ? undefined
        : args.data instanceof Uint8Array
        ? args.data
        : Buffer.from(args.data, "hex");
    this.isUpdate = args.isUpdate == undefined ? undefined : args.isUpdate;
  }

  copy() {
    return new ChainParams(this.asObject());
  }

  asObject(): ChainParamsArgs {
    return {
      data: this.data && Buffer.from(this.data).toString("hex"),
      isUpdate: this.isUpdate && this.isUpdate,
    };
  }
}

export type CreateDataAccountArgs = {
  url?: URL | string;
  authorities?: (URL | string)[];
};
export type CreateDataAccountArgsWithType = CreateDataAccountArgs & {
  type: TransactionType.CreateDataAccount | "createDataAccount";
};
export class CreateDataAccount {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.CreateDataAccount;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(3).repeatable.url
  public authorities?: URL[];

  constructor(args: CreateDataAccountArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.authorities =
      args.authorities == undefined
        ? undefined
        : args.authorities.map((v) => (v instanceof URL ? v : new URL(v)));
  }

  copy() {
    return new CreateDataAccount(this.asObject());
  }

  asObject(): CreateDataAccountArgsWithType {
    return {
      type: "createDataAccount",
      url: this.url && this.url.toString(),
      authorities: this.authorities && this.authorities?.map((v) => v.toString()),
    };
  }
}

export type CreateIdentityArgs = {
  url?: URL | string;
  keyHash?: Uint8Array | string;
  keyBookUrl?: URL | string;
  authorities?: (URL | string)[];
};
export type CreateIdentityArgsWithType = CreateIdentityArgs & {
  type: TransactionType.CreateIdentity | "createIdentity";
};
export class CreateIdentity {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.CreateIdentity;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(3).bytes
  public keyHash?: Uint8Array;
  @encodeAs.field(4).url
  public keyBookUrl?: URL;
  @encodeAs.field(6).repeatable.url
  public authorities?: URL[];

  constructor(args: CreateIdentityArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.keyHash =
      args.keyHash == undefined
        ? undefined
        : args.keyHash instanceof Uint8Array
        ? args.keyHash
        : Buffer.from(args.keyHash, "hex");
    this.keyBookUrl =
      args.keyBookUrl == undefined
        ? undefined
        : args.keyBookUrl instanceof URL
        ? args.keyBookUrl
        : new URL(args.keyBookUrl);
    this.authorities =
      args.authorities == undefined
        ? undefined
        : args.authorities.map((v) => (v instanceof URL ? v : new URL(v)));
  }

  copy() {
    return new CreateIdentity(this.asObject());
  }

  asObject(): CreateIdentityArgsWithType {
    return {
      type: "createIdentity",
      url: this.url && this.url.toString(),
      keyHash: this.keyHash && Buffer.from(this.keyHash).toString("hex"),
      keyBookUrl: this.keyBookUrl && this.keyBookUrl.toString(),
      authorities: this.authorities && this.authorities?.map((v) => v.toString()),
    };
  }
}

export type CreateKeyBookArgs = {
  url?: URL | string;
  publicKeyHash?: Uint8Array | string;
  authorities?: (URL | string)[];
};
export type CreateKeyBookArgsWithType = CreateKeyBookArgs & {
  type: TransactionType.CreateKeyBook | "createKeyBook";
};
export class CreateKeyBook {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.CreateKeyBook;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(3).bytes
  public publicKeyHash?: Uint8Array;
  @encodeAs.field(5).repeatable.url
  public authorities?: URL[];

  constructor(args: CreateKeyBookArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.publicKeyHash =
      args.publicKeyHash == undefined
        ? undefined
        : args.publicKeyHash instanceof Uint8Array
        ? args.publicKeyHash
        : Buffer.from(args.publicKeyHash, "hex");
    this.authorities =
      args.authorities == undefined
        ? undefined
        : args.authorities.map((v) => (v instanceof URL ? v : new URL(v)));
  }

  copy() {
    return new CreateKeyBook(this.asObject());
  }

  asObject(): CreateKeyBookArgsWithType {
    return {
      type: "createKeyBook",
      url: this.url && this.url.toString(),
      publicKeyHash: this.publicKeyHash && Buffer.from(this.publicKeyHash).toString("hex"),
      authorities: this.authorities && this.authorities?.map((v) => v.toString()),
    };
  }
}

export type CreateKeyPageArgs = {
  keys?: (KeySpecParams | KeySpecParamsArgs)[];
};
export type CreateKeyPageArgsWithType = CreateKeyPageArgs & {
  type: TransactionType.CreateKeyPage | "createKeyPage";
};
export class CreateKeyPage {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.CreateKeyPage;
  @encodeAs.field(2).repeatable.reference
  public keys?: KeySpecParams[];

  constructor(args: CreateKeyPageArgs) {
    this.keys =
      args.keys == undefined
        ? undefined
        : args.keys.map((v) => (v instanceof KeySpecParams ? v : new KeySpecParams(v)));
  }

  copy() {
    return new CreateKeyPage(this.asObject());
  }

  asObject(): CreateKeyPageArgsWithType {
    return {
      type: "createKeyPage",
      keys: this.keys && this.keys?.map((v) => v.asObject()),
    };
  }
}

export type CreateLiteTokenAccountArgs = {};
export type CreateLiteTokenAccountArgsWithType = {
  type: TransactionType.CreateLiteTokenAccount | "createLiteTokenAccount";
};
export class CreateLiteTokenAccount {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.CreateLiteTokenAccount;

  constructor(_: CreateLiteTokenAccountArgs) {}

  copy() {
    return new CreateLiteTokenAccount(this.asObject());
  }

  asObject(): CreateLiteTokenAccountArgsWithType {
    return {
      type: "createLiteTokenAccount",
    };
  }
}

export type CreateTokenArgs = {
  url?: URL | string;
  symbol?: string;
  precision?: number;
  properties?: URL | string;
  supplyLimit?: BN | string | number;
  authorities?: (URL | string)[];
};
export type CreateTokenArgsWithType = CreateTokenArgs & {
  type: TransactionType.CreateToken | "createToken";
};
export class CreateToken {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.CreateToken;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(4).string
  public symbol?: string;
  @encodeAs.field(5).uint
  public precision?: number;
  @encodeAs.field(6).url
  public properties?: URL;
  @encodeAs.field(7).bigInt
  public supplyLimit?: BN;
  @encodeAs.field(9).repeatable.url
  public authorities?: URL[];

  constructor(args: CreateTokenArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.symbol = args.symbol == undefined ? undefined : args.symbol;
    this.precision = args.precision == undefined ? undefined : args.precision;
    this.properties =
      args.properties == undefined
        ? undefined
        : args.properties instanceof URL
        ? args.properties
        : new URL(args.properties);
    this.supplyLimit =
      args.supplyLimit == undefined
        ? undefined
        : args.supplyLimit instanceof BN
        ? args.supplyLimit
        : new BN(args.supplyLimit);
    this.authorities =
      args.authorities == undefined
        ? undefined
        : args.authorities.map((v) => (v instanceof URL ? v : new URL(v)));
  }

  copy() {
    return new CreateToken(this.asObject());
  }

  asObject(): CreateTokenArgsWithType {
    return {
      type: "createToken",
      url: this.url && this.url.toString(),
      symbol: this.symbol && this.symbol,
      precision: this.precision && this.precision,
      properties: this.properties && this.properties.toString(),
      supplyLimit: this.supplyLimit && this.supplyLimit.toString(),
      authorities: this.authorities && this.authorities?.map((v) => v.toString()),
    };
  }
}

export type CreateTokenAccountArgs = {
  url?: URL | string;
  tokenUrl?: URL | string;
  authorities?: (URL | string)[];
  proof?: TokenIssuerProof | TokenIssuerProofArgs;
};
export type CreateTokenAccountArgsWithType = CreateTokenAccountArgs & {
  type: TransactionType.CreateTokenAccount | "createTokenAccount";
};
export class CreateTokenAccount {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.CreateTokenAccount;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(3).url
  public tokenUrl?: URL;
  @encodeAs.field(7).repeatable.url
  public authorities?: URL[];
  @encodeAs.field(8).reference
  public proof?: TokenIssuerProof;

  constructor(args: CreateTokenAccountArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.tokenUrl =
      args.tokenUrl == undefined
        ? undefined
        : args.tokenUrl instanceof URL
        ? args.tokenUrl
        : new URL(args.tokenUrl);
    this.authorities =
      args.authorities == undefined
        ? undefined
        : args.authorities.map((v) => (v instanceof URL ? v : new URL(v)));
    this.proof =
      args.proof == undefined
        ? undefined
        : args.proof instanceof TokenIssuerProof
        ? args.proof
        : new TokenIssuerProof(args.proof);
  }

  copy() {
    return new CreateTokenAccount(this.asObject());
  }

  asObject(): CreateTokenAccountArgsWithType {
    return {
      type: "createTokenAccount",
      url: this.url && this.url.toString(),
      tokenUrl: this.tokenUrl && this.tokenUrl.toString(),
      authorities: this.authorities && this.authorities?.map((v) => v.toString()),
      proof: this.proof && this.proof.asObject(),
    };
  }
}

export type CreditRecipientArgs = {
  url?: URL | string;
  amount?: number;
};
export class CreditRecipient {
  @encodeAs.field(1).url
  public url?: URL;
  @encodeAs.field(2).uint
  public amount?: number;

  constructor(args: CreditRecipientArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.amount = args.amount == undefined ? undefined : args.amount;
  }

  copy() {
    return new CreditRecipient(this.asObject());
  }

  asObject(): CreditRecipientArgs {
    return {
      url: this.url && this.url.toString(),
      amount: this.amount && this.amount,
    };
  }
}

export type DataAccountArgs = {
  url?: URL | string;
  authorities?: (AuthorityEntry | AuthorityEntryArgs)[];
  entry?: DataEntry | DataEntryArgs;
};
export type DataAccountArgsWithType = DataAccountArgs & {
  type: AccountType.DataAccount | "dataAccount";
};
export class DataAccount {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountType.DataAccount;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(3, 1).repeatable.reference
  public authorities?: AuthorityEntry[];
  @encodeAs.field(4).union
  public entry?: DataEntry;

  constructor(args: DataAccountArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.authorities =
      args.authorities == undefined
        ? undefined
        : args.authorities.map((v) => (v instanceof AuthorityEntry ? v : new AuthorityEntry(v)));
    this.entry = args.entry == undefined ? undefined : DataEntry.fromObject(args.entry);
  }

  copy() {
    return new DataAccount(this.asObject());
  }

  asObject(): DataAccountArgsWithType {
    return {
      type: "dataAccount",
      url: this.url && this.url.toString(),
      authorities: this.authorities && this.authorities?.map((v) => v.asObject()),
      entry: this.entry && this.entry.asObject(),
    };
  }
}

export type DelegatedSignatureArgs = {
  signature?: Signature | SignatureArgs;
  delegator?: URL | string;
};
export type DelegatedSignatureArgsWithType = DelegatedSignatureArgs & {
  type: SignatureType.Delegated | "delegated";
};
export class DelegatedSignature {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = SignatureType.Delegated;
  @encodeAs.field(2).union
  public signature?: Signature;
  @encodeAs.field(3).url
  public delegator?: URL;

  constructor(args: DelegatedSignatureArgs) {
    this.signature = args.signature == undefined ? undefined : Signature.fromObject(args.signature);
    this.delegator =
      args.delegator == undefined
        ? undefined
        : args.delegator instanceof URL
        ? args.delegator
        : new URL(args.delegator);
  }

  copy() {
    return new DelegatedSignature(this.asObject());
  }

  asObject(): DelegatedSignatureArgsWithType {
    return {
      type: "delegated",
      signature: this.signature && this.signature.asObject(),
      delegator: this.delegator && this.delegator.toString(),
    };
  }
}

export type DirectoryAnchorArgs = {
  source?: URL | string;
  majorBlockIndex?: number;
  minorBlockIndex?: number;
  rootChainIndex?: number;
  rootChainAnchor?: Uint8Array | string;
  stateTreeAnchor?: Uint8Array | string;
  updates?: (NetworkAccountUpdate | NetworkAccountUpdateArgs)[];
  receipts?: (PartitionAnchorReceipt | PartitionAnchorReceiptArgs)[];
  makeMajorBlock?: number;
  makeMajorBlockTime?: Date | string;
};
export type DirectoryAnchorArgsWithType = DirectoryAnchorArgs & {
  type: TransactionType.DirectoryAnchor | "directoryAnchor";
};
export class DirectoryAnchor {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.DirectoryAnchor;
  @encodeAs.field(2, 1).url
  public source?: URL;
  @encodeAs.field(2, 2).uint
  public majorBlockIndex?: number;
  @encodeAs.field(2, 3).uint
  public minorBlockIndex?: number;
  @encodeAs.field(2, 4).uint
  public rootChainIndex?: number;
  @encodeAs.field(2, 5).hash
  public rootChainAnchor?: Uint8Array;
  @encodeAs.field(2, 6).hash
  public stateTreeAnchor?: Uint8Array;
  @encodeAs.field(3).repeatable.reference
  public updates?: NetworkAccountUpdate[];
  @encodeAs.field(4).repeatable.reference
  public receipts?: PartitionAnchorReceipt[];
  @encodeAs.field(5).uint
  public makeMajorBlock?: number;
  @encodeAs.field(6).time
  public makeMajorBlockTime?: Date;

  constructor(args: DirectoryAnchorArgs) {
    this.source =
      args.source == undefined
        ? undefined
        : args.source instanceof URL
        ? args.source
        : new URL(args.source);
    this.majorBlockIndex = args.majorBlockIndex == undefined ? undefined : args.majorBlockIndex;
    this.minorBlockIndex = args.minorBlockIndex == undefined ? undefined : args.minorBlockIndex;
    this.rootChainIndex = args.rootChainIndex == undefined ? undefined : args.rootChainIndex;
    this.rootChainAnchor =
      args.rootChainAnchor == undefined
        ? undefined
        : args.rootChainAnchor instanceof Uint8Array
        ? args.rootChainAnchor
        : Buffer.from(args.rootChainAnchor, "hex");
    this.stateTreeAnchor =
      args.stateTreeAnchor == undefined
        ? undefined
        : args.stateTreeAnchor instanceof Uint8Array
        ? args.stateTreeAnchor
        : Buffer.from(args.stateTreeAnchor, "hex");
    this.updates =
      args.updates == undefined
        ? undefined
        : args.updates.map((v) =>
            v instanceof NetworkAccountUpdate ? v : new NetworkAccountUpdate(v)
          );
    this.receipts =
      args.receipts == undefined
        ? undefined
        : args.receipts.map((v) =>
            v instanceof PartitionAnchorReceipt ? v : new PartitionAnchorReceipt(v)
          );
    this.makeMajorBlock = args.makeMajorBlock == undefined ? undefined : args.makeMajorBlock;
    this.makeMajorBlockTime =
      args.makeMajorBlockTime == undefined
        ? undefined
        : args.makeMajorBlockTime instanceof Date
        ? args.makeMajorBlockTime
        : new Date(args.makeMajorBlockTime);
  }

  copy() {
    return new DirectoryAnchor(this.asObject());
  }

  asObject(): DirectoryAnchorArgsWithType {
    return {
      type: "directoryAnchor",
      source: this.source && this.source.toString(),
      majorBlockIndex: this.majorBlockIndex && this.majorBlockIndex,
      minorBlockIndex: this.minorBlockIndex && this.minorBlockIndex,
      rootChainIndex: this.rootChainIndex && this.rootChainIndex,
      rootChainAnchor: this.rootChainAnchor && Buffer.from(this.rootChainAnchor).toString("hex"),
      stateTreeAnchor: this.stateTreeAnchor && Buffer.from(this.stateTreeAnchor).toString("hex"),
      updates: this.updates && this.updates?.map((v) => v.asObject()),
      receipts: this.receipts && this.receipts?.map((v) => v.asObject()),
      makeMajorBlock: this.makeMajorBlock && this.makeMajorBlock,
      makeMajorBlockTime: this.makeMajorBlockTime && this.makeMajorBlockTime,
    };
  }
}

export type DisableAccountAuthOperationArgs = {
  authority?: URL | string;
};
export type DisableAccountAuthOperationArgsWithType = DisableAccountAuthOperationArgs & {
  type: AccountAuthOperationType.Disable | "disable";
};
export class DisableAccountAuthOperation {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountAuthOperationType.Disable;
  @encodeAs.field(2).url
  public authority?: URL;

  constructor(args: DisableAccountAuthOperationArgs) {
    this.authority =
      args.authority == undefined
        ? undefined
        : args.authority instanceof URL
        ? args.authority
        : new URL(args.authority);
  }

  copy() {
    return new DisableAccountAuthOperation(this.asObject());
  }

  asObject(): DisableAccountAuthOperationArgsWithType {
    return {
      type: "disable",
      authority: this.authority && this.authority.toString(),
    };
  }
}

export type DoubleHashDataEntryArgs = {
  data?: (Uint8Array | string)[];
};
export type DoubleHashDataEntryArgsWithType = DoubleHashDataEntryArgs & {
  type: DataEntryType.DoubleHash | "doubleHash";
};
export class DoubleHashDataEntry {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = DataEntryType.DoubleHash;
  @encodeAs.field(2).repeatable.bytes
  public data?: Uint8Array[];

  constructor(args: DoubleHashDataEntryArgs) {
    this.data =
      args.data == undefined
        ? undefined
        : args.data.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
  }

  copy() {
    return new DoubleHashDataEntry(this.asObject());
  }

  asObject(): DoubleHashDataEntryArgsWithType {
    return {
      type: "doubleHash",
      data: this.data && this.data?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export type ED25519SignatureArgs = {
  publicKey?: Uint8Array | string;
  signature?: Uint8Array | string;
  signer?: URL | string;
  signerVersion?: number;
  timestamp?: number;
  vote?: VoteTypeArgs;
  transactionHash?: Uint8Array | string;
};
export type ED25519SignatureArgsWithType = ED25519SignatureArgs & {
  type: SignatureType.ED25519 | "ed25519";
};
export class ED25519Signature {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = SignatureType.ED25519;
  @encodeAs.field(2).bytes
  public publicKey?: Uint8Array;
  @encodeAs.field(3).bytes
  public signature?: Uint8Array;
  @encodeAs.field(4).url
  public signer?: URL;
  @encodeAs.field(5).uint
  public signerVersion?: number;
  @encodeAs.field(6).uint
  public timestamp?: number;
  @encodeAs.field(7).enum
  public vote?: VoteType;
  @encodeAs.field(8).hash
  public transactionHash?: Uint8Array;

  constructor(args: ED25519SignatureArgs) {
    this.publicKey =
      args.publicKey == undefined
        ? undefined
        : args.publicKey instanceof Uint8Array
        ? args.publicKey
        : Buffer.from(args.publicKey, "hex");
    this.signature =
      args.signature == undefined
        ? undefined
        : args.signature instanceof Uint8Array
        ? args.signature
        : Buffer.from(args.signature, "hex");
    this.signer =
      args.signer == undefined
        ? undefined
        : args.signer instanceof URL
        ? args.signer
        : new URL(args.signer);
    this.signerVersion = args.signerVersion == undefined ? undefined : args.signerVersion;
    this.timestamp = args.timestamp == undefined ? undefined : args.timestamp;
    this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
    this.transactionHash =
      args.transactionHash == undefined
        ? undefined
        : args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  copy() {
    return new ED25519Signature(this.asObject());
  }

  asObject(): ED25519SignatureArgsWithType {
    return {
      type: "ed25519",
      publicKey: this.publicKey && Buffer.from(this.publicKey).toString("hex"),
      signature: this.signature && Buffer.from(this.signature).toString("hex"),
      signer: this.signer && this.signer.toString(),
      signerVersion: this.signerVersion && this.signerVersion,
      timestamp: this.timestamp && this.timestamp,
      vote: this.vote && VoteType.getName(this.vote),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export type ETHSignatureArgs = {
  publicKey?: Uint8Array | string;
  signature?: Uint8Array | string;
  signer?: URL | string;
  signerVersion?: number;
  timestamp?: number;
  vote?: VoteTypeArgs;
  transactionHash?: Uint8Array | string;
};
export type ETHSignatureArgsWithType = ETHSignatureArgs & { type: SignatureType.ETH | "eth" };
export class ETHSignature {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = SignatureType.ETH;
  @encodeAs.field(2).bytes
  public publicKey?: Uint8Array;
  @encodeAs.field(3).bytes
  public signature?: Uint8Array;
  @encodeAs.field(4).url
  public signer?: URL;
  @encodeAs.field(5).uint
  public signerVersion?: number;
  @encodeAs.field(6).uint
  public timestamp?: number;
  @encodeAs.field(7).enum
  public vote?: VoteType;
  @encodeAs.field(8).hash
  public transactionHash?: Uint8Array;

  constructor(args: ETHSignatureArgs) {
    this.publicKey =
      args.publicKey == undefined
        ? undefined
        : args.publicKey instanceof Uint8Array
        ? args.publicKey
        : Buffer.from(args.publicKey, "hex");
    this.signature =
      args.signature == undefined
        ? undefined
        : args.signature instanceof Uint8Array
        ? args.signature
        : Buffer.from(args.signature, "hex");
    this.signer =
      args.signer == undefined
        ? undefined
        : args.signer instanceof URL
        ? args.signer
        : new URL(args.signer);
    this.signerVersion = args.signerVersion == undefined ? undefined : args.signerVersion;
    this.timestamp = args.timestamp == undefined ? undefined : args.timestamp;
    this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
    this.transactionHash =
      args.transactionHash == undefined
        ? undefined
        : args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  copy() {
    return new ETHSignature(this.asObject());
  }

  asObject(): ETHSignatureArgsWithType {
    return {
      type: "eth",
      publicKey: this.publicKey && Buffer.from(this.publicKey).toString("hex"),
      signature: this.signature && Buffer.from(this.signature).toString("hex"),
      signer: this.signer && this.signer.toString(),
      signerVersion: this.signerVersion && this.signerVersion,
      timestamp: this.timestamp && this.timestamp,
      vote: this.vote && VoteType.getName(this.vote),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export type EmptyResultArgs = {};
export type EmptyResultArgsWithType = { type: TransactionType.Unknown | "unknown" };
export class EmptyResult {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.Unknown;

  constructor(_: EmptyResultArgs) {}

  copy() {
    return new EmptyResult(this.asObject());
  }

  asObject(): EmptyResultArgsWithType {
    return {
      type: "unknown",
    };
  }
}

export type EnableAccountAuthOperationArgs = {
  authority?: URL | string;
};
export type EnableAccountAuthOperationArgsWithType = EnableAccountAuthOperationArgs & {
  type: AccountAuthOperationType.Enable | "enable";
};
export class EnableAccountAuthOperation {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountAuthOperationType.Enable;
  @encodeAs.field(2).url
  public authority?: URL;

  constructor(args: EnableAccountAuthOperationArgs) {
    this.authority =
      args.authority == undefined
        ? undefined
        : args.authority instanceof URL
        ? args.authority
        : new URL(args.authority);
  }

  copy() {
    return new EnableAccountAuthOperation(this.asObject());
  }

  asObject(): EnableAccountAuthOperationArgsWithType {
    return {
      type: "enable",
      authority: this.authority && this.authority.toString(),
    };
  }
}

export type FactomDataEntryArgs = {
  accountId?: Uint8Array | string;
  data?: Uint8Array | string;
  extIds?: (Uint8Array | string)[];
};
export class FactomDataEntry {
  public accountId?: Uint8Array;
  public data?: Uint8Array;
  public extIds?: Uint8Array[];

  constructor(args: FactomDataEntryArgs) {
    this.accountId =
      args.accountId == undefined
        ? undefined
        : args.accountId instanceof Uint8Array
        ? args.accountId
        : Buffer.from(args.accountId, "hex");
    this.data =
      args.data == undefined
        ? undefined
        : args.data instanceof Uint8Array
        ? args.data
        : Buffer.from(args.data, "hex");
    this.extIds =
      args.extIds == undefined
        ? undefined
        : args.extIds.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
  }

  copy() {
    return new FactomDataEntry(this.asObject());
  }

  asObject(): FactomDataEntryArgs {
    return {
      accountId: this.accountId && Buffer.from(this.accountId).toString("hex"),
      data: this.data && Buffer.from(this.data).toString("hex"),
      extIds: this.extIds && this.extIds?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export type FactomDataEntryWrapperArgs = {
  accountId?: Uint8Array | string;
  data?: Uint8Array | string;
  extIds?: (Uint8Array | string)[];
};
export type FactomDataEntryWrapperArgsWithType = FactomDataEntryWrapperArgs & {
  type: DataEntryType.Factom | "factom";
};
export class FactomDataEntryWrapper {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = DataEntryType.Factom;
  @encodeAs.field(2, 1).hash
  public accountId?: Uint8Array;
  @encodeAs.field(2, 2).bytes
  public data?: Uint8Array;
  @encodeAs.field(2, 3).repeatable.bytes
  public extIds?: Uint8Array[];

  constructor(args: FactomDataEntryWrapperArgs) {
    this.accountId =
      args.accountId == undefined
        ? undefined
        : args.accountId instanceof Uint8Array
        ? args.accountId
        : Buffer.from(args.accountId, "hex");
    this.data =
      args.data == undefined
        ? undefined
        : args.data instanceof Uint8Array
        ? args.data
        : Buffer.from(args.data, "hex");
    this.extIds =
      args.extIds == undefined
        ? undefined
        : args.extIds.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
  }

  copy() {
    return new FactomDataEntryWrapper(this.asObject());
  }

  asObject(): FactomDataEntryWrapperArgsWithType {
    return {
      type: "factom",
      accountId: this.accountId && Buffer.from(this.accountId).toString("hex"),
      data: this.data && Buffer.from(this.data).toString("hex"),
      extIds: this.extIds && this.extIds?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export type FeeScheduleArgs = {
  createIdentitySliding?: FeeArgs[];
};
export class FeeSchedule {
  @encodeAs.field(1).repeatable.enum
  public createIdentitySliding?: Fee[];

  constructor(args: FeeScheduleArgs) {
    this.createIdentitySliding =
      args.createIdentitySliding == undefined
        ? undefined
        : args.createIdentitySliding.map((v) => Fee.fromObject(v));
  }

  copy() {
    return new FeeSchedule(this.asObject());
  }

  asObject(): FeeScheduleArgs {
    return {
      createIdentitySliding:
        this.createIdentitySliding && this.createIdentitySliding?.map((v) => Fee.getName(v)),
    };
  }
}

export type IndexEntryArgs = {
  source?: number;
  anchor?: number;
  blockIndex?: number;
  blockTime?: Date | string;
  rootIndexIndex?: number;
};
export class IndexEntry {
  @encodeAs.field(1).uint
  public source?: number;
  @encodeAs.field(2).uint
  public anchor?: number;
  @encodeAs.field(3).uint
  public blockIndex?: number;
  @encodeAs.field(4).time
  public blockTime?: Date;
  @encodeAs.field(5).uint
  public rootIndexIndex?: number;

  constructor(args: IndexEntryArgs) {
    this.source = args.source == undefined ? undefined : args.source;
    this.anchor = args.anchor == undefined ? undefined : args.anchor;
    this.blockIndex = args.blockIndex == undefined ? undefined : args.blockIndex;
    this.blockTime =
      args.blockTime == undefined
        ? undefined
        : args.blockTime instanceof Date
        ? args.blockTime
        : new Date(args.blockTime);
    this.rootIndexIndex = args.rootIndexIndex == undefined ? undefined : args.rootIndexIndex;
  }

  copy() {
    return new IndexEntry(this.asObject());
  }

  asObject(): IndexEntryArgs {
    return {
      source: this.source && this.source,
      anchor: this.anchor && this.anchor,
      blockIndex: this.blockIndex && this.blockIndex,
      blockTime: this.blockTime && this.blockTime,
      rootIndexIndex: this.rootIndexIndex && this.rootIndexIndex,
    };
  }
}

export type InternalSignatureArgs = {
  cause?: Uint8Array | string;
  transactionHash?: Uint8Array | string;
};
export type InternalSignatureArgsWithType = InternalSignatureArgs & {
  type: SignatureType.Internal | "internal";
};
export class InternalSignature {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = SignatureType.Internal;
  @encodeAs.field(2).hash
  public cause?: Uint8Array;
  @encodeAs.field(3).hash
  public transactionHash?: Uint8Array;

  constructor(args: InternalSignatureArgs) {
    this.cause =
      args.cause == undefined
        ? undefined
        : args.cause instanceof Uint8Array
        ? args.cause
        : Buffer.from(args.cause, "hex");
    this.transactionHash =
      args.transactionHash == undefined
        ? undefined
        : args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  copy() {
    return new InternalSignature(this.asObject());
  }

  asObject(): InternalSignatureArgsWithType {
    return {
      type: "internal",
      cause: this.cause && Buffer.from(this.cause).toString("hex"),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export type IssueTokensArgs = {
  recipient?: URL | string;
  amount?: BN | string | number;
  to?: (TokenRecipient | TokenRecipientArgs)[];
};
export type IssueTokensArgsWithType = IssueTokensArgs & {
  type: TransactionType.IssueTokens | "issueTokens";
};
export class IssueTokens {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.IssueTokens;
  @encodeAs.field(2).url
  public recipient?: URL;
  @encodeAs.field(3).bigInt
  public amount?: BN;
  @encodeAs.field(4).repeatable.reference
  public to?: TokenRecipient[];

  constructor(args: IssueTokensArgs) {
    this.recipient =
      args.recipient == undefined
        ? undefined
        : args.recipient instanceof URL
        ? args.recipient
        : new URL(args.recipient);
    this.amount =
      args.amount == undefined
        ? undefined
        : args.amount instanceof BN
        ? args.amount
        : new BN(args.amount);
    this.to =
      args.to == undefined
        ? undefined
        : args.to.map((v) => (v instanceof TokenRecipient ? v : new TokenRecipient(v)));
  }

  copy() {
    return new IssueTokens(this.asObject());
  }

  asObject(): IssueTokensArgsWithType {
    return {
      type: "issueTokens",
      recipient: this.recipient && this.recipient.toString(),
      amount: this.amount && this.amount.toString(),
      to: this.to && this.to?.map((v) => v.asObject()),
    };
  }
}

export type KeyBookArgs = {
  url?: URL | string;
  bookType?: BookTypeArgs;
  authorities?: (AuthorityEntry | AuthorityEntryArgs)[];
  pageCount?: number;
};
export type KeyBookArgsWithType = KeyBookArgs & { type: AccountType.KeyBook | "keyBook" };
export class KeyBook {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountType.KeyBook;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(3).enum
  public bookType?: BookType;
  @encodeAs.field(4, 1).repeatable.reference
  public authorities?: AuthorityEntry[];
  @encodeAs.field(5).uint
  public pageCount?: number;

  constructor(args: KeyBookArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.bookType = args.bookType == undefined ? undefined : BookType.fromObject(args.bookType);
    this.authorities =
      args.authorities == undefined
        ? undefined
        : args.authorities.map((v) => (v instanceof AuthorityEntry ? v : new AuthorityEntry(v)));
    this.pageCount = args.pageCount == undefined ? undefined : args.pageCount;
  }

  copy() {
    return new KeyBook(this.asObject());
  }

  asObject(): KeyBookArgsWithType {
    return {
      type: "keyBook",
      url: this.url && this.url.toString(),
      bookType: this.bookType && BookType.getName(this.bookType),
      authorities: this.authorities && this.authorities?.map((v) => v.asObject()),
      pageCount: this.pageCount && this.pageCount,
    };
  }
}

export type KeyPageArgs = {
  url?: URL | string;
  creditBalance?: number;
  acceptThreshold?: number;
  rejectThreshold?: number;
  responseThreshold?: number;
  blockThreshold?: number;
  version?: number;
  keys?: (KeySpec | KeySpecArgs)[];
  transactionBlacklist?: AllowedTransactionsArgs;
};
export type KeyPageArgsWithType = KeyPageArgs & { type: AccountType.KeyPage | "keyPage" };
export class KeyPage {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountType.KeyPage;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(3).uint
  public creditBalance?: number;
  @encodeAs.field(4).uint
  public acceptThreshold?: number;
  @encodeAs.field(5).uint
  public rejectThreshold?: number;
  @encodeAs.field(6).uint
  public responseThreshold?: number;
  @encodeAs.field(7).uint
  public blockThreshold?: number;
  @encodeAs.field(8).uint
  public version?: number;
  @encodeAs.field(9).repeatable.reference
  public keys?: KeySpec[];
  @encodeAs.field(10).enum
  public transactionBlacklist?: AllowedTransactions;

  constructor(args: KeyPageArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.creditBalance = args.creditBalance == undefined ? undefined : args.creditBalance;
    this.acceptThreshold = args.acceptThreshold == undefined ? undefined : args.acceptThreshold;
    this.rejectThreshold = args.rejectThreshold == undefined ? undefined : args.rejectThreshold;
    this.responseThreshold =
      args.responseThreshold == undefined ? undefined : args.responseThreshold;
    this.blockThreshold = args.blockThreshold == undefined ? undefined : args.blockThreshold;
    this.version = args.version == undefined ? undefined : args.version;
    this.keys =
      args.keys == undefined
        ? undefined
        : args.keys.map((v) => (v instanceof KeySpec ? v : new KeySpec(v)));
    this.transactionBlacklist =
      args.transactionBlacklist == undefined
        ? undefined
        : AllowedTransactions.fromObject(args.transactionBlacklist);
  }

  copy() {
    return new KeyPage(this.asObject());
  }

  asObject(): KeyPageArgsWithType {
    return {
      type: "keyPage",
      url: this.url && this.url.toString(),
      creditBalance: this.creditBalance && this.creditBalance,
      acceptThreshold: this.acceptThreshold && this.acceptThreshold,
      rejectThreshold: this.rejectThreshold && this.rejectThreshold,
      responseThreshold: this.responseThreshold && this.responseThreshold,
      blockThreshold: this.blockThreshold && this.blockThreshold,
      version: this.version && this.version,
      keys: this.keys && this.keys?.map((v) => v.asObject()),
      transactionBlacklist:
        this.transactionBlacklist &&
        this.transactionBlacklist.map((v) => TransactionType.getName(v)),
    };
  }
}

export type KeySpecArgs = {
  publicKeyHash?: Uint8Array | string;
  lastUsedOn?: number;
  delegate?: URL | string;
};
export class KeySpec {
  @encodeAs.field(1).bytes
  public publicKeyHash?: Uint8Array;
  @encodeAs.field(2).uint
  public lastUsedOn?: number;
  @encodeAs.field(3).url
  public delegate?: URL;

  constructor(args: KeySpecArgs) {
    this.publicKeyHash =
      args.publicKeyHash == undefined
        ? undefined
        : args.publicKeyHash instanceof Uint8Array
        ? args.publicKeyHash
        : Buffer.from(args.publicKeyHash, "hex");
    this.lastUsedOn = args.lastUsedOn == undefined ? undefined : args.lastUsedOn;
    this.delegate =
      args.delegate == undefined
        ? undefined
        : args.delegate instanceof URL
        ? args.delegate
        : new URL(args.delegate);
  }

  copy() {
    return new KeySpec(this.asObject());
  }

  asObject(): KeySpecArgs {
    return {
      publicKeyHash: this.publicKeyHash && Buffer.from(this.publicKeyHash).toString("hex"),
      lastUsedOn: this.lastUsedOn && this.lastUsedOn,
      delegate: this.delegate && this.delegate.toString(),
    };
  }
}

export type KeySpecParamsArgs = {
  keyHash?: Uint8Array | string;
  delegate?: URL | string;
};
export class KeySpecParams {
  @encodeAs.field(1).bytes
  public keyHash?: Uint8Array;
  @encodeAs.field(2).url
  public delegate?: URL;

  constructor(args: KeySpecParamsArgs) {
    this.keyHash =
      args.keyHash == undefined
        ? undefined
        : args.keyHash instanceof Uint8Array
        ? args.keyHash
        : Buffer.from(args.keyHash, "hex");
    this.delegate =
      args.delegate == undefined
        ? undefined
        : args.delegate instanceof URL
        ? args.delegate
        : new URL(args.delegate);
  }

  copy() {
    return new KeySpecParams(this.asObject());
  }

  asObject(): KeySpecParamsArgs {
    return {
      keyHash: this.keyHash && Buffer.from(this.keyHash).toString("hex"),
      delegate: this.delegate && this.delegate.toString(),
    };
  }
}

export type LegacyED25519SignatureArgs = {
  timestamp?: number;
  publicKey?: Uint8Array | string;
  signature?: Uint8Array | string;
  signer?: URL | string;
  signerVersion?: number;
  vote?: VoteTypeArgs;
  transactionHash?: Uint8Array | string;
};
export type LegacyED25519SignatureArgsWithType = LegacyED25519SignatureArgs & {
  type: SignatureType.LegacyED25519 | "legacyED25519";
};
export class LegacyED25519Signature {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = SignatureType.LegacyED25519;
  @encodeAs.field(2).uint
  public timestamp?: number;
  @encodeAs.field(3).bytes
  public publicKey?: Uint8Array;
  @encodeAs.field(4).bytes
  public signature?: Uint8Array;
  @encodeAs.field(5).url
  public signer?: URL;
  @encodeAs.field(6).uint
  public signerVersion?: number;
  @encodeAs.field(7).enum
  public vote?: VoteType;
  @encodeAs.field(8).hash
  public transactionHash?: Uint8Array;

  constructor(args: LegacyED25519SignatureArgs) {
    this.timestamp = args.timestamp == undefined ? undefined : args.timestamp;
    this.publicKey =
      args.publicKey == undefined
        ? undefined
        : args.publicKey instanceof Uint8Array
        ? args.publicKey
        : Buffer.from(args.publicKey, "hex");
    this.signature =
      args.signature == undefined
        ? undefined
        : args.signature instanceof Uint8Array
        ? args.signature
        : Buffer.from(args.signature, "hex");
    this.signer =
      args.signer == undefined
        ? undefined
        : args.signer instanceof URL
        ? args.signer
        : new URL(args.signer);
    this.signerVersion = args.signerVersion == undefined ? undefined : args.signerVersion;
    this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
    this.transactionHash =
      args.transactionHash == undefined
        ? undefined
        : args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  copy() {
    return new LegacyED25519Signature(this.asObject());
  }

  asObject(): LegacyED25519SignatureArgsWithType {
    return {
      type: "legacyED25519",
      timestamp: this.timestamp && this.timestamp,
      publicKey: this.publicKey && Buffer.from(this.publicKey).toString("hex"),
      signature: this.signature && Buffer.from(this.signature).toString("hex"),
      signer: this.signer && this.signer.toString(),
      signerVersion: this.signerVersion && this.signerVersion,
      vote: this.vote && VoteType.getName(this.vote),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export type LiteDataAccountArgs = {
  url?: URL | string;
};
export type LiteDataAccountArgsWithType = LiteDataAccountArgs & {
  type: AccountType.LiteDataAccount | "liteDataAccount";
};
export class LiteDataAccount {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountType.LiteDataAccount;
  @encodeAs.field(2).url
  public url?: URL;

  constructor(args: LiteDataAccountArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
  }

  copy() {
    return new LiteDataAccount(this.asObject());
  }

  asObject(): LiteDataAccountArgsWithType {
    return {
      type: "liteDataAccount",
      url: this.url && this.url.toString(),
    };
  }
}

export type LiteIdentityArgs = {
  url?: URL | string;
  creditBalance?: number;
  lastUsedOn?: number;
};
export type LiteIdentityArgsWithType = LiteIdentityArgs & {
  type: AccountType.LiteIdentity | "liteIdentity";
};
export class LiteIdentity {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountType.LiteIdentity;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(3).uint
  public creditBalance?: number;
  @encodeAs.field(4).uint
  public lastUsedOn?: number;

  constructor(args: LiteIdentityArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.creditBalance = args.creditBalance == undefined ? undefined : args.creditBalance;
    this.lastUsedOn = args.lastUsedOn == undefined ? undefined : args.lastUsedOn;
  }

  copy() {
    return new LiteIdentity(this.asObject());
  }

  asObject(): LiteIdentityArgsWithType {
    return {
      type: "liteIdentity",
      url: this.url && this.url.toString(),
      creditBalance: this.creditBalance && this.creditBalance,
      lastUsedOn: this.lastUsedOn && this.lastUsedOn,
    };
  }
}

export type LiteTokenAccountArgs = {
  url?: URL | string;
  tokenUrl?: URL | string;
  balance?: BN | string | number;
  lockHeight?: number;
};
export type LiteTokenAccountArgsWithType = LiteTokenAccountArgs & {
  type: AccountType.LiteTokenAccount | "liteTokenAccount";
};
export class LiteTokenAccount {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountType.LiteTokenAccount;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(3).url
  public tokenUrl?: URL;
  @encodeAs.field(4).bigInt
  public balance?: BN;
  @encodeAs.field(5).uint
  public lockHeight?: number;

  constructor(args: LiteTokenAccountArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.tokenUrl =
      args.tokenUrl == undefined
        ? undefined
        : args.tokenUrl instanceof URL
        ? args.tokenUrl
        : new URL(args.tokenUrl);
    this.balance =
      args.balance == undefined
        ? undefined
        : args.balance instanceof BN
        ? args.balance
        : new BN(args.balance);
    this.lockHeight = args.lockHeight == undefined ? undefined : args.lockHeight;
  }

  copy() {
    return new LiteTokenAccount(this.asObject());
  }

  asObject(): LiteTokenAccountArgsWithType {
    return {
      type: "liteTokenAccount",
      url: this.url && this.url.toString(),
      tokenUrl: this.tokenUrl && this.tokenUrl.toString(),
      balance: this.balance && this.balance.toString(),
      lockHeight: this.lockHeight && this.lockHeight,
    };
  }
}

export type LockAccountArgs = {
  height?: number;
};
export type LockAccountArgsWithType = LockAccountArgs & {
  type: TransactionType.LockAccount | "lockAccount";
};
export class LockAccount {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.LockAccount;
  @encodeAs.field(2).uint
  public height?: number;

  constructor(args: LockAccountArgs) {
    this.height = args.height == undefined ? undefined : args.height;
  }

  copy() {
    return new LockAccount(this.asObject());
  }

  asObject(): LockAccountArgsWithType {
    return {
      type: "lockAccount",
      height: this.height && this.height,
    };
  }
}

export type NetworkAccountUpdateArgs = {
  name?: string;
  body?: TransactionBody | TransactionBodyArgs;
};
export class NetworkAccountUpdate {
  @encodeAs.field(1).string
  public name?: string;
  @encodeAs.field(2).union
  public body?: TransactionBody;

  constructor(args: NetworkAccountUpdateArgs) {
    this.name = args.name == undefined ? undefined : args.name;
    this.body = args.body == undefined ? undefined : TransactionBody.fromObject(args.body);
  }

  copy() {
    return new NetworkAccountUpdate(this.asObject());
  }

  asObject(): NetworkAccountUpdateArgs {
    return {
      name: this.name && this.name,
      body: this.body && this.body.asObject(),
    };
  }
}

export type NetworkDefinitionArgs = {
  networkName?: string;
  version?: number;
  partitions?: (PartitionInfo | PartitionInfoArgs)[];
  validators?: (ValidatorInfo | ValidatorInfoArgs)[];
};
export class NetworkDefinition {
  @encodeAs.field(1).string
  public networkName?: string;
  @encodeAs.field(2).uint
  public version?: number;
  @encodeAs.field(3).repeatable.reference
  public partitions?: PartitionInfo[];
  @encodeAs.field(4).repeatable.reference
  public validators?: ValidatorInfo[];

  constructor(args: NetworkDefinitionArgs) {
    this.networkName = args.networkName == undefined ? undefined : args.networkName;
    this.version = args.version == undefined ? undefined : args.version;
    this.partitions =
      args.partitions == undefined
        ? undefined
        : args.partitions.map((v) => (v instanceof PartitionInfo ? v : new PartitionInfo(v)));
    this.validators =
      args.validators == undefined
        ? undefined
        : args.validators.map((v) => (v instanceof ValidatorInfo ? v : new ValidatorInfo(v)));
  }

  copy() {
    return new NetworkDefinition(this.asObject());
  }

  asObject(): NetworkDefinitionArgs {
    return {
      networkName: this.networkName && this.networkName,
      version: this.version && this.version,
      partitions: this.partitions && this.partitions?.map((v) => v.asObject()),
      validators: this.validators && this.validators?.map((v) => v.asObject()),
    };
  }
}

export type NetworkGlobalsArgs = {
  operatorAcceptThreshold?: Rational | RationalArgs;
  validatorAcceptThreshold?: Rational | RationalArgs;
  majorBlockSchedule?: string;
  anchorEmptyBlocks?: boolean;
  feeSchedule?: FeeSchedule | FeeScheduleArgs;
  limits?: NetworkLimits | NetworkLimitsArgs;
};
export class NetworkGlobals {
  @encodeAs.field(1).reference
  public operatorAcceptThreshold?: Rational;
  @encodeAs.field(2).reference
  public validatorAcceptThreshold?: Rational;
  @encodeAs.field(3).string
  public majorBlockSchedule?: string;
  @encodeAs.field(4).bool
  public anchorEmptyBlocks?: boolean;
  @encodeAs.field(5).reference
  public feeSchedule?: FeeSchedule;
  @encodeAs.field(6).reference
  public limits?: NetworkLimits;

  constructor(args: NetworkGlobalsArgs) {
    this.operatorAcceptThreshold =
      args.operatorAcceptThreshold == undefined
        ? undefined
        : args.operatorAcceptThreshold instanceof Rational
        ? args.operatorAcceptThreshold
        : new Rational(args.operatorAcceptThreshold);
    this.validatorAcceptThreshold =
      args.validatorAcceptThreshold == undefined
        ? undefined
        : args.validatorAcceptThreshold instanceof Rational
        ? args.validatorAcceptThreshold
        : new Rational(args.validatorAcceptThreshold);
    this.majorBlockSchedule =
      args.majorBlockSchedule == undefined ? undefined : args.majorBlockSchedule;
    this.anchorEmptyBlocks =
      args.anchorEmptyBlocks == undefined ? undefined : args.anchorEmptyBlocks;
    this.feeSchedule =
      args.feeSchedule == undefined
        ? undefined
        : args.feeSchedule instanceof FeeSchedule
        ? args.feeSchedule
        : new FeeSchedule(args.feeSchedule);
    this.limits =
      args.limits == undefined
        ? undefined
        : args.limits instanceof NetworkLimits
        ? args.limits
        : new NetworkLimits(args.limits);
  }

  copy() {
    return new NetworkGlobals(this.asObject());
  }

  asObject(): NetworkGlobalsArgs {
    return {
      operatorAcceptThreshold:
        this.operatorAcceptThreshold && this.operatorAcceptThreshold.asObject(),
      validatorAcceptThreshold:
        this.validatorAcceptThreshold && this.validatorAcceptThreshold.asObject(),
      majorBlockSchedule: this.majorBlockSchedule && this.majorBlockSchedule,
      anchorEmptyBlocks: this.anchorEmptyBlocks && this.anchorEmptyBlocks,
      feeSchedule: this.feeSchedule && this.feeSchedule.asObject(),
      limits: this.limits && this.limits.asObject(),
    };
  }
}

export type NetworkLimitsArgs = {
  dataEntryParts?: number;
  accountAuthorities?: number;
  bookPages?: number;
  pageEntries?: number;
  identityAccounts?: number;
};
export class NetworkLimits {
  @encodeAs.field(1).uint
  public dataEntryParts?: number;
  @encodeAs.field(2).uint
  public accountAuthorities?: number;
  @encodeAs.field(3).uint
  public bookPages?: number;
  @encodeAs.field(4).uint
  public pageEntries?: number;
  @encodeAs.field(5).uint
  public identityAccounts?: number;

  constructor(args: NetworkLimitsArgs) {
    this.dataEntryParts = args.dataEntryParts == undefined ? undefined : args.dataEntryParts;
    this.accountAuthorities =
      args.accountAuthorities == undefined ? undefined : args.accountAuthorities;
    this.bookPages = args.bookPages == undefined ? undefined : args.bookPages;
    this.pageEntries = args.pageEntries == undefined ? undefined : args.pageEntries;
    this.identityAccounts = args.identityAccounts == undefined ? undefined : args.identityAccounts;
  }

  copy() {
    return new NetworkLimits(this.asObject());
  }

  asObject(): NetworkLimitsArgs {
    return {
      dataEntryParts: this.dataEntryParts && this.dataEntryParts,
      accountAuthorities: this.accountAuthorities && this.accountAuthorities,
      bookPages: this.bookPages && this.bookPages,
      pageEntries: this.pageEntries && this.pageEntries,
      identityAccounts: this.identityAccounts && this.identityAccounts,
    };
  }
}

export type PartitionAnchorArgs = {
  source?: URL | string;
  majorBlockIndex?: number;
  minorBlockIndex?: number;
  rootChainIndex?: number;
  rootChainAnchor?: Uint8Array | string;
  stateTreeAnchor?: Uint8Array | string;
};
export class PartitionAnchor {
  @encodeAs.field(1).url
  public source?: URL;
  @encodeAs.field(2).uint
  public majorBlockIndex?: number;
  @encodeAs.field(3).uint
  public minorBlockIndex?: number;
  @encodeAs.field(4).uint
  public rootChainIndex?: number;
  @encodeAs.field(5).hash
  public rootChainAnchor?: Uint8Array;
  @encodeAs.field(6).hash
  public stateTreeAnchor?: Uint8Array;

  constructor(args: PartitionAnchorArgs) {
    this.source =
      args.source == undefined
        ? undefined
        : args.source instanceof URL
        ? args.source
        : new URL(args.source);
    this.majorBlockIndex = args.majorBlockIndex == undefined ? undefined : args.majorBlockIndex;
    this.minorBlockIndex = args.minorBlockIndex == undefined ? undefined : args.minorBlockIndex;
    this.rootChainIndex = args.rootChainIndex == undefined ? undefined : args.rootChainIndex;
    this.rootChainAnchor =
      args.rootChainAnchor == undefined
        ? undefined
        : args.rootChainAnchor instanceof Uint8Array
        ? args.rootChainAnchor
        : Buffer.from(args.rootChainAnchor, "hex");
    this.stateTreeAnchor =
      args.stateTreeAnchor == undefined
        ? undefined
        : args.stateTreeAnchor instanceof Uint8Array
        ? args.stateTreeAnchor
        : Buffer.from(args.stateTreeAnchor, "hex");
  }

  copy() {
    return new PartitionAnchor(this.asObject());
  }

  asObject(): PartitionAnchorArgs {
    return {
      source: this.source && this.source.toString(),
      majorBlockIndex: this.majorBlockIndex && this.majorBlockIndex,
      minorBlockIndex: this.minorBlockIndex && this.minorBlockIndex,
      rootChainIndex: this.rootChainIndex && this.rootChainIndex,
      rootChainAnchor: this.rootChainAnchor && Buffer.from(this.rootChainAnchor).toString("hex"),
      stateTreeAnchor: this.stateTreeAnchor && Buffer.from(this.stateTreeAnchor).toString("hex"),
    };
  }
}

export type PartitionAnchorReceiptArgs = {
  anchor?: PartitionAnchor | PartitionAnchorArgs;
  rootChainReceipt?: merkle.Receipt | merkle.ReceiptArgs;
};
export class PartitionAnchorReceipt {
  @encodeAs.field(1).reference
  public anchor?: PartitionAnchor;
  @encodeAs.field(2).reference
  public rootChainReceipt?: merkle.Receipt;

  constructor(args: PartitionAnchorReceiptArgs) {
    this.anchor =
      args.anchor == undefined
        ? undefined
        : args.anchor instanceof PartitionAnchor
        ? args.anchor
        : new PartitionAnchor(args.anchor);
    this.rootChainReceipt =
      args.rootChainReceipt == undefined
        ? undefined
        : args.rootChainReceipt instanceof merkle.Receipt
        ? args.rootChainReceipt
        : new merkle.Receipt(args.rootChainReceipt);
  }

  copy() {
    return new PartitionAnchorReceipt(this.asObject());
  }

  asObject(): PartitionAnchorReceiptArgs {
    return {
      anchor: this.anchor && this.anchor.asObject(),
      rootChainReceipt: this.rootChainReceipt && this.rootChainReceipt.asObject(),
    };
  }
}

export type PartitionInfoArgs = {
  id?: string;
  type?: PartitionTypeArgs;
};
export class PartitionInfo {
  @encodeAs.field(1).string
  public id?: string;
  @encodeAs.field(2).enum
  public type?: PartitionType;

  constructor(args: PartitionInfoArgs) {
    this.id = args.id == undefined ? undefined : args.id;
    this.type = args.type == undefined ? undefined : PartitionType.fromObject(args.type);
  }

  copy() {
    return new PartitionInfo(this.asObject());
  }

  asObject(): PartitionInfoArgs {
    return {
      id: this.id && this.id,
      type: this.type && PartitionType.getName(this.type),
    };
  }
}

export type PartitionSignatureArgs = {
  sourceNetwork?: URL | string;
  destinationNetwork?: URL | string;
  sequenceNumber?: number;
  transactionHash?: Uint8Array | string;
};
export type PartitionSignatureArgsWithType = PartitionSignatureArgs & {
  type: SignatureType.Partition | "partition";
};
export class PartitionSignature {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = SignatureType.Partition;
  @encodeAs.field(2).url
  public sourceNetwork?: URL;
  @encodeAs.field(3).url
  public destinationNetwork?: URL;
  @encodeAs.field(4).uint
  public sequenceNumber?: number;
  @encodeAs.field(5).hash
  public transactionHash?: Uint8Array;

  constructor(args: PartitionSignatureArgs) {
    this.sourceNetwork =
      args.sourceNetwork == undefined
        ? undefined
        : args.sourceNetwork instanceof URL
        ? args.sourceNetwork
        : new URL(args.sourceNetwork);
    this.destinationNetwork =
      args.destinationNetwork == undefined
        ? undefined
        : args.destinationNetwork instanceof URL
        ? args.destinationNetwork
        : new URL(args.destinationNetwork);
    this.sequenceNumber = args.sequenceNumber == undefined ? undefined : args.sequenceNumber;
    this.transactionHash =
      args.transactionHash == undefined
        ? undefined
        : args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  copy() {
    return new PartitionSignature(this.asObject());
  }

  asObject(): PartitionSignatureArgsWithType {
    return {
      type: "partition",
      sourceNetwork: this.sourceNetwork && this.sourceNetwork.toString(),
      destinationNetwork: this.destinationNetwork && this.destinationNetwork.toString(),
      sequenceNumber: this.sequenceNumber && this.sequenceNumber,
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export type PartitionSyntheticLedgerArgs = {
  url?: URL | string;
  produced?: number;
  received?: number;
  delivered?: number;
  pending?: (TxID | string)[];
};
export class PartitionSyntheticLedger {
  @encodeAs.field(1).url
  public url?: URL;
  @encodeAs.field(2).uint
  public produced?: number;
  @encodeAs.field(3).uint
  public received?: number;
  @encodeAs.field(4).uint
  public delivered?: number;
  @encodeAs.field(5).repeatable.txid
  public pending?: TxID[];

  constructor(args: PartitionSyntheticLedgerArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.produced = args.produced == undefined ? undefined : args.produced;
    this.received = args.received == undefined ? undefined : args.received;
    this.delivered = args.delivered == undefined ? undefined : args.delivered;
    this.pending =
      args.pending == undefined
        ? undefined
        : args.pending.map((v) => (v instanceof TxID ? v : new TxID(v)));
  }

  copy() {
    return new PartitionSyntheticLedger(this.asObject());
  }

  asObject(): PartitionSyntheticLedgerArgs {
    return {
      url: this.url && this.url.toString(),
      produced: this.produced && this.produced,
      received: this.received && this.received,
      delivered: this.delivered && this.delivered,
      pending: this.pending && this.pending?.map((v) => v.toString()),
    };
  }
}

export type RCD1SignatureArgs = {
  publicKey?: Uint8Array | string;
  signature?: Uint8Array | string;
  signer?: URL | string;
  signerVersion?: number;
  timestamp?: number;
  vote?: VoteTypeArgs;
  transactionHash?: Uint8Array | string;
};
export type RCD1SignatureArgsWithType = RCD1SignatureArgs & { type: SignatureType.RCD1 | "rcd1" };
export class RCD1Signature {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = SignatureType.RCD1;
  @encodeAs.field(2).bytes
  public publicKey?: Uint8Array;
  @encodeAs.field(3).bytes
  public signature?: Uint8Array;
  @encodeAs.field(4).url
  public signer?: URL;
  @encodeAs.field(5).uint
  public signerVersion?: number;
  @encodeAs.field(6).uint
  public timestamp?: number;
  @encodeAs.field(7).enum
  public vote?: VoteType;
  @encodeAs.field(8).hash
  public transactionHash?: Uint8Array;

  constructor(args: RCD1SignatureArgs) {
    this.publicKey =
      args.publicKey == undefined
        ? undefined
        : args.publicKey instanceof Uint8Array
        ? args.publicKey
        : Buffer.from(args.publicKey, "hex");
    this.signature =
      args.signature == undefined
        ? undefined
        : args.signature instanceof Uint8Array
        ? args.signature
        : Buffer.from(args.signature, "hex");
    this.signer =
      args.signer == undefined
        ? undefined
        : args.signer instanceof URL
        ? args.signer
        : new URL(args.signer);
    this.signerVersion = args.signerVersion == undefined ? undefined : args.signerVersion;
    this.timestamp = args.timestamp == undefined ? undefined : args.timestamp;
    this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
    this.transactionHash =
      args.transactionHash == undefined
        ? undefined
        : args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  copy() {
    return new RCD1Signature(this.asObject());
  }

  asObject(): RCD1SignatureArgsWithType {
    return {
      type: "rcd1",
      publicKey: this.publicKey && Buffer.from(this.publicKey).toString("hex"),
      signature: this.signature && Buffer.from(this.signature).toString("hex"),
      signer: this.signer && this.signer.toString(),
      signerVersion: this.signerVersion && this.signerVersion,
      timestamp: this.timestamp && this.timestamp,
      vote: this.vote && VoteType.getName(this.vote),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export type RationalArgs = {
  numerator?: number;
  denominator?: number;
};
export class Rational {
  @encodeAs.field(1).uint
  public numerator?: number;
  @encodeAs.field(2).uint
  public denominator?: number;

  constructor(args: RationalArgs) {
    this.numerator = args.numerator == undefined ? undefined : args.numerator;
    this.denominator = args.denominator == undefined ? undefined : args.denominator;
  }

  copy() {
    return new Rational(this.asObject());
  }

  asObject(): RationalArgs {
    return {
      numerator: this.numerator && this.numerator,
      denominator: this.denominator && this.denominator,
    };
  }
}

export type ReceiptSignatureArgs = {
  sourceNetwork?: URL | string;
  proof?: merkle.Receipt | merkle.ReceiptArgs;
  transactionHash?: Uint8Array | string;
};
export type ReceiptSignatureArgsWithType = ReceiptSignatureArgs & {
  type: SignatureType.Receipt | "receipt";
};
export class ReceiptSignature {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = SignatureType.Receipt;
  @encodeAs.field(2).url
  public sourceNetwork?: URL;
  @encodeAs.field(3).reference
  public proof?: merkle.Receipt;
  @encodeAs.field(4).hash
  public transactionHash?: Uint8Array;

  constructor(args: ReceiptSignatureArgs) {
    this.sourceNetwork =
      args.sourceNetwork == undefined
        ? undefined
        : args.sourceNetwork instanceof URL
        ? args.sourceNetwork
        : new URL(args.sourceNetwork);
    this.proof =
      args.proof == undefined
        ? undefined
        : args.proof instanceof merkle.Receipt
        ? args.proof
        : new merkle.Receipt(args.proof);
    this.transactionHash =
      args.transactionHash == undefined
        ? undefined
        : args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
  }

  copy() {
    return new ReceiptSignature(this.asObject());
  }

  asObject(): ReceiptSignatureArgsWithType {
    return {
      type: "receipt",
      sourceNetwork: this.sourceNetwork && this.sourceNetwork.toString(),
      proof: this.proof && this.proof.asObject(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
    };
  }
}

export type RemoteSignatureArgs = {
  destination?: URL | string;
  signature?: Signature | SignatureArgs;
  cause?: (Uint8Array | string)[];
};
export type RemoteSignatureArgsWithType = RemoteSignatureArgs & {
  type: SignatureType.Remote | "remote";
};
export class RemoteSignature {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = SignatureType.Remote;
  @encodeAs.field(2).url
  public destination?: URL;
  @encodeAs.field(3).union
  public signature?: Signature;
  @encodeAs.field(4).repeatable.hash
  public cause?: Uint8Array[];

  constructor(args: RemoteSignatureArgs) {
    this.destination =
      args.destination == undefined
        ? undefined
        : args.destination instanceof URL
        ? args.destination
        : new URL(args.destination);
    this.signature = args.signature == undefined ? undefined : Signature.fromObject(args.signature);
    this.cause =
      args.cause == undefined
        ? undefined
        : args.cause.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
  }

  copy() {
    return new RemoteSignature(this.asObject());
  }

  asObject(): RemoteSignatureArgsWithType {
    return {
      type: "remote",
      destination: this.destination && this.destination.toString(),
      signature: this.signature && this.signature.asObject(),
      cause: this.cause && this.cause?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export type RemoteTransactionArgs = {
  hash?: Uint8Array | string;
};
export type RemoteTransactionArgsWithType = RemoteTransactionArgs & {
  type: TransactionType.Remote | "remote";
};
export class RemoteTransaction {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.Remote;
  @encodeAs.field(2).hash
  public hash?: Uint8Array;

  constructor(args: RemoteTransactionArgs) {
    this.hash =
      args.hash == undefined
        ? undefined
        : args.hash instanceof Uint8Array
        ? args.hash
        : Buffer.from(args.hash, "hex");
  }

  copy() {
    return new RemoteTransaction(this.asObject());
  }

  asObject(): RemoteTransactionArgsWithType {
    return {
      type: "remote",
      hash: this.hash && Buffer.from(this.hash).toString("hex"),
    };
  }
}

export type RemoveAccountAuthorityOperationArgs = {
  authority?: URL | string;
};
export type RemoveAccountAuthorityOperationArgsWithType = RemoveAccountAuthorityOperationArgs & {
  type: AccountAuthOperationType.RemoveAuthority | "removeAuthority";
};
export class RemoveAccountAuthorityOperation {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountAuthOperationType.RemoveAuthority;
  @encodeAs.field(2).url
  public authority?: URL;

  constructor(args: RemoveAccountAuthorityOperationArgs) {
    this.authority =
      args.authority == undefined
        ? undefined
        : args.authority instanceof URL
        ? args.authority
        : new URL(args.authority);
  }

  copy() {
    return new RemoveAccountAuthorityOperation(this.asObject());
  }

  asObject(): RemoveAccountAuthorityOperationArgsWithType {
    return {
      type: "removeAuthority",
      authority: this.authority && this.authority.toString(),
    };
  }
}

export type RemoveKeyOperationArgs = {
  entry?: KeySpecParams | KeySpecParamsArgs;
};
export type RemoveKeyOperationArgsWithType = RemoveKeyOperationArgs & {
  type: KeyPageOperationType.Remove | "remove";
};
export class RemoveKeyOperation {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = KeyPageOperationType.Remove;
  @encodeAs.field(2).reference
  public entry?: KeySpecParams;

  constructor(args: RemoveKeyOperationArgs) {
    this.entry =
      args.entry == undefined
        ? undefined
        : args.entry instanceof KeySpecParams
        ? args.entry
        : new KeySpecParams(args.entry);
  }

  copy() {
    return new RemoveKeyOperation(this.asObject());
  }

  asObject(): RemoveKeyOperationArgsWithType {
    return {
      type: "remove",
      entry: this.entry && this.entry.asObject(),
    };
  }
}

export type RouteArgs = {
  length?: number;
  value?: number;
  partition?: string;
};
export class Route {
  @encodeAs.field(1).uint
  public length?: number;
  @encodeAs.field(2).uint
  public value?: number;
  @encodeAs.field(3).string
  public partition?: string;

  constructor(args: RouteArgs) {
    this.length = args.length == undefined ? undefined : args.length;
    this.value = args.value == undefined ? undefined : args.value;
    this.partition = args.partition == undefined ? undefined : args.partition;
  }

  copy() {
    return new Route(this.asObject());
  }

  asObject(): RouteArgs {
    return {
      length: this.length && this.length,
      value: this.value && this.value,
      partition: this.partition && this.partition,
    };
  }
}

export type RouteOverrideArgs = {
  account?: URL | string;
  partition?: string;
};
export class RouteOverride {
  @encodeAs.field(1).url
  public account?: URL;
  @encodeAs.field(2).string
  public partition?: string;

  constructor(args: RouteOverrideArgs) {
    this.account =
      args.account == undefined
        ? undefined
        : args.account instanceof URL
        ? args.account
        : new URL(args.account);
    this.partition = args.partition == undefined ? undefined : args.partition;
  }

  copy() {
    return new RouteOverride(this.asObject());
  }

  asObject(): RouteOverrideArgs {
    return {
      account: this.account && this.account.toString(),
      partition: this.partition && this.partition,
    };
  }
}

export type RoutingTableArgs = {
  overrides?: (RouteOverride | RouteOverrideArgs)[];
  routes?: (Route | RouteArgs)[];
};
export class RoutingTable {
  @encodeAs.field(1).repeatable.reference
  public overrides?: RouteOverride[];
  @encodeAs.field(2).repeatable.reference
  public routes?: Route[];

  constructor(args: RoutingTableArgs) {
    this.overrides =
      args.overrides == undefined
        ? undefined
        : args.overrides.map((v) => (v instanceof RouteOverride ? v : new RouteOverride(v)));
    this.routes =
      args.routes == undefined
        ? undefined
        : args.routes.map((v) => (v instanceof Route ? v : new Route(v)));
  }

  copy() {
    return new RoutingTable(this.asObject());
  }

  asObject(): RoutingTableArgs {
    return {
      overrides: this.overrides && this.overrides?.map((v) => v.asObject()),
      routes: this.routes && this.routes?.map((v) => v.asObject()),
    };
  }
}

export type SendTokensArgs = {
  hash?: Uint8Array | string;
  meta?: unknown;
  to?: (TokenRecipient | TokenRecipientArgs)[];
};
export type SendTokensArgsWithType = SendTokensArgs & {
  type: TransactionType.SendTokens | "sendTokens";
};
export class SendTokens {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.SendTokens;
  @encodeAs.field(2).hash
  public hash?: Uint8Array;
  @encodeAs.field(3).rawJson
  public meta?: unknown;
  @encodeAs.field(4).repeatable.reference
  public to?: TokenRecipient[];

  constructor(args: SendTokensArgs) {
    this.hash =
      args.hash == undefined
        ? undefined
        : args.hash instanceof Uint8Array
        ? args.hash
        : Buffer.from(args.hash, "hex");
    this.meta = args.meta == undefined ? undefined : args.meta;
    this.to =
      args.to == undefined
        ? undefined
        : args.to.map((v) => (v instanceof TokenRecipient ? v : new TokenRecipient(v)));
  }

  copy() {
    return new SendTokens(this.asObject());
  }

  asObject(): SendTokensArgsWithType {
    return {
      type: "sendTokens",
      hash: this.hash && Buffer.from(this.hash).toString("hex"),
      meta: this.meta && this.meta,
      to: this.to && this.to?.map((v) => v.asObject()),
    };
  }
}

export type SetThresholdKeyPageOperationArgs = {
  threshold?: number;
};
export type SetThresholdKeyPageOperationArgsWithType = SetThresholdKeyPageOperationArgs & {
  type: KeyPageOperationType.SetThreshold | "setThreshold";
};
export class SetThresholdKeyPageOperation {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = KeyPageOperationType.SetThreshold;
  @encodeAs.field(2).uint
  public threshold?: number;

  constructor(args: SetThresholdKeyPageOperationArgs) {
    this.threshold = args.threshold == undefined ? undefined : args.threshold;
  }

  copy() {
    return new SetThresholdKeyPageOperation(this.asObject());
  }

  asObject(): SetThresholdKeyPageOperationArgsWithType {
    return {
      type: "setThreshold",
      threshold: this.threshold && this.threshold,
    };
  }
}

export type SignatureSetArgs = {
  vote?: VoteTypeArgs;
  signer?: URL | string;
  transactionHash?: Uint8Array | string;
  signatures?: (Signature | SignatureArgs)[];
  authority?: URL | string;
};
export type SignatureSetArgsWithType = SignatureSetArgs & { type: SignatureType.Set | "set" };
export class SignatureSet {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = SignatureType.Set;
  @encodeAs.field(2).enum
  public vote?: VoteType;
  @encodeAs.field(3).url
  public signer?: URL;
  @encodeAs.field(4).hash
  public transactionHash?: Uint8Array;
  @encodeAs.field(5).repeatable.union
  public signatures?: Signature[];
  @encodeAs.field(6).url
  public authority?: URL;

  constructor(args: SignatureSetArgs) {
    this.vote = args.vote == undefined ? undefined : VoteType.fromObject(args.vote);
    this.signer =
      args.signer == undefined
        ? undefined
        : args.signer instanceof URL
        ? args.signer
        : new URL(args.signer);
    this.transactionHash =
      args.transactionHash == undefined
        ? undefined
        : args.transactionHash instanceof Uint8Array
        ? args.transactionHash
        : Buffer.from(args.transactionHash, "hex");
    this.signatures =
      args.signatures == undefined
        ? undefined
        : args.signatures.map((v) => Signature.fromObject(v));
    this.authority =
      args.authority == undefined
        ? undefined
        : args.authority instanceof URL
        ? args.authority
        : new URL(args.authority);
  }

  copy() {
    return new SignatureSet(this.asObject());
  }

  asObject(): SignatureSetArgsWithType {
    return {
      type: "set",
      vote: this.vote && VoteType.getName(this.vote),
      signer: this.signer && this.signer.toString(),
      transactionHash: this.transactionHash && Buffer.from(this.transactionHash).toString("hex"),
      signatures: this.signatures && this.signatures?.map((v) => v.asObject()),
      authority: this.authority && this.authority.toString(),
    };
  }
}

export type SyntheticBurnTokensArgs = {
  cause?: TxID | string;
  source?: URL | string;
  initiator?: URL | string;
  feeRefund?: number;
  amount?: BN | string | number;
  isRefund?: boolean;
};
export type SyntheticBurnTokensArgsWithType = SyntheticBurnTokensArgs & {
  type: TransactionType.SyntheticBurnTokens | "syntheticBurnTokens";
};
export class SyntheticBurnTokens {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.SyntheticBurnTokens;
  @encodeAs.field(2, 1).txid
  public cause?: TxID;
  @encodeAs.field(2, 0).url
  public source?: URL;
  @encodeAs.field(2, 3).url
  public initiator?: URL;
  @encodeAs.field(2, 4).uint
  public feeRefund?: number;
  @encodeAs.field(3).bigInt
  public amount?: BN;
  @encodeAs.field(4).bool
  public isRefund?: boolean;

  constructor(args: SyntheticBurnTokensArgs) {
    this.cause =
      args.cause == undefined
        ? undefined
        : args.cause instanceof TxID
        ? args.cause
        : new TxID(args.cause);
    this.source =
      args.source == undefined
        ? undefined
        : args.source instanceof URL
        ? args.source
        : new URL(args.source);
    this.initiator =
      args.initiator == undefined
        ? undefined
        : args.initiator instanceof URL
        ? args.initiator
        : new URL(args.initiator);
    this.feeRefund = args.feeRefund == undefined ? undefined : args.feeRefund;
    this.amount =
      args.amount == undefined
        ? undefined
        : args.amount instanceof BN
        ? args.amount
        : new BN(args.amount);
    this.isRefund = args.isRefund == undefined ? undefined : args.isRefund;
  }

  copy() {
    return new SyntheticBurnTokens(this.asObject());
  }

  asObject(): SyntheticBurnTokensArgsWithType {
    return {
      type: "syntheticBurnTokens",
      cause: this.cause && this.cause.toString(),
      source: this.source && this.source.toString(),
      initiator: this.initiator && this.initiator.toString(),
      feeRefund: this.feeRefund && this.feeRefund,
      amount: this.amount && this.amount.toString(),
      isRefund: this.isRefund && this.isRefund,
    };
  }
}

export type SyntheticCreateIdentityArgs = {
  cause?: TxID | string;
  source?: URL | string;
  initiator?: URL | string;
  feeRefund?: number;
  accounts?: (Account | AccountArgs)[];
};
export type SyntheticCreateIdentityArgsWithType = SyntheticCreateIdentityArgs & {
  type: TransactionType.SyntheticCreateIdentity | "syntheticCreateIdentity";
};
export class SyntheticCreateIdentity {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.SyntheticCreateIdentity;
  @encodeAs.field(2, 1).txid
  public cause?: TxID;
  @encodeAs.field(2, 0).url
  public source?: URL;
  @encodeAs.field(2, 3).url
  public initiator?: URL;
  @encodeAs.field(2, 4).uint
  public feeRefund?: number;
  @encodeAs.field(3).repeatable.union
  public accounts?: Account[];

  constructor(args: SyntheticCreateIdentityArgs) {
    this.cause =
      args.cause == undefined
        ? undefined
        : args.cause instanceof TxID
        ? args.cause
        : new TxID(args.cause);
    this.source =
      args.source == undefined
        ? undefined
        : args.source instanceof URL
        ? args.source
        : new URL(args.source);
    this.initiator =
      args.initiator == undefined
        ? undefined
        : args.initiator instanceof URL
        ? args.initiator
        : new URL(args.initiator);
    this.feeRefund = args.feeRefund == undefined ? undefined : args.feeRefund;
    this.accounts =
      args.accounts == undefined ? undefined : args.accounts.map((v) => Account.fromObject(v));
  }

  copy() {
    return new SyntheticCreateIdentity(this.asObject());
  }

  asObject(): SyntheticCreateIdentityArgsWithType {
    return {
      type: "syntheticCreateIdentity",
      cause: this.cause && this.cause.toString(),
      source: this.source && this.source.toString(),
      initiator: this.initiator && this.initiator.toString(),
      feeRefund: this.feeRefund && this.feeRefund,
      accounts: this.accounts && this.accounts?.map((v) => v.asObject()),
    };
  }
}

export type SyntheticDepositCreditsArgs = {
  cause?: TxID | string;
  source?: URL | string;
  initiator?: URL | string;
  feeRefund?: number;
  amount?: number;
  acmeRefundAmount?: BN | string | number;
  isRefund?: boolean;
};
export type SyntheticDepositCreditsArgsWithType = SyntheticDepositCreditsArgs & {
  type: TransactionType.SyntheticDepositCredits | "syntheticDepositCredits";
};
export class SyntheticDepositCredits {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.SyntheticDepositCredits;
  @encodeAs.field(2, 1).txid
  public cause?: TxID;
  @encodeAs.field(2, 0).url
  public source?: URL;
  @encodeAs.field(2, 3).url
  public initiator?: URL;
  @encodeAs.field(2, 4).uint
  public feeRefund?: number;
  @encodeAs.field(3).uint
  public amount?: number;
  @encodeAs.field(4).bigInt
  public acmeRefundAmount?: BN;
  @encodeAs.field(5).bool
  public isRefund?: boolean;

  constructor(args: SyntheticDepositCreditsArgs) {
    this.cause =
      args.cause == undefined
        ? undefined
        : args.cause instanceof TxID
        ? args.cause
        : new TxID(args.cause);
    this.source =
      args.source == undefined
        ? undefined
        : args.source instanceof URL
        ? args.source
        : new URL(args.source);
    this.initiator =
      args.initiator == undefined
        ? undefined
        : args.initiator instanceof URL
        ? args.initiator
        : new URL(args.initiator);
    this.feeRefund = args.feeRefund == undefined ? undefined : args.feeRefund;
    this.amount = args.amount == undefined ? undefined : args.amount;
    this.acmeRefundAmount =
      args.acmeRefundAmount == undefined
        ? undefined
        : args.acmeRefundAmount instanceof BN
        ? args.acmeRefundAmount
        : new BN(args.acmeRefundAmount);
    this.isRefund = args.isRefund == undefined ? undefined : args.isRefund;
  }

  copy() {
    return new SyntheticDepositCredits(this.asObject());
  }

  asObject(): SyntheticDepositCreditsArgsWithType {
    return {
      type: "syntheticDepositCredits",
      cause: this.cause && this.cause.toString(),
      source: this.source && this.source.toString(),
      initiator: this.initiator && this.initiator.toString(),
      feeRefund: this.feeRefund && this.feeRefund,
      amount: this.amount && this.amount,
      acmeRefundAmount: this.acmeRefundAmount && this.acmeRefundAmount.toString(),
      isRefund: this.isRefund && this.isRefund,
    };
  }
}

export type SyntheticDepositTokensArgs = {
  cause?: TxID | string;
  source?: URL | string;
  initiator?: URL | string;
  feeRefund?: number;
  token?: URL | string;
  amount?: BN | string | number;
  isIssuer?: boolean;
  isRefund?: boolean;
};
export type SyntheticDepositTokensArgsWithType = SyntheticDepositTokensArgs & {
  type: TransactionType.SyntheticDepositTokens | "syntheticDepositTokens";
};
export class SyntheticDepositTokens {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.SyntheticDepositTokens;
  @encodeAs.field(2, 1).txid
  public cause?: TxID;
  @encodeAs.field(2, 0).url
  public source?: URL;
  @encodeAs.field(2, 3).url
  public initiator?: URL;
  @encodeAs.field(2, 4).uint
  public feeRefund?: number;
  @encodeAs.field(3).url
  public token?: URL;
  @encodeAs.field(4).bigInt
  public amount?: BN;
  @encodeAs.field(5).bool
  public isIssuer?: boolean;
  @encodeAs.field(6).bool
  public isRefund?: boolean;

  constructor(args: SyntheticDepositTokensArgs) {
    this.cause =
      args.cause == undefined
        ? undefined
        : args.cause instanceof TxID
        ? args.cause
        : new TxID(args.cause);
    this.source =
      args.source == undefined
        ? undefined
        : args.source instanceof URL
        ? args.source
        : new URL(args.source);
    this.initiator =
      args.initiator == undefined
        ? undefined
        : args.initiator instanceof URL
        ? args.initiator
        : new URL(args.initiator);
    this.feeRefund = args.feeRefund == undefined ? undefined : args.feeRefund;
    this.token =
      args.token == undefined
        ? undefined
        : args.token instanceof URL
        ? args.token
        : new URL(args.token);
    this.amount =
      args.amount == undefined
        ? undefined
        : args.amount instanceof BN
        ? args.amount
        : new BN(args.amount);
    this.isIssuer = args.isIssuer == undefined ? undefined : args.isIssuer;
    this.isRefund = args.isRefund == undefined ? undefined : args.isRefund;
  }

  copy() {
    return new SyntheticDepositTokens(this.asObject());
  }

  asObject(): SyntheticDepositTokensArgsWithType {
    return {
      type: "syntheticDepositTokens",
      cause: this.cause && this.cause.toString(),
      source: this.source && this.source.toString(),
      initiator: this.initiator && this.initiator.toString(),
      feeRefund: this.feeRefund && this.feeRefund,
      token: this.token && this.token.toString(),
      amount: this.amount && this.amount.toString(),
      isIssuer: this.isIssuer && this.isIssuer,
      isRefund: this.isRefund && this.isRefund,
    };
  }
}

export type SyntheticForwardTransactionArgs = {
  signatures?: (RemoteSignature | RemoteSignatureArgs)[];
  transaction?: Transaction | TransactionArgs;
};
export type SyntheticForwardTransactionArgsWithType = SyntheticForwardTransactionArgs & {
  type: TransactionType.SyntheticForwardTransaction | "syntheticForwardTransaction";
};
export class SyntheticForwardTransaction {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.SyntheticForwardTransaction;
  @encodeAs.field(2).repeatable.reference
  public signatures?: RemoteSignature[];
  @encodeAs.field(3).reference
  public transaction?: Transaction;

  constructor(args: SyntheticForwardTransactionArgs) {
    this.signatures =
      args.signatures == undefined
        ? undefined
        : args.signatures.map((v) => (v instanceof RemoteSignature ? v : new RemoteSignature(v)));
    this.transaction =
      args.transaction == undefined
        ? undefined
        : args.transaction instanceof Transaction
        ? args.transaction
        : new Transaction(args.transaction);
  }

  copy() {
    return new SyntheticForwardTransaction(this.asObject());
  }

  asObject(): SyntheticForwardTransactionArgsWithType {
    return {
      type: "syntheticForwardTransaction",
      signatures: this.signatures && this.signatures?.map((v) => v.asObject()),
      transaction: this.transaction && this.transaction.asObject(),
    };
  }
}

export type SyntheticLedgerArgs = {
  url?: URL | string;
  sequence?: (PartitionSyntheticLedger | PartitionSyntheticLedgerArgs)[];
};
export type SyntheticLedgerArgsWithType = SyntheticLedgerArgs & {
  type: AccountType.SyntheticLedger | "syntheticLedger";
};
export class SyntheticLedger {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountType.SyntheticLedger;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(3).repeatable.reference
  public sequence?: PartitionSyntheticLedger[];

  constructor(args: SyntheticLedgerArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.sequence =
      args.sequence == undefined
        ? undefined
        : args.sequence.map((v) =>
            v instanceof PartitionSyntheticLedger ? v : new PartitionSyntheticLedger(v)
          );
  }

  copy() {
    return new SyntheticLedger(this.asObject());
  }

  asObject(): SyntheticLedgerArgsWithType {
    return {
      type: "syntheticLedger",
      url: this.url && this.url.toString(),
      sequence: this.sequence && this.sequence?.map((v) => v.asObject()),
    };
  }
}

export type SyntheticOriginArgs = {
  cause?: TxID | string;
  initiator?: URL | string;
  feeRefund?: number;
};
export class SyntheticOrigin {
  @encodeAs.field(1).txid
  public cause?: TxID;
  @encodeAs.field(3).url
  public initiator?: URL;
  @encodeAs.field(4).uint
  public feeRefund?: number;

  constructor(args: SyntheticOriginArgs) {
    this.cause =
      args.cause == undefined
        ? undefined
        : args.cause instanceof TxID
        ? args.cause
        : new TxID(args.cause);
    this.initiator =
      args.initiator == undefined
        ? undefined
        : args.initiator instanceof URL
        ? args.initiator
        : new URL(args.initiator);
    this.feeRefund = args.feeRefund == undefined ? undefined : args.feeRefund;
  }

  copy() {
    return new SyntheticOrigin(this.asObject());
  }

  asObject(): SyntheticOriginArgs {
    return {
      cause: this.cause && this.cause.toString(),
      initiator: this.initiator && this.initiator.toString(),
      feeRefund: this.feeRefund && this.feeRefund,
    };
  }
}

export type SyntheticWriteDataArgs = {
  cause?: TxID | string;
  source?: URL | string;
  initiator?: URL | string;
  feeRefund?: number;
  entry?: DataEntry | DataEntryArgs;
};
export type SyntheticWriteDataArgsWithType = SyntheticWriteDataArgs & {
  type: TransactionType.SyntheticWriteData | "syntheticWriteData";
};
export class SyntheticWriteData {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.SyntheticWriteData;
  @encodeAs.field(2, 1).txid
  public cause?: TxID;
  @encodeAs.field(2, 0).url
  public source?: URL;
  @encodeAs.field(2, 3).url
  public initiator?: URL;
  @encodeAs.field(2, 4).uint
  public feeRefund?: number;
  @encodeAs.field(3).union
  public entry?: DataEntry;

  constructor(args: SyntheticWriteDataArgs) {
    this.cause =
      args.cause == undefined
        ? undefined
        : args.cause instanceof TxID
        ? args.cause
        : new TxID(args.cause);
    this.source =
      args.source == undefined
        ? undefined
        : args.source instanceof URL
        ? args.source
        : new URL(args.source);
    this.initiator =
      args.initiator == undefined
        ? undefined
        : args.initiator instanceof URL
        ? args.initiator
        : new URL(args.initiator);
    this.feeRefund = args.feeRefund == undefined ? undefined : args.feeRefund;
    this.entry = args.entry == undefined ? undefined : DataEntry.fromObject(args.entry);
  }

  copy() {
    return new SyntheticWriteData(this.asObject());
  }

  asObject(): SyntheticWriteDataArgsWithType {
    return {
      type: "syntheticWriteData",
      cause: this.cause && this.cause.toString(),
      source: this.source && this.source.toString(),
      initiator: this.initiator && this.initiator.toString(),
      feeRefund: this.feeRefund && this.feeRefund,
      entry: this.entry && this.entry.asObject(),
    };
  }
}

export type SystemGenesisArgs = {};
export type SystemGenesisArgsWithType = { type: TransactionType.SystemGenesis | "systemGenesis" };
export class SystemGenesis {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.SystemGenesis;

  constructor(_: SystemGenesisArgs) {}

  copy() {
    return new SystemGenesis(this.asObject());
  }

  asObject(): SystemGenesisArgsWithType {
    return {
      type: "systemGenesis",
    };
  }
}

export type SystemLedgerArgs = {
  url?: URL | string;
  index?: number;
  timestamp?: Date | string;
  acmeBurnt?: BN | string | number;
  pendingUpdates?: (NetworkAccountUpdate | NetworkAccountUpdateArgs)[];
  anchor?: AnchorBody | AnchorBodyArgs;
  executorVersion?: ExecutorVersionArgs;
};
export type SystemLedgerArgsWithType = SystemLedgerArgs & {
  type: AccountType.SystemLedger | "systemLedger";
};
export class SystemLedger {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountType.SystemLedger;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(3).uint
  public index?: number;
  @encodeAs.field(4).time
  public timestamp?: Date;
  @encodeAs.field(5).bigInt
  public acmeBurnt?: BN;
  @encodeAs.field(6).repeatable.reference
  public pendingUpdates?: NetworkAccountUpdate[];
  @encodeAs.field(7).union
  public anchor?: AnchorBody;
  @encodeAs.field(8).enum
  public executorVersion?: ExecutorVersion;

  constructor(args: SystemLedgerArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.index = args.index == undefined ? undefined : args.index;
    this.timestamp =
      args.timestamp == undefined
        ? undefined
        : args.timestamp instanceof Date
        ? args.timestamp
        : new Date(args.timestamp);
    this.acmeBurnt =
      args.acmeBurnt == undefined
        ? undefined
        : args.acmeBurnt instanceof BN
        ? args.acmeBurnt
        : new BN(args.acmeBurnt);
    this.pendingUpdates =
      args.pendingUpdates == undefined
        ? undefined
        : args.pendingUpdates.map((v) =>
            v instanceof NetworkAccountUpdate ? v : new NetworkAccountUpdate(v)
          );
    this.anchor = args.anchor == undefined ? undefined : AnchorBody.fromObject(args.anchor);
    this.executorVersion =
      args.executorVersion == undefined
        ? undefined
        : ExecutorVersion.fromObject(args.executorVersion);
  }

  copy() {
    return new SystemLedger(this.asObject());
  }

  asObject(): SystemLedgerArgsWithType {
    return {
      type: "systemLedger",
      url: this.url && this.url.toString(),
      index: this.index && this.index,
      timestamp: this.timestamp && this.timestamp,
      acmeBurnt: this.acmeBurnt && this.acmeBurnt.toString(),
      pendingUpdates: this.pendingUpdates && this.pendingUpdates?.map((v) => v.asObject()),
      anchor: this.anchor && this.anchor.asObject(),
      executorVersion: this.executorVersion && ExecutorVersion.getName(this.executorVersion),
    };
  }
}

export type SystemWriteDataArgs = {
  entry?: DataEntry | DataEntryArgs;
  writeToState?: boolean;
};
export type SystemWriteDataArgsWithType = SystemWriteDataArgs & {
  type: TransactionType.SystemWriteData | "systemWriteData";
};
export class SystemWriteData {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.SystemWriteData;
  @encodeAs.field(2).union
  public entry?: DataEntry;
  @encodeAs.field(3).bool
  public writeToState?: boolean;

  constructor(args: SystemWriteDataArgs) {
    this.entry = args.entry == undefined ? undefined : DataEntry.fromObject(args.entry);
    this.writeToState = args.writeToState == undefined ? undefined : args.writeToState;
  }

  copy() {
    return new SystemWriteData(this.asObject());
  }

  asObject(): SystemWriteDataArgsWithType {
    return {
      type: "systemWriteData",
      entry: this.entry && this.entry.asObject(),
      writeToState: this.writeToState && this.writeToState,
    };
  }
}

export type TokenAccountArgs = {
  url?: URL | string;
  authorities?: (AuthorityEntry | AuthorityEntryArgs)[];
  tokenUrl?: URL | string;
  balance?: BN | string | number;
};
export type TokenAccountArgsWithType = TokenAccountArgs & {
  type: AccountType.TokenAccount | "tokenAccount";
};
export class TokenAccount {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountType.TokenAccount;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(3, 1).repeatable.reference
  public authorities?: AuthorityEntry[];
  @encodeAs.field(4).url
  public tokenUrl?: URL;
  @encodeAs.field(5).bigInt
  public balance?: BN;

  constructor(args: TokenAccountArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.authorities =
      args.authorities == undefined
        ? undefined
        : args.authorities.map((v) => (v instanceof AuthorityEntry ? v : new AuthorityEntry(v)));
    this.tokenUrl =
      args.tokenUrl == undefined
        ? undefined
        : args.tokenUrl instanceof URL
        ? args.tokenUrl
        : new URL(args.tokenUrl);
    this.balance =
      args.balance == undefined
        ? undefined
        : args.balance instanceof BN
        ? args.balance
        : new BN(args.balance);
  }

  copy() {
    return new TokenAccount(this.asObject());
  }

  asObject(): TokenAccountArgsWithType {
    return {
      type: "tokenAccount",
      url: this.url && this.url.toString(),
      authorities: this.authorities && this.authorities?.map((v) => v.asObject()),
      tokenUrl: this.tokenUrl && this.tokenUrl.toString(),
      balance: this.balance && this.balance.toString(),
    };
  }
}

export type TokenIssuerArgs = {
  url?: URL | string;
  authorities?: (AuthorityEntry | AuthorityEntryArgs)[];
  symbol?: string;
  precision?: number;
  properties?: URL | string;
  issued?: BN | string | number;
  supplyLimit?: BN | string | number;
};
export type TokenIssuerArgsWithType = TokenIssuerArgs & {
  type: AccountType.TokenIssuer | "tokenIssuer";
};
export class TokenIssuer {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountType.TokenIssuer;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(3, 1).repeatable.reference
  public authorities?: AuthorityEntry[];
  @encodeAs.field(4).string
  public symbol?: string;
  @encodeAs.field(5).uint
  public precision?: number;
  @encodeAs.field(6).url
  public properties?: URL;
  @encodeAs.field(7).bigInt
  public issued?: BN;
  @encodeAs.field(8).bigInt
  public supplyLimit?: BN;

  constructor(args: TokenIssuerArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.authorities =
      args.authorities == undefined
        ? undefined
        : args.authorities.map((v) => (v instanceof AuthorityEntry ? v : new AuthorityEntry(v)));
    this.symbol = args.symbol == undefined ? undefined : args.symbol;
    this.precision = args.precision == undefined ? undefined : args.precision;
    this.properties =
      args.properties == undefined
        ? undefined
        : args.properties instanceof URL
        ? args.properties
        : new URL(args.properties);
    this.issued =
      args.issued == undefined
        ? undefined
        : args.issued instanceof BN
        ? args.issued
        : new BN(args.issued);
    this.supplyLimit =
      args.supplyLimit == undefined
        ? undefined
        : args.supplyLimit instanceof BN
        ? args.supplyLimit
        : new BN(args.supplyLimit);
  }

  copy() {
    return new TokenIssuer(this.asObject());
  }

  asObject(): TokenIssuerArgsWithType {
    return {
      type: "tokenIssuer",
      url: this.url && this.url.toString(),
      authorities: this.authorities && this.authorities?.map((v) => v.asObject()),
      symbol: this.symbol && this.symbol,
      precision: this.precision && this.precision,
      properties: this.properties && this.properties.toString(),
      issued: this.issued && this.issued.toString(),
      supplyLimit: this.supplyLimit && this.supplyLimit.toString(),
    };
  }
}

export type TokenIssuerProofArgs = {
  transaction?: CreateToken | CreateTokenArgs;
  receipt?: merkle.Receipt | merkle.ReceiptArgs;
};
export class TokenIssuerProof {
  @encodeAs.field(1).reference
  public transaction?: CreateToken;
  @encodeAs.field(2).reference
  public receipt?: merkle.Receipt;

  constructor(args: TokenIssuerProofArgs) {
    this.transaction =
      args.transaction == undefined
        ? undefined
        : args.transaction instanceof CreateToken
        ? args.transaction
        : new CreateToken(args.transaction);
    this.receipt =
      args.receipt == undefined
        ? undefined
        : args.receipt instanceof merkle.Receipt
        ? args.receipt
        : new merkle.Receipt(args.receipt);
  }

  copy() {
    return new TokenIssuerProof(this.asObject());
  }

  asObject(): TokenIssuerProofArgs {
    return {
      transaction: this.transaction && this.transaction.asObject(),
      receipt: this.receipt && this.receipt.asObject(),
    };
  }
}

export type TokenRecipientArgs = {
  url?: URL | string;
  amount?: BN | string | number;
};
export class TokenRecipient {
  @encodeAs.field(1).url
  public url?: URL;
  @encodeAs.field(2).bigInt
  public amount?: BN;

  constructor(args: TokenRecipientArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.amount =
      args.amount == undefined
        ? undefined
        : args.amount instanceof BN
        ? args.amount
        : new BN(args.amount);
  }

  copy() {
    return new TokenRecipient(this.asObject());
  }

  asObject(): TokenRecipientArgs {
    return {
      url: this.url && this.url.toString(),
      amount: this.amount && this.amount.toString(),
    };
  }
}

export type TransactionArgs = {
  header?: TransactionHeader | TransactionHeaderArgs;
  body?: TransactionBody | TransactionBodyArgs;
};
export class Transaction extends TransactionBase {
  @encodeAs.field(1).reference
  public header?: TransactionHeader;
  @encodeAs.field(2).union
  public body?: TransactionBody;

  constructor(args: TransactionArgs) {
    super();
    this.header =
      args.header == undefined
        ? undefined
        : args.header instanceof TransactionHeader
        ? args.header
        : new TransactionHeader(args.header);
    this.body = args.body == undefined ? undefined : TransactionBody.fromObject(args.body);
  }

  copy() {
    return new Transaction(this.asObject());
  }

  asObject(): TransactionArgs {
    return {
      header: this.header && this.header.asObject(),
      body: this.body && this.body.asObject(),
    };
  }
}

export type TransactionHeaderArgs = {
  principal?: URL | string;
  initiator?: Uint8Array | string;
  memo?: string;
  metadata?: Uint8Array | string;
};
export class TransactionHeader {
  @encodeAs.field(1).url
  public principal?: URL;
  @encodeAs.field(2).hash
  public initiator?: Uint8Array;
  @encodeAs.field(3).string
  public memo?: string;
  @encodeAs.field(4).bytes
  public metadata?: Uint8Array;

  constructor(args: TransactionHeaderArgs) {
    this.principal =
      args.principal == undefined
        ? undefined
        : args.principal instanceof URL
        ? args.principal
        : new URL(args.principal);
    this.initiator =
      args.initiator == undefined
        ? undefined
        : args.initiator instanceof Uint8Array
        ? args.initiator
        : Buffer.from(args.initiator, "hex");
    this.memo = args.memo == undefined ? undefined : args.memo;
    this.metadata =
      args.metadata == undefined
        ? undefined
        : args.metadata instanceof Uint8Array
        ? args.metadata
        : Buffer.from(args.metadata, "hex");
  }

  copy() {
    return new TransactionHeader(this.asObject());
  }

  asObject(): TransactionHeaderArgs {
    return {
      principal: this.principal && this.principal.toString(),
      initiator: this.initiator && Buffer.from(this.initiator).toString("hex"),
      memo: this.memo && this.memo,
      metadata: this.metadata && Buffer.from(this.metadata).toString("hex"),
    };
  }
}

export type TransactionStatusArgs = {
  txID?: TxID | string;
  code?: errors2.StatusArgs;
  error?: errors2.Error | errors2.ErrorArgs;
  result?: TransactionResult | TransactionResultArgs;
  received?: number;
  initiator?: URL | string;
  signers?: (Signer | SignerArgs)[];
  sourceNetwork?: URL | string;
  destinationNetwork?: URL | string;
  sequenceNumber?: number;
  gotDirectoryReceipt?: boolean;
  proof?: merkle.Receipt | merkle.ReceiptArgs;
  anchorSigners?: (Uint8Array | string)[];
};
export class TransactionStatus {
  @encodeAs.field(1).txid
  public txID?: TxID;
  @encodeAs.field(2).enum
  public code?: errors2.Status;
  @encodeAs.field(3).reference
  public error?: errors2.Error;
  @encodeAs.field(4).union
  public result?: TransactionResult;
  @encodeAs.field(5).uint
  public received?: number;
  @encodeAs.field(6).url
  public initiator?: URL;
  @encodeAs.field(7).repeatable.union
  public signers?: Signer[];
  @encodeAs.field(8).url
  public sourceNetwork?: URL;
  @encodeAs.field(9).url
  public destinationNetwork?: URL;
  @encodeAs.field(10).uint
  public sequenceNumber?: number;
  @encodeAs.field(11).bool
  public gotDirectoryReceipt?: boolean;
  @encodeAs.field(12).reference
  public proof?: merkle.Receipt;
  @encodeAs.field(13).repeatable.bytes
  public anchorSigners?: Uint8Array[];

  constructor(args: TransactionStatusArgs) {
    this.txID =
      args.txID == undefined
        ? undefined
        : args.txID instanceof TxID
        ? args.txID
        : new TxID(args.txID);
    this.code = args.code == undefined ? undefined : errors2.Status.fromObject(args.code);
    this.error =
      args.error == undefined
        ? undefined
        : args.error instanceof errors2.Error
        ? args.error
        : new errors2.Error(args.error);
    this.result = args.result == undefined ? undefined : TransactionResult.fromObject(args.result);
    this.received = args.received == undefined ? undefined : args.received;
    this.initiator =
      args.initiator == undefined
        ? undefined
        : args.initiator instanceof URL
        ? args.initiator
        : new URL(args.initiator);
    this.signers =
      args.signers == undefined ? undefined : args.signers.map((v) => Signer.fromObject(v));
    this.sourceNetwork =
      args.sourceNetwork == undefined
        ? undefined
        : args.sourceNetwork instanceof URL
        ? args.sourceNetwork
        : new URL(args.sourceNetwork);
    this.destinationNetwork =
      args.destinationNetwork == undefined
        ? undefined
        : args.destinationNetwork instanceof URL
        ? args.destinationNetwork
        : new URL(args.destinationNetwork);
    this.sequenceNumber = args.sequenceNumber == undefined ? undefined : args.sequenceNumber;
    this.gotDirectoryReceipt =
      args.gotDirectoryReceipt == undefined ? undefined : args.gotDirectoryReceipt;
    this.proof =
      args.proof == undefined
        ? undefined
        : args.proof instanceof merkle.Receipt
        ? args.proof
        : new merkle.Receipt(args.proof);
    this.anchorSigners =
      args.anchorSigners == undefined
        ? undefined
        : args.anchorSigners.map((v) => (v instanceof Uint8Array ? v : Buffer.from(v, "hex")));
  }

  copy() {
    return new TransactionStatus(this.asObject());
  }

  asObject(): TransactionStatusArgs {
    return {
      txID: this.txID && this.txID.toString(),
      code: this.code && errors2.Status.getName(this.code),
      error: this.error && this.error.asObject(),
      result: this.result && this.result.asObject(),
      received: this.received && this.received,
      initiator: this.initiator && this.initiator.toString(),
      signers: this.signers && this.signers?.map((v) => v.asObject()),
      sourceNetwork: this.sourceNetwork && this.sourceNetwork.toString(),
      destinationNetwork: this.destinationNetwork && this.destinationNetwork.toString(),
      sequenceNumber: this.sequenceNumber && this.sequenceNumber,
      gotDirectoryReceipt: this.gotDirectoryReceipt && this.gotDirectoryReceipt,
      proof: this.proof && this.proof.asObject(),
      anchorSigners:
        this.anchorSigners && this.anchorSigners?.map((v) => Buffer.from(v).toString("hex")),
    };
  }
}

export type TransferCreditsArgs = {
  to?: (CreditRecipient | CreditRecipientArgs)[];
};
export type TransferCreditsArgsWithType = TransferCreditsArgs & {
  type: TransactionType.TransferCredits | "transferCredits";
};
export class TransferCredits {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.TransferCredits;
  @encodeAs.field(2).repeatable.reference
  public to?: CreditRecipient[];

  constructor(args: TransferCreditsArgs) {
    this.to =
      args.to == undefined
        ? undefined
        : args.to.map((v) => (v instanceof CreditRecipient ? v : new CreditRecipient(v)));
  }

  copy() {
    return new TransferCredits(this.asObject());
  }

  asObject(): TransferCreditsArgsWithType {
    return {
      type: "transferCredits",
      to: this.to && this.to?.map((v) => v.asObject()),
    };
  }
}

export type TxIdSetArgs = {
  entries?: (TxID | string)[];
};
export class TxIdSet {
  @encodeAs.field(1).repeatable.txid
  public entries?: TxID[];

  constructor(args: TxIdSetArgs) {
    this.entries =
      args.entries == undefined
        ? undefined
        : args.entries.map((v) => (v instanceof TxID ? v : new TxID(v)));
  }

  copy() {
    return new TxIdSet(this.asObject());
  }

  asObject(): TxIdSetArgs {
    return {
      entries: this.entries && this.entries?.map((v) => v.toString()),
    };
  }
}

export type UnknownAccountArgs = {
  url?: URL | string;
};
export type UnknownAccountArgsWithType = UnknownAccountArgs & {
  type: AccountType.Unknown | "unknown";
};
export class UnknownAccount {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountType.Unknown;
  @encodeAs.field(2).url
  public url?: URL;

  constructor(args: UnknownAccountArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
  }

  copy() {
    return new UnknownAccount(this.asObject());
  }

  asObject(): UnknownAccountArgsWithType {
    return {
      type: "unknown",
      url: this.url && this.url.toString(),
    };
  }
}

export type UnknownSignerArgs = {
  url?: URL | string;
  version?: number;
};
export type UnknownSignerArgsWithType = UnknownSignerArgs & {
  type: AccountType.UnknownSigner | "unknownSigner";
};
export class UnknownSigner {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = AccountType.UnknownSigner;
  @encodeAs.field(2).url
  public url?: URL;
  @encodeAs.field(3).uint
  public version?: number;

  constructor(args: UnknownSignerArgs) {
    this.url =
      args.url == undefined ? undefined : args.url instanceof URL ? args.url : new URL(args.url);
    this.version = args.version == undefined ? undefined : args.version;
  }

  copy() {
    return new UnknownSigner(this.asObject());
  }

  asObject(): UnknownSignerArgsWithType {
    return {
      type: "unknownSigner",
      url: this.url && this.url.toString(),
      version: this.version && this.version,
    };
  }
}

export type UpdateAccountAuthArgs = {
  operations?: (AccountAuthOperation | AccountAuthOperationArgs)[];
};
export type UpdateAccountAuthArgsWithType = UpdateAccountAuthArgs & {
  type: TransactionType.UpdateAccountAuth | "updateAccountAuth";
};
export class UpdateAccountAuth {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.UpdateAccountAuth;
  @encodeAs.field(2).repeatable.union
  public operations?: AccountAuthOperation[];

  constructor(args: UpdateAccountAuthArgs) {
    this.operations =
      args.operations == undefined
        ? undefined
        : args.operations.map((v) => AccountAuthOperation.fromObject(v));
  }

  copy() {
    return new UpdateAccountAuth(this.asObject());
  }

  asObject(): UpdateAccountAuthArgsWithType {
    return {
      type: "updateAccountAuth",
      operations: this.operations && this.operations?.map((v) => v.asObject()),
    };
  }
}

export type UpdateAllowedKeyPageOperationArgs = {
  allow?: TransactionTypeArgs[];
  deny?: TransactionTypeArgs[];
};
export type UpdateAllowedKeyPageOperationArgsWithType = UpdateAllowedKeyPageOperationArgs & {
  type: KeyPageOperationType.UpdateAllowed | "updateAllowed";
};
export class UpdateAllowedKeyPageOperation {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = KeyPageOperationType.UpdateAllowed;
  @encodeAs.field(2).repeatable.enum
  public allow?: TransactionType[];
  @encodeAs.field(3).repeatable.enum
  public deny?: TransactionType[];

  constructor(args: UpdateAllowedKeyPageOperationArgs) {
    this.allow =
      args.allow == undefined ? undefined : args.allow.map((v) => TransactionType.fromObject(v));
    this.deny =
      args.deny == undefined ? undefined : args.deny.map((v) => TransactionType.fromObject(v));
  }

  copy() {
    return new UpdateAllowedKeyPageOperation(this.asObject());
  }

  asObject(): UpdateAllowedKeyPageOperationArgsWithType {
    return {
      type: "updateAllowed",
      allow: this.allow && this.allow?.map((v) => TransactionType.getName(v)),
      deny: this.deny && this.deny?.map((v) => TransactionType.getName(v)),
    };
  }
}

export type UpdateKeyArgs = {
  newKeyHash?: Uint8Array | string;
};
export type UpdateKeyArgsWithType = UpdateKeyArgs & {
  type: TransactionType.UpdateKey | "updateKey";
};
export class UpdateKey {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.UpdateKey;
  @encodeAs.field(2).bytes
  public newKeyHash?: Uint8Array;

  constructor(args: UpdateKeyArgs) {
    this.newKeyHash =
      args.newKeyHash == undefined
        ? undefined
        : args.newKeyHash instanceof Uint8Array
        ? args.newKeyHash
        : Buffer.from(args.newKeyHash, "hex");
  }

  copy() {
    return new UpdateKey(this.asObject());
  }

  asObject(): UpdateKeyArgsWithType {
    return {
      type: "updateKey",
      newKeyHash: this.newKeyHash && Buffer.from(this.newKeyHash).toString("hex"),
    };
  }
}

export type UpdateKeyOperationArgs = {
  oldEntry?: KeySpecParams | KeySpecParamsArgs;
  newEntry?: KeySpecParams | KeySpecParamsArgs;
};
export type UpdateKeyOperationArgsWithType = UpdateKeyOperationArgs & {
  type: KeyPageOperationType.Update | "update";
};
export class UpdateKeyOperation {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = KeyPageOperationType.Update;
  @encodeAs.field(2).reference
  public oldEntry?: KeySpecParams;
  @encodeAs.field(3).reference
  public newEntry?: KeySpecParams;

  constructor(args: UpdateKeyOperationArgs) {
    this.oldEntry =
      args.oldEntry == undefined
        ? undefined
        : args.oldEntry instanceof KeySpecParams
        ? args.oldEntry
        : new KeySpecParams(args.oldEntry);
    this.newEntry =
      args.newEntry == undefined
        ? undefined
        : args.newEntry instanceof KeySpecParams
        ? args.newEntry
        : new KeySpecParams(args.newEntry);
  }

  copy() {
    return new UpdateKeyOperation(this.asObject());
  }

  asObject(): UpdateKeyOperationArgsWithType {
    return {
      type: "update",
      oldEntry: this.oldEntry && this.oldEntry.asObject(),
      newEntry: this.newEntry && this.newEntry.asObject(),
    };
  }
}

export type UpdateKeyPageArgs = {
  operation?: (KeyPageOperation | KeyPageOperationArgs)[];
};
export type UpdateKeyPageArgsWithType = UpdateKeyPageArgs & {
  type: TransactionType.UpdateKeyPage | "updateKeyPage";
};
export class UpdateKeyPage {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.UpdateKeyPage;
  @encodeAs.field(2).repeatable.union
  public operation?: KeyPageOperation[];

  constructor(args: UpdateKeyPageArgs) {
    this.operation =
      args.operation == undefined
        ? undefined
        : args.operation.map((v) => KeyPageOperation.fromObject(v));
  }

  copy() {
    return new UpdateKeyPage(this.asObject());
  }

  asObject(): UpdateKeyPageArgsWithType {
    return {
      type: "updateKeyPage",
      operation: this.operation && this.operation?.map((v) => v.asObject()),
    };
  }
}

export type ValidatorInfoArgs = {
  publicKey?: Uint8Array | string;
  publicKeyHash?: Uint8Array | string;
  operator?: URL | string;
  partitions?: (ValidatorPartitionInfo | ValidatorPartitionInfoArgs)[];
};
export class ValidatorInfo {
  @encodeAs.field(1).bytes
  public publicKey?: Uint8Array;
  @encodeAs.field(2).hash
  public publicKeyHash?: Uint8Array;
  @encodeAs.field(3).url
  public operator?: URL;
  @encodeAs.field(4).repeatable.reference
  public partitions?: ValidatorPartitionInfo[];

  constructor(args: ValidatorInfoArgs) {
    this.publicKey =
      args.publicKey == undefined
        ? undefined
        : args.publicKey instanceof Uint8Array
        ? args.publicKey
        : Buffer.from(args.publicKey, "hex");
    this.publicKeyHash =
      args.publicKeyHash == undefined
        ? undefined
        : args.publicKeyHash instanceof Uint8Array
        ? args.publicKeyHash
        : Buffer.from(args.publicKeyHash, "hex");
    this.operator =
      args.operator == undefined
        ? undefined
        : args.operator instanceof URL
        ? args.operator
        : new URL(args.operator);
    this.partitions =
      args.partitions == undefined
        ? undefined
        : args.partitions.map((v) =>
            v instanceof ValidatorPartitionInfo ? v : new ValidatorPartitionInfo(v)
          );
  }

  copy() {
    return new ValidatorInfo(this.asObject());
  }

  asObject(): ValidatorInfoArgs {
    return {
      publicKey: this.publicKey && Buffer.from(this.publicKey).toString("hex"),
      publicKeyHash: this.publicKeyHash && Buffer.from(this.publicKeyHash).toString("hex"),
      operator: this.operator && this.operator.toString(),
      partitions: this.partitions && this.partitions?.map((v) => v.asObject()),
    };
  }
}

export type ValidatorPartitionInfoArgs = {
  id?: string;
  active?: boolean;
};
export class ValidatorPartitionInfo {
  @encodeAs.field(1).string
  public id?: string;
  @encodeAs.field(2).keepEmpty.bool
  public active?: boolean;

  constructor(args: ValidatorPartitionInfoArgs) {
    this.id = args.id == undefined ? undefined : args.id;
    this.active = args.active == undefined ? undefined : args.active;
  }

  copy() {
    return new ValidatorPartitionInfo(this.asObject());
  }

  asObject(): ValidatorPartitionInfoArgs {
    return {
      id: this.id && this.id,
      active: this.active && this.active,
    };
  }
}

export type WriteDataArgs = {
  entry?: DataEntry | DataEntryArgs;
  scratch?: boolean;
  writeToState?: boolean;
};
export type WriteDataArgsWithType = WriteDataArgs & {
  type: TransactionType.WriteData | "writeData";
};
export class WriteData {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.WriteData;
  @encodeAs.field(2).union
  public entry?: DataEntry;
  @encodeAs.field(3).bool
  public scratch?: boolean;
  @encodeAs.field(4).bool
  public writeToState?: boolean;

  constructor(args: WriteDataArgs) {
    this.entry = args.entry == undefined ? undefined : DataEntry.fromObject(args.entry);
    this.scratch = args.scratch == undefined ? undefined : args.scratch;
    this.writeToState = args.writeToState == undefined ? undefined : args.writeToState;
  }

  copy() {
    return new WriteData(this.asObject());
  }

  asObject(): WriteDataArgsWithType {
    return {
      type: "writeData",
      entry: this.entry && this.entry.asObject(),
      scratch: this.scratch && this.scratch,
      writeToState: this.writeToState && this.writeToState,
    };
  }
}

export type WriteDataResultArgs = {
  entryHash?: Uint8Array | string;
  accountUrl?: URL | string;
  accountID?: Uint8Array | string;
};
export type WriteDataResultArgsWithType = WriteDataResultArgs & {
  type: TransactionType.WriteData | "writeData";
};
export class WriteDataResult {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.WriteData;
  @encodeAs.field(2).hash
  public entryHash?: Uint8Array;
  @encodeAs.field(3).url
  public accountUrl?: URL;
  @encodeAs.field(4).bytes
  public accountID?: Uint8Array;

  constructor(args: WriteDataResultArgs) {
    this.entryHash =
      args.entryHash == undefined
        ? undefined
        : args.entryHash instanceof Uint8Array
        ? args.entryHash
        : Buffer.from(args.entryHash, "hex");
    this.accountUrl =
      args.accountUrl == undefined
        ? undefined
        : args.accountUrl instanceof URL
        ? args.accountUrl
        : new URL(args.accountUrl);
    this.accountID =
      args.accountID == undefined
        ? undefined
        : args.accountID instanceof Uint8Array
        ? args.accountID
        : Buffer.from(args.accountID, "hex");
  }

  copy() {
    return new WriteDataResult(this.asObject());
  }

  asObject(): WriteDataResultArgsWithType {
    return {
      type: "writeData",
      entryHash: this.entryHash && Buffer.from(this.entryHash).toString("hex"),
      accountUrl: this.accountUrl && this.accountUrl.toString(),
      accountID: this.accountID && Buffer.from(this.accountID).toString("hex"),
    };
  }
}

export type WriteDataToArgs = {
  recipient?: URL | string;
  entry?: DataEntry | DataEntryArgs;
};
export type WriteDataToArgsWithType = WriteDataToArgs & {
  type: TransactionType.WriteDataTo | "writeDataTo";
};
export class WriteDataTo {
  @encodeAs.field(1).keepEmpty.enum
  public readonly type = TransactionType.WriteDataTo;
  @encodeAs.field(2).url
  public recipient?: URL;
  @encodeAs.field(3).union
  public entry?: DataEntry;

  constructor(args: WriteDataToArgs) {
    this.recipient =
      args.recipient == undefined
        ? undefined
        : args.recipient instanceof URL
        ? args.recipient
        : new URL(args.recipient);
    this.entry = args.entry == undefined ? undefined : DataEntry.fromObject(args.entry);
  }

  copy() {
    return new WriteDataTo(this.asObject());
  }

  asObject(): WriteDataToArgsWithType {
    return {
      type: "writeDataTo",
      recipient: this.recipient && this.recipient.toString(),
      entry: this.entry && this.entry.asObject(),
    };
  }
}
