// DO NOT EDIT. Generated by gitlab.com/accumulatenetwork/accumulate/tools/cmd/gen-types.

/* eslint-disable @typescript-eslint/no-namespace */

export enum AccountAuthOperationType {
  /** Unknown is used when the authorization operation is not known. */
  Unknown = 0,
  /** Enable enables authorization checks for an authority. */
  Enable = 1,
  /** Disable disables authorization checks for an authority. */
  Disable = 2,
  /** AddAuthority adds an authority. */
  AddAuthority = 3,
  /** RemoveAuthority removes an authority. */
  RemoveAuthority = 4,
}

export type AccountAuthOperationTypeArgs = AccountAuthOperationType | string;

/** @ignore */
export namespace AccountAuthOperationType {
  export function fromObject(obj: AccountAuthOperationTypeArgs): AccountAuthOperationType {
    if (typeof obj === "number") return obj;
    return byName(obj);
  }

  export function byName(name: string): AccountAuthOperationType {
    switch (name) {
      case "unknown":
        return AccountAuthOperationType.Unknown;
      case "enable":
        return AccountAuthOperationType.Enable;
      case "disable":
        return AccountAuthOperationType.Disable;
      case "addauthority":
        return AccountAuthOperationType.AddAuthority;
      case "removeauthority":
        return AccountAuthOperationType.RemoveAuthority;
      default:
        throw new Error(`Unknown AccountAuthOperationType '${name}'`);
    }
  }

  export function getName(v: AccountAuthOperationType) {
    switch (v) {
      case AccountAuthOperationType.Unknown:
        return "unknown";
      case AccountAuthOperationType.Enable:
        return "enable";
      case AccountAuthOperationType.Disable:
        return "disable";
      case AccountAuthOperationType.AddAuthority:
        return "addAuthority";
      case AccountAuthOperationType.RemoveAuthority:
        return "removeAuthority";
      default:
        throw new Error(`Unknown AccountAuthOperationType ${v}`);
    }
  }
}

export enum AccountType {
  /** Unknown represents an unknown account type. */
  Unknown = 0,
  /** AnchorLedger anchors the other partitions. */
  AnchorLedger = 1,
  /** Identity is an Identity account, aka an ADI. */
  Identity = 2,
  /** TokenIssuer is a Token Issuer account. */
  TokenIssuer = 3,
  /** TokenAccount is an ADI Token Account. */
  TokenAccount = 4,
  /** LiteTokenAccount is a Lite Token Account. */
  LiteTokenAccount = 5,
  /** BlockLedger is a Block Ledger account. */
  BlockLedger = 6,
  /** KeyPage is a Key Page account. */
  KeyPage = 9,
  /** KeyBook is a Key Book account. */
  KeyBook = 10,
  /** DataAccount is an ADI Data Account. */
  DataAccount = 11,
  /** LiteDataAccount is a Lite Data Account. */
  LiteDataAccount = 12,
  /** UnknownSigner represents an unknown signer account. */
  UnknownSigner = 13,
  /** SystemLedger is a ledger that tracks the state of internal operations. */
  SystemLedger = 14,
  /** LiteIdentity is a lite identity account. */
  LiteIdentity = 15,
  /** SyntheticLedger is a ledger that tracks the status of produced and received synthetic transactions. */
  SyntheticLedger = 16,
}

export type AccountTypeArgs = AccountType | string;

/** @ignore */
export namespace AccountType {
  export function fromObject(obj: AccountTypeArgs): AccountType {
    if (typeof obj === "number") return obj;
    return byName(obj);
  }

  export function byName(name: string): AccountType {
    switch (name) {
      case "unknown":
        return AccountType.Unknown;
      case "anchorledger":
        return AccountType.AnchorLedger;
      case "identity":
        return AccountType.Identity;
      case "tokenissuer":
        return AccountType.TokenIssuer;
      case "token":
        return AccountType.TokenIssuer;
      case "tokenaccount":
        return AccountType.TokenAccount;
      case "litetokenaccount":
        return AccountType.LiteTokenAccount;
      case "blockledger":
        return AccountType.BlockLedger;
      case "keypage":
        return AccountType.KeyPage;
      case "keybook":
        return AccountType.KeyBook;
      case "dataaccount":
        return AccountType.DataAccount;
      case "litedataaccount":
        return AccountType.LiteDataAccount;
      case "unknownsigner":
        return AccountType.UnknownSigner;
      case "systemledger":
        return AccountType.SystemLedger;
      case "liteidentity":
        return AccountType.LiteIdentity;
      case "syntheticledger":
        return AccountType.SyntheticLedger;
      default:
        throw new Error(`Unknown AccountType '${name}'`);
    }
  }

  export function getName(v: AccountType) {
    switch (v) {
      case AccountType.Unknown:
        return "unknown";
      case AccountType.AnchorLedger:
        return "anchorLedger";
      case AccountType.Identity:
        return "identity";
      case AccountType.TokenIssuer:
        return "tokenIssuer";
      case AccountType.TokenAccount:
        return "tokenAccount";
      case AccountType.LiteTokenAccount:
        return "liteTokenAccount";
      case AccountType.BlockLedger:
        return "blockLedger";
      case AccountType.KeyPage:
        return "keyPage";
      case AccountType.KeyBook:
        return "keyBook";
      case AccountType.DataAccount:
        return "dataAccount";
      case AccountType.LiteDataAccount:
        return "liteDataAccount";
      case AccountType.UnknownSigner:
        return "unknownSigner";
      case AccountType.SystemLedger:
        return "systemLedger";
      case AccountType.LiteIdentity:
        return "liteIdentity";
      case AccountType.SyntheticLedger:
        return "syntheticLedger";
      default:
        throw new Error(`Unknown AccountType ${v}`);
    }
  }
}

export enum AllowedTransactionBit {
  /** UpdateKeyPage is the offset of the UpdateKeyPage bit. */
  UpdateKeyPage = 1,
  /** UpdateAccountAuth is the offset of the UpdateAccountAuth bit. */
  UpdateAccountAuth = 2,
}

export type AllowedTransactionBitArgs = AllowedTransactionBit | string;

/** @ignore */
export namespace AllowedTransactionBit {
  export function fromObject(obj: AllowedTransactionBitArgs): AllowedTransactionBit {
    if (typeof obj === "number") return obj;
    return byName(obj);
  }

  export function byName(name: string): AllowedTransactionBit {
    switch (name) {
      case "updatekeypage":
        return AllowedTransactionBit.UpdateKeyPage;
      case "updateaccountauth":
        return AllowedTransactionBit.UpdateAccountAuth;
      default:
        throw new Error(`Unknown AllowedTransactionBit '${name}'`);
    }
  }

  export function getName(v: AllowedTransactionBit) {
    switch (v) {
      case AllowedTransactionBit.UpdateKeyPage:
        return "updateKeyPage";
      case AllowedTransactionBit.UpdateAccountAuth:
        return "updateAccountAuth";
      default:
        throw new Error(`Unknown AllowedTransactionBit ${v}`);
    }
  }
}

export enum BookType {
  /** Normal is a normal key book. */
  Normal = 0,
  /** Validator is a validator key book. */
  Validator = 1,
  /** Operator Operator key book. */
  Operator = 2,
}

export type BookTypeArgs = BookType | string;

/** @ignore */
export namespace BookType {
  export function fromObject(obj: BookTypeArgs): BookType {
    if (typeof obj === "number") return obj;
    return byName(obj);
  }

  export function byName(name: string): BookType {
    switch (name) {
      case "normal":
        return BookType.Normal;
      case "validator":
        return BookType.Validator;
      case "operator":
        return BookType.Operator;
      default:
        throw new Error(`Unknown BookType '${name}'`);
    }
  }

  export function getName(v: BookType) {
    switch (v) {
      case BookType.Normal:
        return "normal";
      case BookType.Validator:
        return "validator";
      case BookType.Operator:
        return "operator";
      default:
        throw new Error(`Unknown BookType ${v}`);
    }
  }
}

export enum DataEntryType {
  /** Unknown . */
  Unknown = 0,
  /** Factom . */
  Factom = 1,
  /** Accumulate . */
  Accumulate = 2,
  /** DoubleHash . */
  DoubleHash = 3,
}

export type DataEntryTypeArgs = DataEntryType | string;

/** @ignore */
export namespace DataEntryType {
  export function fromObject(obj: DataEntryTypeArgs): DataEntryType {
    if (typeof obj === "number") return obj;
    return byName(obj);
  }

  export function byName(name: string): DataEntryType {
    switch (name) {
      case "unknown":
        return DataEntryType.Unknown;
      case "factom":
        return DataEntryType.Factom;
      case "accumulate":
        return DataEntryType.Accumulate;
      case "doublehash":
        return DataEntryType.DoubleHash;
      default:
        throw new Error(`Unknown DataEntryType '${name}'`);
    }
  }

  export function getName(v: DataEntryType) {
    switch (v) {
      case DataEntryType.Unknown:
        return "unknown";
      case DataEntryType.Factom:
        return "factom";
      case DataEntryType.Accumulate:
        return "accumulate";
      case DataEntryType.DoubleHash:
        return "doubleHash";
      default:
        throw new Error(`Unknown DataEntryType ${v}`);
    }
  }
}

export enum ExecutorVersion {
  /** V1 is the first version of the executor system. */
  V1 = 1,
  /** V1SignatureAnchoring introduces anchoring of signature chains into the root chain. */
  V1SignatureAnchoring = 2,
  /** V1DoubleHashEntries fixes a problem that prevented v1-signatureAnchoring from being activated correctly and enables double-hashed data entries. */
  V1DoubleHashEntries = 3,
  /** V1Halt halts transaction processing in preparation for v2. */
  V1Halt = 4,
  /** V2 is the second version of the executor system. */
  V2 = 5,
}

export type ExecutorVersionArgs = ExecutorVersion | string;

/** @ignore */
export namespace ExecutorVersion {
  export function fromObject(obj: ExecutorVersionArgs): ExecutorVersion {
    if (typeof obj === "number") return obj;
    return byName(obj);
  }

  export function byName(name: string): ExecutorVersion {
    switch (name) {
      case "v1":
        return ExecutorVersion.V1;
      case "v1signatureanchoring":
        return ExecutorVersion.V1SignatureAnchoring;
      case "v1doublehashentries":
        return ExecutorVersion.V1DoubleHashEntries;
      case "v1halt":
        return ExecutorVersion.V1Halt;
      case "v2":
        return ExecutorVersion.V2;
      default:
        throw new Error(`Unknown ExecutorVersion '${name}'`);
    }
  }

  export function getName(v: ExecutorVersion) {
    switch (v) {
      case ExecutorVersion.V1:
        return "v1";
      case ExecutorVersion.V1SignatureAnchoring:
        return "v1SignatureAnchoring";
      case ExecutorVersion.V1DoubleHashEntries:
        return "v1DoubleHashEntries";
      case ExecutorVersion.V1Halt:
        return "v1Halt";
      case ExecutorVersion.V2:
        return "v2";
      default:
        throw new Error(`Unknown ExecutorVersion ${v}`);
    }
  }
}

export enum KeyPageOperationType {
  /** Unknown is used when the key page operation is not known. */
  Unknown = 0,
  /** Update replaces a key in the page with a new key. */
  Update = 1,
  /** Remove removes a key from the page. */
  Remove = 2,
  /** Add adds a key to the page. */
  Add = 3,
  /** SetThreshold sets the signing threshold (the M of "M of N" signatures required). */
  SetThreshold = 4,
  /** UpdateAllowed updates the transactions the key page is allowed to execute. */
  UpdateAllowed = 5,
}

export type KeyPageOperationTypeArgs = KeyPageOperationType | string;

/** @ignore */
export namespace KeyPageOperationType {
  export function fromObject(obj: KeyPageOperationTypeArgs): KeyPageOperationType {
    if (typeof obj === "number") return obj;
    return byName(obj);
  }

  export function byName(name: string): KeyPageOperationType {
    switch (name) {
      case "unknown":
        return KeyPageOperationType.Unknown;
      case "update":
        return KeyPageOperationType.Update;
      case "remove":
        return KeyPageOperationType.Remove;
      case "add":
        return KeyPageOperationType.Add;
      case "setthreshold":
        return KeyPageOperationType.SetThreshold;
      case "updateallowed":
        return KeyPageOperationType.UpdateAllowed;
      default:
        throw new Error(`Unknown KeyPageOperationType '${name}'`);
    }
  }

  export function getName(v: KeyPageOperationType) {
    switch (v) {
      case KeyPageOperationType.Unknown:
        return "unknown";
      case KeyPageOperationType.Update:
        return "update";
      case KeyPageOperationType.Remove:
        return "remove";
      case KeyPageOperationType.Add:
        return "add";
      case KeyPageOperationType.SetThreshold:
        return "setThreshold";
      case KeyPageOperationType.UpdateAllowed:
        return "updateAllowed";
      default:
        throw new Error(`Unknown KeyPageOperationType ${v}`);
    }
  }
}

export enum ObjectType {
  /** Unknown is used when the object type is not known. */
  Unknown = 0,
  /** Account represents an account object. */
  Account = 1,
  /** Transaction represents a transaction object. */
  Transaction = 2,
}

export type ObjectTypeArgs = ObjectType | string;

/** @ignore */
export namespace ObjectType {
  export function fromObject(obj: ObjectTypeArgs): ObjectType {
    if (typeof obj === "number") return obj;
    return byName(obj);
  }

  export function byName(name: string): ObjectType {
    switch (name) {
      case "unknown":
        return ObjectType.Unknown;
      case "account":
        return ObjectType.Account;
      case "transaction":
        return ObjectType.Transaction;
      default:
        throw new Error(`Unknown ObjectType '${name}'`);
    }
  }

  export function getName(v: ObjectType) {
    switch (v) {
      case ObjectType.Unknown:
        return "unknown";
      case ObjectType.Account:
        return "account";
      case ObjectType.Transaction:
        return "transaction";
      default:
        throw new Error(`Unknown ObjectType ${v}`);
    }
  }
}

export enum PartitionType {
  /** Directory . */
  Directory = 1,
  /** BlockValidator . */
  BlockValidator = 2,
  /** BlockSummary . */
  BlockSummary = 3,
}

export type PartitionTypeArgs = PartitionType | string;

/** @ignore */
export namespace PartitionType {
  export function fromObject(obj: PartitionTypeArgs): PartitionType {
    if (typeof obj === "number") return obj;
    return byName(obj);
  }

  export function byName(name: string): PartitionType {
    switch (name) {
      case "directory":
        return PartitionType.Directory;
      case "blockvalidator":
        return PartitionType.BlockValidator;
      case "block-validator":
        return PartitionType.BlockValidator;
      case "blocksummary":
        return PartitionType.BlockSummary;
      case "block-summary":
        return PartitionType.BlockSummary;
      default:
        throw new Error(`Unknown PartitionType '${name}'`);
    }
  }

  export function getName(v: PartitionType) {
    switch (v) {
      case PartitionType.Directory:
        return "directory";
      case PartitionType.BlockValidator:
        return "blockValidator";
      case PartitionType.BlockSummary:
        return "blockSummary";
      default:
        throw new Error(`Unknown PartitionType ${v}`);
    }
  }
}

export enum SignatureType {
  /** Unknown is used when the signature type is not known. */
  Unknown = 0,
  /** LegacyED25519 represents a legacy ED25519 signature. */
  LegacyED25519 = 1,
  /** ED25519 represents an ED25519 signature. */
  ED25519 = 2,
  /** RCD1 represents an RCD1 signature. */
  RCD1 = 3,
  /** Receipt represents a Merkle tree receipt. */
  Receipt = 4,
  /** Partition is used when sending synthetic and system transactions. */
  Partition = 5,
  /** Set is used when forwarding multiple signatures. */
  Set = 6,
  /** Remote is used when forwarding a signature from one partition to another. */
  Remote = 7,
  /** BTC represents an BTC signature. */
  BTC = 8,
  /** BTCLegacy represents an BTC signature with uncompressed public key. */
  BTCLegacy = 9,
  /** ETH represents an ETH signature. */
  ETH = 10,
  /** Delegated represents a signature for a delegated authority. */
  Delegated = 11,
  /** Internal is used for internally produced transactions. */
  Internal = 12,
  /** Authority is a signature produced by an authority. */
  Authority = 13,
}

export type SignatureTypeArgs = SignatureType | string;

/** @ignore */
export namespace SignatureType {
  export function fromObject(obj: SignatureTypeArgs): SignatureType {
    if (typeof obj === "number") return obj;
    return byName(obj);
  }

  export function byName(name: string): SignatureType {
    switch (name) {
      case "unknown":
        return SignatureType.Unknown;
      case "legacyed25519":
        return SignatureType.LegacyED25519;
      case "ed25519":
        return SignatureType.ED25519;
      case "rcd1":
        return SignatureType.RCD1;
      case "receipt":
        return SignatureType.Receipt;
      case "partition":
        return SignatureType.Partition;
      case "synthetic":
        return SignatureType.Partition;
      case "set":
        return SignatureType.Set;
      case "remote":
        return SignatureType.Remote;
      case "btc":
        return SignatureType.BTC;
      case "btclegacy":
        return SignatureType.BTCLegacy;
      case "eth":
        return SignatureType.ETH;
      case "delegated":
        return SignatureType.Delegated;
      case "internal":
        return SignatureType.Internal;
      case "authority":
        return SignatureType.Authority;
      default:
        throw new Error(`Unknown SignatureType '${name}'`);
    }
  }

  export function getName(v: SignatureType) {
    switch (v) {
      case SignatureType.Unknown:
        return "unknown";
      case SignatureType.LegacyED25519:
        return "legacyED25519";
      case SignatureType.ED25519:
        return "ed25519";
      case SignatureType.RCD1:
        return "rcd1";
      case SignatureType.Receipt:
        return "receipt";
      case SignatureType.Partition:
        return "partition";
      case SignatureType.Set:
        return "set";
      case SignatureType.Remote:
        return "remote";
      case SignatureType.BTC:
        return "btc";
      case SignatureType.BTCLegacy:
        return "btclegacy";
      case SignatureType.ETH:
        return "eth";
      case SignatureType.Delegated:
        return "delegated";
      case SignatureType.Internal:
        return "internal";
      case SignatureType.Authority:
        return "authority";
      default:
        throw new Error(`Unknown SignatureType ${v}`);
    }
  }
}

export enum TransactionMax {
  /** User is the highest number reserved for user transactions. */
  User = 48,
  /** Synthetic is the highest number reserved for synthetic transactions. */
  Synthetic = 95,
  /** System is the highest number reserved for internal transactions. */
  System = 255,
}

export type TransactionMaxArgs = TransactionMax | string;

/** @ignore */
export namespace TransactionMax {
  export function fromObject(obj: TransactionMaxArgs): TransactionMax {
    if (typeof obj === "number") return obj;
    return byName(obj);
  }

  export function byName(name: string): TransactionMax {
    switch (name) {
      case "user":
        return TransactionMax.User;
      case "synthetic":
        return TransactionMax.Synthetic;
      case "system":
        return TransactionMax.System;
      default:
        throw new Error(`Unknown TransactionMax '${name}'`);
    }
  }

  export function getName(v: TransactionMax) {
    switch (v) {
      case TransactionMax.User:
        return "user";
      case TransactionMax.Synthetic:
        return "synthetic";
      case TransactionMax.System:
        return "system";
      default:
        throw new Error(`Unknown TransactionMax ${v}`);
    }
  }
}

export enum TransactionType {
  /** Unknown represents an unknown transaction type. */
  Unknown = 0,
  /** CreateIdentity creates an ADI, which produces a synthetic chain. */
  CreateIdentity = 1,
  /** CreateTokenAccount creates an ADI token account, which produces a synthetic chain create transaction. */
  CreateTokenAccount = 2,
  /** SendTokens transfers tokens between token accounts, which produces a synthetic deposit tokens transaction. */
  SendTokens = 3,
  /** CreateDataAccount creates an ADI Data Account, which produces a synthetic chain create transaction. */
  CreateDataAccount = 4,
  /** WriteData writes data to an ADI Data Account, which *does not* produce a synthetic transaction. */
  WriteData = 5,
  /** WriteDataTo writes data to a Lite Data Account, which produces a synthetic write data transaction. */
  WriteDataTo = 6,
  /** AcmeFaucet produces a synthetic deposit tokens transaction that deposits ACME tokens into a lite token account. */
  AcmeFaucet = 7,
  /** CreateToken creates a token issuer, which produces a synthetic chain create transaction. */
  CreateToken = 8,
  /** IssueTokens issues tokens to a token account, which produces a synthetic token deposit transaction. */
  IssueTokens = 9,
  /** BurnTokens burns tokens from a token account, which produces a synthetic burn tokens transaction. */
  BurnTokens = 10,
  /** CreateLiteTokenAccount create a lite token account. */
  CreateLiteTokenAccount = 11,
  /** CreateKeyPage creates a key page, which produces a synthetic chain create transaction. */
  CreateKeyPage = 12,
  /** CreateKeyBook creates a key book, which produces a synthetic chain create transaction. */
  CreateKeyBook = 13,
  /** AddCredits converts ACME tokens to credits, which produces a synthetic deposit credits transaction. */
  AddCredits = 14,
  /** UpdateKeyPage adds, removes, or updates keys in a key page, which *does not* produce a synthetic transaction. */
  UpdateKeyPage = 15,
  /** LockAccount sets a major block height that prevents tokens from being transferred out of a lite token account until that height has been reached. */
  LockAccount = 16,
  /** BurnCredits burns credits from a credit account. */
  BurnCredits = 17,
  /** TransferCredits transfers credits between credit accounts within the same domain. */
  TransferCredits = 18,
  /** UpdateAccountAuth updates authorization for an account. */
  UpdateAccountAuth = 21,
  /** UpdateKey update key for existing keys. */
  UpdateKey = 22,
  /** ActivateProtocolVersion activates a new version of the protocol. */
  ActivateProtocolVersion = 47,
  /** Remote is used to sign a remote transaction. */
  Remote = 48,
  /** SyntheticCreateIdentity creates an identity. */
  SyntheticCreateIdentity = 49,
  /** SyntheticWriteData writes data to a data account. */
  SyntheticWriteData = 50,
  /** SyntheticDepositTokens deposits tokens into token accounts. */
  SyntheticDepositTokens = 51,
  /** SyntheticDepositCredits deposits credits into a credit holder. */
  SyntheticDepositCredits = 52,
  /** SyntheticBurnTokens returns tokens to a token issuer's pool of issuable tokens. */
  SyntheticBurnTokens = 53,
  /** SyntheticForwardTransaction forwards a transaction from one partition to another. */
  SyntheticForwardTransaction = 54,
  /** SystemGenesis initializes system chains. */
  SystemGenesis = 96,
  /** DirectoryAnchor anchors one network to another. */
  DirectoryAnchor = 97,
  /** BlockValidatorAnchor system transaction for partition data. */
  BlockValidatorAnchor = 98,
  /** SystemWriteData writes data to a system data account. */
  SystemWriteData = 99,
}

export type TransactionTypeArgs = TransactionType | string;

/** @ignore */
export namespace TransactionType {
  export function fromObject(obj: TransactionTypeArgs): TransactionType {
    if (typeof obj === "number") return obj;
    return byName(obj);
  }

  export function byName(name: string): TransactionType {
    switch (name) {
      case "unknown":
        return TransactionType.Unknown;
      case "createidentity":
        return TransactionType.CreateIdentity;
      case "createtokenaccount":
        return TransactionType.CreateTokenAccount;
      case "sendtokens":
        return TransactionType.SendTokens;
      case "createdataaccount":
        return TransactionType.CreateDataAccount;
      case "writedata":
        return TransactionType.WriteData;
      case "writedatato":
        return TransactionType.WriteDataTo;
      case "acmefaucet":
        return TransactionType.AcmeFaucet;
      case "createtoken":
        return TransactionType.CreateToken;
      case "issuetokens":
        return TransactionType.IssueTokens;
      case "burntokens":
        return TransactionType.BurnTokens;
      case "createlitetokenaccount":
        return TransactionType.CreateLiteTokenAccount;
      case "createkeypage":
        return TransactionType.CreateKeyPage;
      case "createkeybook":
        return TransactionType.CreateKeyBook;
      case "addcredits":
        return TransactionType.AddCredits;
      case "updatekeypage":
        return TransactionType.UpdateKeyPage;
      case "lockaccount":
        return TransactionType.LockAccount;
      case "burncredits":
        return TransactionType.BurnCredits;
      case "transfercredits":
        return TransactionType.TransferCredits;
      case "updateaccountauth":
        return TransactionType.UpdateAccountAuth;
      case "updatekey":
        return TransactionType.UpdateKey;
      case "activateprotocolversion":
        return TransactionType.ActivateProtocolVersion;
      case "remote":
        return TransactionType.Remote;
      case "signPending":
        return TransactionType.Remote;
      case "syntheticcreateidentity":
        return TransactionType.SyntheticCreateIdentity;
      case "syntheticwritedata":
        return TransactionType.SyntheticWriteData;
      case "syntheticdeposittokens":
        return TransactionType.SyntheticDepositTokens;
      case "syntheticdepositcredits":
        return TransactionType.SyntheticDepositCredits;
      case "syntheticburntokens":
        return TransactionType.SyntheticBurnTokens;
      case "syntheticforwardtransaction":
        return TransactionType.SyntheticForwardTransaction;
      case "systemgenesis":
        return TransactionType.SystemGenesis;
      case "directoryanchor":
        return TransactionType.DirectoryAnchor;
      case "blockvalidatoranchor":
        return TransactionType.BlockValidatorAnchor;
      case "systemwritedata":
        return TransactionType.SystemWriteData;
      default:
        throw new Error(`Unknown TransactionType '${name}'`);
    }
  }

  export function getName(v: TransactionType) {
    switch (v) {
      case TransactionType.Unknown:
        return "unknown";
      case TransactionType.CreateIdentity:
        return "createIdentity";
      case TransactionType.CreateTokenAccount:
        return "createTokenAccount";
      case TransactionType.SendTokens:
        return "sendTokens";
      case TransactionType.CreateDataAccount:
        return "createDataAccount";
      case TransactionType.WriteData:
        return "writeData";
      case TransactionType.WriteDataTo:
        return "writeDataTo";
      case TransactionType.AcmeFaucet:
        return "acmeFaucet";
      case TransactionType.CreateToken:
        return "createToken";
      case TransactionType.IssueTokens:
        return "issueTokens";
      case TransactionType.BurnTokens:
        return "burnTokens";
      case TransactionType.CreateLiteTokenAccount:
        return "createLiteTokenAccount";
      case TransactionType.CreateKeyPage:
        return "createKeyPage";
      case TransactionType.CreateKeyBook:
        return "createKeyBook";
      case TransactionType.AddCredits:
        return "addCredits";
      case TransactionType.UpdateKeyPage:
        return "updateKeyPage";
      case TransactionType.LockAccount:
        return "lockAccount";
      case TransactionType.BurnCredits:
        return "burnCredits";
      case TransactionType.TransferCredits:
        return "transferCredits";
      case TransactionType.UpdateAccountAuth:
        return "updateAccountAuth";
      case TransactionType.UpdateKey:
        return "updateKey";
      case TransactionType.ActivateProtocolVersion:
        return "activateProtocolVersion";
      case TransactionType.Remote:
        return "remote";
      case TransactionType.SyntheticCreateIdentity:
        return "syntheticCreateIdentity";
      case TransactionType.SyntheticWriteData:
        return "syntheticWriteData";
      case TransactionType.SyntheticDepositTokens:
        return "syntheticDepositTokens";
      case TransactionType.SyntheticDepositCredits:
        return "syntheticDepositCredits";
      case TransactionType.SyntheticBurnTokens:
        return "syntheticBurnTokens";
      case TransactionType.SyntheticForwardTransaction:
        return "syntheticForwardTransaction";
      case TransactionType.SystemGenesis:
        return "systemGenesis";
      case TransactionType.DirectoryAnchor:
        return "directoryAnchor";
      case TransactionType.BlockValidatorAnchor:
        return "blockValidatorAnchor";
      case TransactionType.SystemWriteData:
        return "systemWriteData";
      default:
        throw new Error(`Unknown TransactionType ${v}`);
    }
  }
}

export enum VoteType {
  /** Accept vote yea in favor of proposal. */
  Accept = 0,
  /** Reject vote nay against a proposal. */
  Reject = 1,
  /** Abstain chose not to vote on a proposal. */
  Abstain = 2,
  /** Suggest put forth a proposal. */
  Suggest = 3,
}

export type VoteTypeArgs = VoteType | string;

/** @ignore */
export namespace VoteType {
  export function fromObject(obj: VoteTypeArgs): VoteType {
    if (typeof obj === "number") return obj;
    return byName(obj);
  }

  export function byName(name: string): VoteType {
    switch (name) {
      case "accept":
        return VoteType.Accept;
      case "reject":
        return VoteType.Reject;
      case "abstain":
        return VoteType.Abstain;
      case "suggest":
        return VoteType.Suggest;
      default:
        throw new Error(`Unknown VoteType '${name}'`);
    }
  }

  export function getName(v: VoteType) {
    switch (v) {
      case VoteType.Accept:
        return "accept";
      case VoteType.Reject:
        return "reject";
      case VoteType.Abstain:
        return "abstain";
      case VoteType.Suggest:
        return "suggest";
      default:
        throw new Error(`Unknown VoteType ${v}`);
    }
  }
}
